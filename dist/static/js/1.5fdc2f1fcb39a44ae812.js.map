{"version":3,"sources":["webpack:///static/js/1.5fdc2f1fcb39a44ae812.js","webpack:///./~/zrender/lib/core/util.js?10f4","webpack:///./~/echarts/lib/echarts.js?68a2","webpack:///./~/zrender/lib/graphic/Path.js?c119","webpack:///./~/zrender/lib/core/vector.js?6654","webpack:///./~/echarts/lib/util/format.js?7f72","webpack:///./~/echarts/lib/util/graphic.js?e267","webpack:///./~/echarts/lib/util/model.js?e2bd","webpack:///./~/echarts/lib/util/number.js?43e3","webpack:///./~/zrender/lib/core/BoundingRect.js?76f6","webpack:///./~/zrender/lib/core/env.js?9ccc","webpack:///./~/echarts/lib/model/Model.js?f4df","webpack:///./~/echarts/lib/model/Component.js?0e02","webpack:///./~/zrender/lib/core/curve.js?9511","webpack:///./~/echarts/lib/util/clazz.js?3e66","webpack:///./~/echarts/lib/util/layout.js?2b1e","webpack:///./~/zrender/lib/contain/text.js?3a43","webpack:///./~/zrender/lib/core/matrix.js?97a2","webpack:///./~/zrender/lib/mixin/Eventful.js?223b","webpack:///./~/zrender/lib/tool/color.js?284f","webpack:///./~/element-ui/lib/theme-default/loading.css?8570","webpack:///./~/element-ui/lib/loading.js?0101","webpack:///./~/element-ui/lib/theme-default/loading.css?ffb0*","webpack:///./~/zrender/lib/config.js?2861","webpack:///./~/zrender/lib/container/Group.js?8d57","webpack:///./~/zrender/lib/core/PathProxy.js?69e9","webpack:///./~/zrender/lib/core/event.js?24ff","webpack:///./~/echarts/lib/model/mixin/makeStyleMapper.js?e2b1","webpack:///./~/echarts/lib/model/mixin/colorPalette.js?b454","webpack:///./~/echarts/lib/util/component.js?cc72","webpack:///./~/element-ui/lib/utils/popper.js?0605","webpack:///./~/element-ui/lib/utils/vue-popper.js?c27f","webpack:///./~/zrender/lib/core/timsort.js?0a74","webpack:///./~/zrender/lib/graphic/Displayable.js?5c45","webpack:///./~/zrender/lib/graphic/Gradient.js?5165","webpack:///./src/views/ex/mixin.js?02ef","webpack:///./~/echarts/lib/CoordinateSystem.js?2b30","webpack:///./~/echarts/lib/data/List.js?b096","webpack:///./~/zrender/lib/Element.js?325b","webpack:///./~/zrender/lib/animation/Animator.js?d2b9","webpack:///./~/zrender/lib/animation/requestAnimationFrame.js?6d88","webpack:///./~/zrender/lib/contain/util.js?0031","webpack:///./~/zrender/lib/core/guid.js?f0e4","webpack:///./~/zrender/lib/core/log.js?26a2","webpack:///./~/zrender/lib/graphic/Image.js?bf1b","webpack:///./~/zrender/lib/graphic/Pattern.js?a97e","webpack:///./~/zrender/lib/graphic/Style.js?22d9","webpack:///./~/zrender/lib/graphic/helper/poly.js?788c","webpack:///./~/echarts/lib/model/Series.js?186c","webpack:///./~/echarts/lib/view/Chart.js?72f3","webpack:///./~/element-ui/lib/theme-default/tooltip.css?14d7","webpack:///./~/echarts/lib/ExtensionAPI.js?e283","webpack:///./~/echarts/lib/component/helper/listComponent.js?566d","webpack:///./~/echarts/lib/component/legend.js?d893","webpack:///./~/echarts/lib/component/legend/LegendModel.js?bbe7","webpack:///./~/echarts/lib/component/legend/LegendView.js?124f","webpack:///./~/echarts/lib/component/legend/legendAction.js?b7a9","webpack:///./~/echarts/lib/component/legend/legendFilter.js?93b2","webpack:///./~/echarts/lib/component/tooltip.js?b491","webpack:///./~/echarts/lib/component/tooltip/TooltipContent.js?2c54","webpack:///./~/echarts/lib/component/tooltip/TooltipModel.js?19ac","webpack:///./~/echarts/lib/component/tooltip/TooltipView.js?ae52","webpack:///./~/echarts/lib/data/DataDiffer.js?f330","webpack:///./~/echarts/lib/data/helper/completeDimensions.js?9c9e","webpack:///./~/echarts/lib/loading/default.js?8a5f","webpack:///./~/echarts/lib/model/Global.js?b9d3","webpack:///./~/echarts/lib/model/OptionManager.js?a7a5","webpack:///./~/echarts/lib/model/globalDefault.js?fd54","webpack:///./~/echarts/lib/model/mixin/areaStyle.js?4e41","webpack:///./~/echarts/lib/model/mixin/boxLayout.js?92d7","webpack:///./~/echarts/lib/model/mixin/itemStyle.js?9011","webpack:///./~/echarts/lib/model/mixin/lineStyle.js?3579","webpack:///./~/echarts/lib/model/mixin/textStyle.js?e4c8","webpack:///./~/echarts/lib/model/series.js?56d0","webpack:///./~/echarts/lib/preprocessor/backwardCompat.js?f171","webpack:///./~/echarts/lib/preprocessor/helper/compatStyle.js?aff6","webpack:///./~/echarts/lib/util/symbol.js?be2c","webpack:///./~/echarts/lib/util/throttle.js?56b3","webpack:///./~/echarts/lib/view/Component.js?415a","webpack:///./~/echarts/lib/visual/seriesColor.js?4b6a","webpack:///./~/element-ui/lib/tooltip.js?f554","webpack:///./~/element-ui/lib/theme-default/tooltip.css?94cb*","webpack:///./~/zrender/lib/Handler.js?fbeb","webpack:///./~/zrender/lib/Layer.js?f586","webpack:///./~/zrender/lib/Painter.js?ee99","webpack:///./~/zrender/lib/Storage.js?7e93","webpack:///./~/zrender/lib/animation/Animation.js?8743","webpack:///./~/zrender/lib/animation/Clip.js?fef9","webpack:///./~/zrender/lib/animation/easing.js?64b6","webpack:///./~/zrender/lib/contain/arc.js?7367","webpack:///./~/zrender/lib/contain/cubic.js?b90e","webpack:///./~/zrender/lib/contain/line.js?4326","webpack:///./~/zrender/lib/contain/path.js?2e7f","webpack:///./~/zrender/lib/contain/quadratic.js?f589","webpack:///./~/zrender/lib/contain/windingLine.js?625a","webpack:///./~/zrender/lib/core/GestureMgr.js?00fd","webpack:///./~/zrender/lib/core/LRU.js?018e","webpack:///./~/zrender/lib/core/bbox.js?1b56","webpack:///./~/zrender/lib/dom/HandlerProxy.js?2fc7","webpack:///./~/zrender/lib/graphic/CompoundPath.js?8636","webpack:///./~/zrender/lib/graphic/LinearGradient.js?4250","webpack:///./~/zrender/lib/graphic/RadialGradient.js?895e","webpack:///./~/zrender/lib/graphic/Text.js?3244","webpack:///./~/zrender/lib/graphic/helper/roundRect.js?418d","webpack:///./~/zrender/lib/graphic/helper/smoothBezier.js?2713","webpack:///./~/zrender/lib/graphic/helper/smoothSpline.js?a17c","webpack:///./~/zrender/lib/graphic/mixin/RectText.js?94ea","webpack:///./~/zrender/lib/graphic/shape/Arc.js?2994","webpack:///./~/zrender/lib/graphic/shape/BezierCurve.js?f5c4","webpack:///./~/zrender/lib/graphic/shape/Circle.js?076e","webpack:///./~/zrender/lib/graphic/shape/Line.js?7728","webpack:///./~/zrender/lib/graphic/shape/Polygon.js?d37d","webpack:///./~/zrender/lib/graphic/shape/Polyline.js?3cdb","webpack:///./~/zrender/lib/graphic/shape/Rect.js?3b3d","webpack:///./~/zrender/lib/graphic/shape/Ring.js?b71c","webpack:///./~/zrender/lib/graphic/shape/Sector.js?9767","webpack:///./~/zrender/lib/mixin/Animatable.js?35cb","webpack:///./~/zrender/lib/mixin/Draggable.js?fbca","webpack:///./~/zrender/lib/mixin/Transformable.js?f61b","webpack:///./~/zrender/lib/tool/path.js?dc4b","webpack:///./~/zrender/lib/tool/transformPath.js?ddb2","webpack:///./~/zrender/lib/zrender.js?5dcd","webpack:///kt-pie-echart.vue","webpack:///dashboard.vue","webpack:///./src/views/ex/dashboard.vue?1c39","webpack:///./src/components/kt-pie-echart.vue?9747","webpack:///./~/echarts/lib/action/createDataSelectAction.js","webpack:///./~/echarts/lib/chart/pie.js","webpack:///./~/echarts/lib/chart/pie/PieSeries.js","webpack:///./~/echarts/lib/chart/pie/PieView.js","webpack:///./~/echarts/lib/chart/pie/labelLayout.js","webpack:///./~/echarts/lib/chart/pie/pieLayout.js","webpack:///./~/echarts/lib/component/helper/selectableMixin.js","webpack:///./~/echarts/lib/processor/dataFilter.js","webpack:///./~/echarts/lib/visual/dataColor.js","webpack:///./src/views/ex/dashboard.vue?2752","webpack:///./src/components/kt-pie-echart.vue?bae4","webpack:///./src/components/kt-pie-echart.vue","webpack:///./src/views/ex/dashboard.vue","webpack:///./src/views/ex/dashboard.vue?c669","webpack:///./src/components/kt-pie-echart.vue?4cbd"],"names":["webpackJsonp","module","exports","clone","source","result","typeStr","objToString","call","i","len","length","TYPED_ARRAY","constructor","from","BUILTIN_OBJECT","isDom","key","hasOwnProperty","merge","target","overwrite","isObject","targetProp","sourceProp","isArray","isBuildInObject","mergeAll","targetAndSources","extend","defaults","overlay","createCanvas","document","createElement","getContext","_ctx","util","indexOf","array","value","inherits","clazz","baseClazz","F","clazzPrototype","prototype","prop","superClass","mixin","isArrayLike","data","each","obj","cb","context","forEach","nativeForEach","map","nativeMap","push","reduce","memo","nativeReduce","filter","nativeFilter","find","bind","func","args","nativeSlice","arguments","apply","concat","curry","this","isFunction","isString","type","nodeType","ownerDocument","retrieve","values","slice","Function","assert","condition","message","Error","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","Object","toString","arrayProto","Array","noop","__webpack_require__","global","createRegisterEventWithLowercaseName","method","eventName","handler","toLowerCase","Eventful","MessageCenter","ECharts","dom","theme","opts","prioritySortFunc","a","b","prio","themeStorage","id","group","_dom","zr","_zr","zrender","init","renderer","devicePixelRatio","width","height","_throttledZrFlush","throttle","zrUtil","flush","_theme","_chartsViews","_chartsMap","_componentsViews","_componentsMap","_api","ExtensionAPI","_coordSysMgr","CoordinateSystemManager","_messageCenter","_initEvents","resize","_pendingActions","timsort","visualFuncs","dataProcessorFuncs","animation","on","_onframe","doConvertPixel","methodName","finder","ecModel","_model","coordSysList","getCoordinateSystems","modelUtil","parseFinder","coordSys","__DEV__","console","warn","toggleHighlight","payload","eachComponent","mainType","query","seriesModel","index","chartView","__viewId","__alive","doDispatchAction","silent","actionWrap","actions","actionInfo","updateMethod","update","IN_MAIN_PROCESS","payloads","batched","batch","item","eventObj","eventObjBatch","isHighlightOrDownplay","batchItem","action","event","updateMethods","OPTION_UPDATED","prepareAndUpdate","trigger","flushPendingActions","pendingActions","shift","invokeUpdateMethod","api","component","componentModel","__model","updateZ","eachSeries","idx","chart","updateProgressiveAndBlend","updateHoverLayerStatus","prepareView","isComponent","viewList","viewMap","componentType","model","viewId","view","classType","ComponentModel","parseClassType","Clazz","ComponentView","getClass","main","sub","ChartView","add","__id","remove","dispose","splice","processData","process","stackSeriesData","stackedDataMap","series","stack","get","getData","previousStack","stackedOn","doLayout","visual","isLayout","doVisualEncoding","clearColorPalette","doRender","componentView","render","storage","elCount","traverse","el","isGroup","env","node","useHoverLayer","ignore","frameDrawNum","needProgressive","progressive","Math","floor","stopAnimation","blendMode","canvasSupported","setStyle","z","zlevel","enableConnect","updateConnectedChartsStatus","charts","status","otherChart","STATUS_KEY","STATUS_PENDING","STATUS_UPDATING","STATUS_UPDATED","eventActionMap","actionType","eventType","connectedGroups","makeActionFromEvent","otherCharts","instances","dispatchAction","window","GlobalModel","OptionManager","SeriesModel","graphic","colorTool","PRIORITY_PROCESSOR_FILTER","PRIORITY_PROCESSOR_STATISTIC","PRIORITY_VISUAL_LAYOUT","PRIORITY_VISUAL_GLOBAL","PRIORITY_VISUAL_CHART","PRIORITY_VISUAL_COMPONENT","PRIORITY_VISUAL_BRUSH","HAS_GRADIENT_OR_PATTERN_BG","off","one","echartsProto","getDom","getZr","setOption","option","notMerge","lazyUpdate","optionManager","__lastOnlyGraphic","o","optionPreprocessorFuncs","setTheme","log","getModel","getOption","getWidth","getHeight","getRenderedCanvas","pixelRatio","backgroundColor","list","getDisplayList","painter","getDataURL","excludeComponents","excludesComponentViews","self","url","toDataURL","getConnectedDataURL","groupId","mathMin","min","mathMax","max","MAX_NUMBER","Infinity","left","top","right","bottom","canvasList","dpr","canvas","boundingRect","getBoundingClientRect","targetCanvas","img","Image","style","x","y","image","refreshImmediately","convertToPixel","convertFromPixel","containPixel","models","coordinateSystem","containPoint","getVisual","visualType","defaultMainType","dataIndexInside","indexOfRawIndex","dataIndex","getItemVisual","coordSysMgr","restoreData","create","isSingleCanvas","configLayer","clearColor","colorArr","parse","stringify","colorStops","background","updateView","clearAllVisual","updateVisual","updateLayout","highlight","downplay","optionChanged","resetOption","_loadingFX","showLoading","name","cfg","hideLoading","loadingEffects","opt","browser","weChat","MOUSE_EVENT_NAMES","eveName","e","params","dataModel","getSeriesByIndex","seriesIndex","getDataParams","dataType","eventData","isDisposed","_disposed","clear","idBase","Date","groupIdBase","DOM_ATTRIBUTE_KEY","echarts","version","dependencies","replace","nodeName","toUpperCase","clientWidth","clientHeight","setAttribute","connect","disConnect","getInstanceByDom","getAttribute","getInstanceById","registerTheme","registerPreprocessor","preprocessorFunc","registerProcessor","priority","processorFunc","isNaN","registerAction","registerCoordinateSystem","CoordinateSystem","register","registerLayout","layoutFunc","registerVisual","visualFunc","registerLoading","loadingFx","extendComponentModel","extendComponentView","extendSeriesModel","extendChartView","setCanvasCreator","creator","List","Model","number","format","matrix","vector","color","PRIORITY","PROCESSOR","FILTER","STATISTIC","VISUAL","LAYOUT","GLOBAL","CHART","COMPONENT","BRUSH","Path","Displayable","path","PathProxy","pathContain","Pattern","getCanvasPattern","abs","__dirtyPath","strokeContainThreshold","brush","ctx","prevEl","hasStroke","hasFill","fill","stroke","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","__dirty","rect","getBoundingRect","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","scale","getGlobalScale","setScale","beginPath","setLineDashOffset","buildPath","shape","rebuildPath","restoreTransform","text","drawRectText","shapeCfg","inBundle","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","copy","w","lineWidth","lineScale","strokeNoScale","getLineScale","contain","localPos","transformCoordToLocal","pathData","containStroke","dirty","dirtyPath","__zr","refresh","__clipTarget","animateShape","loop","animate","attrKV","setShape","m","transform","sqrt","Sub","extendFrom","defaultShape","thisShape","ArrayCtor","Float32Array","out","v","set","v1","v2","scaleAndAdd","lenSquare","mul","div","dot","s","normalize","d","distance","distanceSquare","negate","lerp","t","applyTransform","lengthSquare","dist","distSquare","numberUtil","textContain","formatUtil","addCommas","split","toCamelCase","str","upperCaseFirst","match","group1","charAt","normalizeCssArray","val","encodeHTML","String","TPL_VAR_ALIAS","wrapVar","varName","seriesIdx","formatTpl","tpl","paramsList","seriesLen","$vars","alias","k","s2d","formatTime","date","parseDate","getFullYear","M","getMonth","getDate","h","getHours","getMinutes","getSeconds","capitalFirst","substr","truncateText","hasFillOrStroke","fillOrStroke","liftColor","lift","cacheElementStl","__hoverStlDirty","hoverStyle","__hoverStl","normalStyle","__normalStl","doSingleEnterHover","__isHover","addHover","z2","doSingleLeaveHover","normalStl","removeHover","doEnterHover","child","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__hoverSilentOnTouch","zrByTouch","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","props","animatableModel","animationEnabled","ifEnableAnimation","getShallow","postfix","duration","animationEasing","animationDelay","animateTo","attr","pathTool","round","Group","Text","Circle","Sector","Ring","Polygon","Polyline","Rect","Line","BezierCurve","Arc","CompoundPath","LinearGradient","RadialGradient","BoundingRect","extendShape","extendPath","extendFromString","makePath","layout","createFromString","aspect","cx","cy","resizePath","mergePath","pathRect","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","x1","x2","y1","y2","subPixelOptimizeRect","originX","originY","originWidth","originHeight","position","positiveOrNegative","doubledPosition","setHoverStyle","hoverSilentOnTouch","setText","textStyle","labelModel","labelPosition","labelColor","textStyleModel","textDistance","textFont","getFont","textPosition","textFill","getTextColor","updateProps","initProps","getTransform","ancestor","mat","identity","getLocalTransform","parent","vertex","invert","transformDirection","direction","hBase","vBase","groupTransition","g1","g2","getElMap","g","elMap","anid","getAnimatableProps","rotation","elMap1","oldEl","newProp","has","nubmerUtil","normalizeToArray","defaultEmphasis","subOpts","emphasisOpt","emphasis","normalOpt","normal","subOptName","LABEL_OPTIONS","getDataItemValue","dataItem","isDataItemOption","converDataValue","dimInfo","dimType","isFinite","NaN","createDataFormatModel","dataFormatMixin","subType","seriesName","rawValue","getRawValue","rawDataIndex","getRawIndex","getName","itemOpt","getRawDataItem","componentSubType","seriesType","getFormattedLabel","dimIndex","itemModel","getItemModel","formatter","formatTooltip","mappingToExists","exists","newCptOptions","exist","cptOption","isIdInner","makeIdAndName","mapResult","idMap","existCpt","keyInfo","idNum","compressBatches","batchA","batchB","makeMap","sourceBatch","otherMap","seriesId","dataIndices","otherDataIndices","j","lenj","mapToArray","isData","mapA","mapB","queryDataIndex","indexOfName","parsedKey","queryType","queryParam","queryComponents","_trim","RADIAN_EPSILON","linearMap","domain","range","clamp","subDomain","subRange","parsePercent","percent","all","parseFloat","precision","toFixed","asc","arr","sort","getPrecision","count","getPrecisionSafe","dotIndex","getPixelPrecision","dataExtent","pixelExtent","LN10","dataQuantity","sizeQuantity","MAX_SAFE_INTEGER","remRadian","radian","pi2","PI","isRadianAroundZero","ret","quantity","pow","nice","nf","exp10","f","reformIntervals","littleThan","lg","interval","close","curr","currClose","vec2","v2ApplyTransform","union","other","lt","rb","lb","rt","maxX","maxY","sx","sy","translate","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","detect","ua","os","firefox","ie","edge","test","touchEventsSupported","pointerEventsSupported","navigator","userAgent","parentModel","clazzUtil","mergeOption","ignoreParent","thisParentModel","isEmpty","Ctor","setReadOnly","properties","enableClassExtend","getDependencies","deps","getClassesByMainType","arrayPush","componentUtil","componentIndex","defaultOption","dependentModels","uid","layoutMode","$constructor","extraOpt","getUID","mergeDefaultAndTheme","inputPositionParams","getLayoutParams","themeModel","getTheme","getDefaultOption","mergeLayoutParam","optionUpdated","newCptOption","isInit","optList","Class","__defaultOption","getReferringComponents","enableClassManagement","registerWhenExtend","enableSubTypeDefaulter","enableTopologicalTravel","isAroundZero","EPSILON","isNotAroundZero","cubicAt","p0","p1","p2","p3","onet","cubicDerivativeAt","cubicRootAt","roots","c","A","B","C","n","t1","disc","K","t2","discSqrt","mathSqrt","Y1","Y2","mathPow","ONE_THIRD","T","theta","acos","ASqrt","tmp","cos","THREE_SQRT","sin","t3","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","x0","y0","x3","y3","prev","next","d1","d2","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","v2Create","superCall","superApply","TYPE_DELIMITER","IS_CONTAINER","RootClass","mandatoryMethods","proto","ExtendedClass","entity","options","makeContainer","container","registerClass","componentTypeMain","throwWhenNotFound","hasClass","getAllClassMainTypes","types","hasSubTypes","originalExtend","boxLayout","orient","gap","maxWidth","maxHeight","currentLineMaxSize","eachChild","nextX","nextY","nextChild","childAt","nextChildRect","moveX","newline","moveY","LOCATION_PARAMS","box","vbox","hbox","getAvailableSize","positionInfo","containerRect","margin","containerWidth","containerHeight","getLayoutRect","verticalMargin","horizontalMargin","positionElement","hv","boundingMode","needLocalTransform","elPos","dx","dy","targetOption","newOption","names","newParams","newValueCount","merged","mergedValueCount","enoughParamNumber","ignoreSize","hasProp","hasValue","hNames","vNames","hResult","vResult","copyLayoutParams","getTextWidth","textWidthCache","textLines","l","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getTextRect","textAlign","textBaseline","textLineLen","lineHeight","adjustTextPositionOnRect","textRect","textHeight","halfHeight","ellipsis","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","join","charCode","charCodeAt","font","m1","m2","out0","out1","out2","out3","out4","out5","rotate","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","arrySlice","_$handlers","_h","isSilent","newList","argLen","triggerWithContext","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseInt","parseCssFloat","cssHueToRgb","p","colorStr","kCSSColorTable","op","ep","fname","alpha","pop","hsla2rgba","iv","hsla","rgba","rgba2hsla","H","S","R","G","vMin","vMax","delta","L","deltaR","deltaG","deltaB","level","toHex","fastMapToColor","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","sources","mappings","file","sourcesContent","sourceRoot","modules","moduleId","installedModules","loaded","0","50","66","117","_interopRequireDefault","__esModule","default","_directive","_directive2","_index","_index2","install","Vue","use","$loading","directive","service","118","_vue","_vue2","_class","Mask","toggleLoading","binding","nextTick","modifiers","fullscreen","originalPosition","body","originalOverflow","overflow","addClass","mask","insertDom","removeClass","property","scroll","maskStyle","documentElement","domVisible","display","keys","lock","appendChild","domInserted","$el","oldValue","unbind","removeChild","parentNode","119","__vue_exports__","__vue_options__","__vue_template__","staticRenderFns","120","customClass","121","_vm","$createElement","_c","staticClass","class","is-fullscreen","attrs","viewBox","r","_s","_e","122","_loading","_loading2","_merge","_merge2","LoadingConstructor","fullscreenLoading","undefined","$destroy","addStyle","instance","Loading","querySelector","123","content","locals","config","debugMode","Element","_children","__storage","children","childOfName","childCount","_doAdd","addBefore","nextSibling","addToMap","addChildrenToStorage","delFromMap","delChildrenFromStorage","removeAll","includeChildren","tmpRect","tmpMat","invisible","childRect","curve","bbox","CMD","Q","Z","min2","max2","mathCos","mathSin","mathAbs","hasTypedArray","_len","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","moveTo","addData","lineTo","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","arc","startAngle","endAngle","anticlockwise","arcTo","radius","closePath","toStatic","lineDashSum","offset","setData","appendPath","appendSize","appendPathData","cmd","_expandData","_prevCmd","newData","dash","dashSum","nDash","bezierLen","tmpLen","Number","MAX_VALUE","xi","yi","fromLine","fromCubic","fromQuadratic","rx","ry","fromArc","ux","uy","dTheta","psi","fs","scaleX","scaleY","isEllipse","clientToLocal","calculate","defaultGetZrXY","layerX","offsetX","zrX","zrY","layerY","offsetY","clientX","clientY","normalizeEvent","isTouch","touch","targetTouches","changedTouches","zrDelta","wheelDelta","detail","addEventListener","isDomLevel2","attachEvent","removeEventListener","detachEvent","stop","preventDefault","stopPropagation","cancelBubble","returnValue","Dispatcher","excludes","propName","_colorIdx","_colorNameMap","getColorFromPalette","scope","colorIdx","colorNameMap","colorPalette","base","DELIMITER","random","subTypeDefaulters","registerSubTypeDefaulter","defaulter","determineSubType","dependencyGetter","makeDepndencyGraph","fullNameList","graph","noEntryList","thisItem","createDependencyGraphItem","originalDeps","availableDeps","getAvailableDependencies","entryCount","dependentName","predecessor","thatItem","successor","dep","topologicalTravel","targetNameList","callback","removeEdge","succComponentType","removeEdgeAndAdd","targetNameSet","currComponentType","currVertex","isInTargetNameSet","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","Symbol","iterator","root","factory","Popper","reference","popper","_reference","jquery","state","isNotDefined","isConfig","_popper","_options","assign","DEFAULTS","modifier","modifiersIgnored","placement","_getPosition","_setupEventListeners","getOuterSizes","element","_display","_visibility","visibility","styles","offsetWidth","getComputedStyle","marginTop","marginBottom","marginLeft","marginRight","offsetHeight","getOppositePlacement","hash","matched","getPopperClientRect","popperOffsets","offsets","getArrayKeyIndex","keyToFind","getStyleComputedProperty","css","getOffsetParent","offsetParent","getScrollParent","scrollTop","isFixed","is_numeric","unit","functionToCheck","getType","getOffsetRect","elementRect","offsetLeft","offsetTop","isIE","rectTop","tagName","getOffsetRectRelativeToCustomParent","fixed","parentRect","scrollParent","scrollLeft","getSupportedPropertyName","prefixes","toCheck","gpuAcceleration","boundariesElement","boundariesPadding","preventOverflowOrder","flipBehavior","arrowElement","forceAbsolute","destroy","removeAttribute","_removeEventListeners","removeOnDestroy","_originalPlacement","_getOffsets","boundaries","_getBoundaries","runModifiers","updateCallback","onCreate","onUpdate","addClassNames","classNames","className","classList","addAttributes","attributes","attribute","defaultConfig","contentType","arrowTagName","arrowClassNames","arrowAttributes","innerHTML","textContent","arrow","querySelectorAll","isParentFixed","referenceOffsets","popperRect","updateBound","padding","html","scrollHeight","scrollWidth","offsetParentRect","ends","modifiersToRun","isModifierRequired","requesting","requested","applyStyle","prefixedProperty","basePlacement","shiftVariation","shiftOffsets","start","end","axis","preventOverflow","order","check","keepTogether","flip","flipped","placementOpposite","variation","flipOrder","step","_flip","contains","arrowStyle","isVertical","side","altSide","opSide","arrowSize","center","sideValue","defineProperty","enumerable","configurable","writable","TypeError","to","nextSource","keysArray","nextIndex","nextKey","desc","getOwnPropertyDescriptor","_popper2","_vuePopup","Boolean","visibleArrow","transition","appendToBody","showPopper","watch","immediate","$emit","updatePopper","destroyPopper","methods","createPopper","_this","popperElm","$refs","referenceElm","$slots","elm","appendArrow","popperJS","_","resetTransformOrigin","$nextTick","zIndex","PopupManager","nextZIndex","doDestroy","placementMap","origin","transformOrigin","appended","beforeDestroy","deactivated","$options","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","mid","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","Style","__clipPaths","RectText","draggable","dragging","culling","cursor","rectHover","beforeBrush","afterBrush","rectContain","coord","animateStyle","useStyle","Gradient","addColorStop","updateStatusIconMap","已更新","更新中","待更新","异常","excuteStatusIconMap","已执行","待执行","不可执行","已过期","filters","updateStatusIcon","excuteStatusIcon","_coordinateSystems","coordinateSystemCreators","coordinateSystems","creater","coordinateSystemCreator","normalizeDimensions","dimensions","cloneListForMapAndSample","original","excludeDimensions","allDimensions","getDimensionInfo","hostModel","transferProperties","_storage","originalStorage","dim","dimStore","UNDEFINED","globalObj","Float64Array","Int32Array","dataCtors","float","int","ordinal","time","DataDiffer","TRANSFERABLE_PROPERTIES","__wrappedMethods","dimensionInfos","dimensionNames","dimensionName","dimensionInfo","stackable","_dimensionInfos","indices","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawData","_extent","listProto","hasItemOption","getDimension","initData","nameList","dimValueGetter","size","dimensionInfoMap","idList","nameRepeatCount","DataCtor","dimName","dimStorage","stackedValue","getValues","getDataExtent","dimData","dimExtent","getSum","sum","rawIndex","indexOfNearest","maxDistance","nearestIdx","minDist","diff","rawIdx","getId","dims","dimSize","filterSelf","newIndices","keep","mapArray","tmpRetValue","retValue","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","otherList","otherIdList","prefix","setVisual","setLayout","getLayout","getItemLayout","setItemLayout","clearItemLayouts","itemVisual","setItemVisual","setItemDataAndSeriesIndex","setItemGraphicEl","getItemGraphicEl","eachItemGraphicEl","cloneShallow","dimensionInfoList","wrapMethod","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","guid","Transformable","Animatable","clipPath","drift","decomposeTransform","beforeUpdate","afterUpdate","updateTransform","hide","show","setClipPath","addSelfToZr","removeClipPath","removeSelfFromZr","animators","addAnimator","removeAnimator","defaultGetter","defaultSetter","interpolateNumber","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isArraySame","catmullRomInterpolateArray","catmullRomInterpolate","v0","cloneValue","rgba2String","createTrackClip","animator","easing","oneTrackDone","keyframes","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","lastValue","_target","lastFrame","lastFramePercent","onframe","frame","clip","Clip","life","_loop","delay","_delay","ondestroy","Animator","_tracks","_clipCount","_doneList","_onframeList","_clipList","when","tracks","during","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","forwardToLast","clipList","removeClip","done","getClips","requestAnimationFrame","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","setTimeout","PI2","normalizeRadian","angle","idStart","ZImage","LRU","globalImageCache","src","_image","cachedImgObj","onload","pending","put","sWidth","sHeight","drawImage","repeat","_canvasPattern","createPattern","createLinearGradient","canvasGradient","createRadialGradient","STYLE_COMMON_PROPS","opacity","shadowBlur","shadowOffsetX","shadowOffsetY","textStroke","textVerticalAlign","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","textRotation","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","newStyle","styleProto","smoothSpline","smoothBezier","points","smooth","controlPoints","smoothConstraint","cp1","cp2","colorPaletteMixin","legendDataProvider","visualColorAccessPath","_dataBeforeProcessed","getInitialData","_data","label","fillDataTextStyle","newSeriesOption","getLinkedData","getRawData","coordDimToDataDim","coordDim","dataDimToCoordDim","dataDim","getBaseAxis","multipleSeries","formatArrayValue","valStr","formattedValue","colorEl","getAxisTooltipDataIndex","getTooltipPosition","Chart","elSetState","dataIdx","chartProto","chartInstance","echartsAPIList","positionGroup","getBoxLayoutParams","addBackground","getItemStyle","LegendModel","selected","_updateData","legendData","hasSelected","isSelected","select","availableNames","getSeries","_availableNames","selectedMode","unSelect","toggleSelected","align","borderColor","borderWidth","itemGap","itemWidth","itemHeight","inactiveColor","tooltip","dispatchSelectAction","dispatchHighlightAction","dataName","dispatchDownplayAction","symbolCreator","listComponentHelper","_symbolTypeStore","legendModel","selectMode","itemAlign","legendDrawedMap","getSeriesByName","legendSymbolType","symbolType","itemGroup","_createItem","eachRawSeries","itemIcon","tooltipModel","legendGlobalTooltipModel","createSymbol","textX","hitRect","formatterParams","legendIndex","legendSelectActionHandler","selectedMap","isToggleSelect","isItemSelected","legendModels","findComponents","filterSeries","assembleTransition","transitionCurve","transitionText","vendors","vendorPrefix","assembleFont","cssText","fontSize","assembleCssText","transitionDuration","zrColor","borderName","camelCase","TooltipContent","_x","_y","_container","_show","_hideTimeout","onmouseenter","enterable","clearTimeout","_inContent","onmousemove","eventUtil","dispatch","onmouseleave","hideLater","_hideDelay","gCssText","stl","currentStyle","defaultView","domStyle","setContent","isShow","showContent","triggerOn","alwaysShowContent","confine","showDelay","hideDelay","borderRadius","extraCssText","axisPointer","animationDurationUpdate","animationEasingUpdate","lineStyle","crossStyle","shadowStyle","dataEqual","makeLineShape","makeRectShape","makeSectorShape","r0","clockwise","refixTooltipPosition","viewWidth","viewHeight","confineTooltipPosition","calcTooltipPosition","domWidth","domHeight","rectWidth","rectHeight","updatePosition","positionExpr","pos","ifSeriesSupportAxisTrigger","_axisPointers","tooltipContent","_tooltipContent","_manuallyShowTip","_manuallyHideTip","_tooltipModel","_ecModel","_lastHover","_alwaysShowContent","_seriesGroupByAxis","_prepareAxisTriggerData","crossText","_crossText","_lastX","_lastY","_refreshUpdateTimeout","_tryShow","_mousemove","_hide","_showTimeout","seriesHaveDataOnIndex","_series","isTriggerAxis","point","dataToPoint","findHover","seriesGroupByAxis","baseAxis","getAxis","globalTrigger","_showAxisTooltip","_ticket","_hideAxisPointer","_resetLastHover","_showItemTooltipContent","tooltipOpt","subTooltipModel","defaultHtml","asyncTicket","_showTooltipContent","axisPointerModel","axisPointerType","_showAxisPointer","allNotShow","seriesCoordSysSameAxis","allCoordSys","pointToData","axisType","contentNotChange","lastHover","valIndex","enableAnimation","_showSinglePointer","_showPolarPointer","_showCartesianPointer","_dispatchAndShowSeriesTooltipContent","cartesian","moveGridLine","otherExtent","targetShape","pointerEl","_getPointerElement","moveAnimation","moveGridShadow","bandWidth","getBandWidth","span","getGlobalExtent","_updateCrossText","otherAxis","single","moveSingleLine","getRect","polar","movePolarLine","mouseCoord","pointToCoord","coordToPoint","movePolarShadow","angleAxis","getAngleAxis","radiusAxis","getRadiusAxis","getExtent","crossStyleModel","getLabel","pointerModel","initShape","axisPointers","coordSysName","pointerType","styleModel","isShadow","elementType","seriesList","sampleSeriesIndex","rootTooltipModel","baseDimIndex","payloadBatch","firstDataIndex","firstLine","seriesTooltipModel","ticket","cbTicket","defaultKeyGetter","oldArr","newArr","oldKeyGetter","newKeyGetter","_old","_new","_oldKeyGetter","_newKeyGetter","initIndexMap","keyArr","keyGetter","existence","_add","_update","_remove","execute","oldDataIndexMap","newDataIndexMap","oldDataKeyArr","newDataKeyArr","unshift","completeDimensions","defaultNames","extraPrefix","value0","retrieveValue","guessOrdinal","textColor","maskColor","lineCap","labelRect","mergeTheme","themeItem","initBase","baseOption","OPTION_INNER_KEY","_seriesIndices","globalDefault","getComponentsByTypes","componentsMap","existComponent","createSeriesIndices","seriesModels","filterBySubType","components","cpt","assertSeriesInitialized","_optionManager","mountOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","mediaOption","visitComponent","newCptOptionList","resultItem","ComponentModelClass","newCptTypes","componentOption","getComponent","cpts","isIdArray","isNameArray","getQueryCond","q","indexAttr","idAttr","nameAttr","doFilter","queryCond","queryResult","oneSeries","getSeriesByType","rawSeriesIndex","eachSeriesByType","eachRawSeriesByType","isSeriesFiltered","filteredSeries","componentTypes","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","parseRawOption","rawOption","isNew","mediaDefault","timelineOptions","mediaList","timelineOpt","timeline","media","singleMedia","preProcess","applyMediaQuery","ecWidth","ecHeight","realMap","aspectratio","applicatable","QUERY_REG","operator","realAttr","real","expect","indicesEquals","indices1","indices2","oldOption","newCptOpt","oldCptOpt","oldOptionBackup","newParsedOption","isRecreate","optionBackup","timelineModel","getCurrentIndex","platform","fontFamily","fontStyle","fontWeight","animationDuration","animationThreshold","progressiveThreshold","hoverLayerThreshold","getAreaStyle","getBorderLineDash","lineType","getLineStyle","getLineDash","dotSize","dashSize","gTextStyleModel","compatLayoutProperties","LAYOUT_PROPERTIES","compatStyle","COMPATITABLE_COMPONENTS","COMPATITABLE_SERIES","seriesOpt","clockWise","pointerColor","dataRange","visualMap","componentName","compatItemStyle","itemStyleOpt","itemStyle","POSSIBLE_STYLES","normalItemStyleOpt","emphasisItemStyleOpt","markPoint","markLine","mpData","mlData","Triangle","Diamond","Pin","asin","tanX","tanY","cpLen","cpLen2","Arrow","symbolCtors","line","roundRect","square","circle","diamond","pin","triangle","symbolShapeMakers","symbolBuildProxies","proxySymbol","symbolPathSetColor","symbolStyle","symbolShape","__isEmptyBrush","symbolUtil","symbolPath","setColor","lib","ORIGIN_METHOD","RATE","THROTTLE_TYPE","fn","debounce","exec","lastExec","getTime","timer","currCall","lastCall","createOrUpdate","fnAttr","throttleType","originFn","lastThrottleType","lastRate","Component","componentProto","encodeColor","colorAccessPath","53","280","_main","_main2","281","282","_vuePopper","_vuePopper2","mixins","openDelay","disabled","manual","effect","handleShowPopper","timeout","handleClosePopper","283","mouseenter","mouseleave","ref","after-leave","directives","rawName","expression","domProps","makeEventPacket","eveType","gestureEvent","pinchX","pinchY","pinchScale","EmptyProxy","isHover","displayable","Draggable","handlerNames","Handler","proxy","painterRoot","_hovered","_lastTouchMoment","mousemove","hovered","lastHovered","setCursor","dispatchToElement","mouseout","innerDom","toElement","relatedTarget","eventArgs","setCursorStyle","cursorStyle","targetEl","eventHandler","eventPacket","eachOtherLayer","layer","exclude","_downel","_upel","returnFalse","createDom","newDom","newDomStyle","Layer","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","initContext","createBackBuffer","clearAll","haveMotionBLur","clearRect","clearColorGradientOrPattern","__canvasGradient","save","fillRect","restore","parseInt10","isLayerValid","isBuildin","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","clipPaths","prevClipPaths","doClip","createRoot","domRoot","MAX_PROGRESSIVE_LAYER_NUMBER","Painter","singleCanvas","_opts","_singleCanvas","rootStyle","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","_getSize","_domRoot","pathToImage","_createPathToImage","_progressiveLayers","_hoverlayer","_hoverElements","getViewportRoot","paintAll","_paintList","refreshHover","_startProgessive","__hoverMir","elMirror","__from","hoverElements","clearHover","hoverLayer","displayableSortFunc","getLayer","originalEl","invTransform","_doPaintEl","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuildinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","clearLayer","imageLayer","displayList","whIdx","wh","cwh","plt","prb","_pathToImage","pathTransform","ImageShape","imgShape","me","shapeCompareFunc","Storage","_elements","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","_updateAndAddDisplayable","addRoot","delRoot","elId","elements","_renderList","Animation","stage","_clips","_running","_time","_pausedTime","_pauseStart","_paused","clips","deferredEvents","deferredClips","_needsRemove","fire","_startLoop","pause","resume","_life","_initialized","onrestart","easingFuncs","globalTime","_startTime","easingFunc","schedule","restart","remainder","arg","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","_l","atan2","_a","_b","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","x_","windingQuadratic","y_","windingArc","dir","containPath","isStroke","windingLine","cubic","quadratic","pointPair","GestureMgr","_track","recognize","_doTrack","_recognize","touches","trackItem","recognizers","gestureInfo","pinch","track","pinchEnd","pinchPre","pinchCenter","LinkedList","head","tail","linkedListProto","insert","entry","Entry","insertEntry","maxSize","_list","_map","_maxSize","LRUProto","leastUsedEntry","extremity","fromPoints","xDim","yDim","tx","ty","vec2Min","vec2Max","eventNameFix","processGesture","gestureMgr","_gestureMgr","setTouchTimer","_touching","_touchTimer","useTouchEvent","initDomHandler","makeMouseHandler","touchHandlerNames","_handlers","domHandlers","mouseHandlerNames","HandlerDomProxy","mountHandlers","eventTool","TOUCH_CLICK_DELAY","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","paths","_updatePathDirty","globalCoord","fillText","strokeText","r1","r2","r3","r4","total","v2Min","v2Max","v2Scale","v2Distance","v2Add","isLoop","constraint","prevPoint","nextPoint","cps","d0","cp0","interpolate","segs","w2","w3","maxValue","lastIndexOf","baseline","verticalAlign","shadowColor","textShadowColor","unitX","unitY","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","curveTool","pointAt","tangentAt","polyHelper","roundRectHelper","animatingShape","pathSplitted","_animateToShallow","objShallow","propertyCount","_dragStart","_drag","_dragEnd","draggingTarget","_draggingTarget","dropTarget","lastDropTarget","_dropTarget","mIdentity","transformableProto","parentHasTransform","tmpTransform","transformCoordToGlobal","processArc","fa","psiDeg","xp","yp","lambda","cxp","cyp","vAngle","u","vRatio","createPathProxyFromString","cs","cc","RegExp","prevCmd","cpx","cpy","ctlPtx","ctlPty","createPathOptions","pathProxy","transformPath","vMag","pathEls","pathList","pathEl","pathBundle","nPoint","mathAtan2","delInstance","HandlerProxy","useVML","painterCtors","ZRender","getInstance","registerPainter","rendererType","vml","handerProxy","_needsRefresh","oldDelFromMap","oldAddToMap","zLevel","_needsRefreshHover","refreshHoverImmediately","clearAnimation","_lodash","_lodash2","_echarts","_echarts2","mounted","echart","legend","avoidLabelOverlap","labelLine","chartOption","_promise","_promise2","_loading3","_loading4","_tooltip","_base","_tooltip3","_tooltip4","_resources","_ktPieEchart","_ktPieEchart2","_mixin","_mixin2","KtPieEchart","ElTooltip","toDetails","product","$router","subsistGet","subsist","then","json","balance","stockGet","_this2","stock","pieChartOption","by_consignee","consignee","liquidationGet","_this3","liquidation","summary","virtualAssets","groupBy","virtual_assets","_this4","instLoading","catch","actionInfos","dataSelectableMixin","PieSeries","updateSelectedMap","_defaultLabelLine","labelLineNormalOpt","labelLineEmphasisOpt","legendHoverLink","hoverAnimation","minAngle","selectedOffset","updateDataSelected","hasAnimation","toggleItemSelected","midAngle","PiePiece","onEmphasis","polyline","hoverIgnore","onNormal","normalIgnore","sector","updateData","getLabelStyle","isLabelInside","piePieceProto","firstCreate","sectorShape","itemStyleModel","visualColor","lineJoin","_updateLabel","labelText","labelLayout","linePoints","labelHoverModel","labelLineModel","labelLineHoverModel","Pie","sectorGroup","_sectorGroup","oldData","isFirstRender","onSectorClick","piePiece","newIdx","oldIdx","_createClipPath","itemLayout","adjustSingleSide","shiftDown","shiftUp","changeX","isDownList","lastDeltaX","deltaY","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","textY","labelLineLen","labelLineLen2","labelRotate","RADIAN","unitRadian","roseType","extent","restAngle","valueSumLargerThanMinAngle","currentAngle","targetList","_selectTargetMap","targetMap","paletteScope","dataAll","idxMap","filteredIdx","singleDataColor","_v","_f","principal","interest","chart-option","slot","executed","pending_execute","cant_execute","expired","$event","inflow_desc","inflow","outflow_desc","outflow","net_cash_flow","execute_method","execute_status","due_at"],"mappings":"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AA,KAEAy2F,EAAAl5F,KAAAsD,MAIAhI,EAAAC,QAAAoI,GzHsz1BS,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CAEH,SAASrI,EAAQC,EAAS6G,GAE/B,YAkBA,SAASwtC,GAAuBlxC,GAAO,MAAOA,IAAOA,EAAImxC,WAAanxC,GAAQoxC,QAASpxC,GAhBvFqD,OAAOumD,eAAe/sD,EAAS,cAC7BsC,OAAO,G0H732BV,IAAAs8F,GAAA/3F,EAAA,I1Hk42BKg4F,EAAWxqD,EAAuBuqD,G0Hj42BvCzpD,EAAAtuC,EAAA,I1Hq42BKuuC,EAAQf,EAAuBc,G0Hp42BpC2pD,EAAAj4F,EAAA,G1Hw42BKk4F,EAAY1qD,EAAuByqD,E0Hv42BxCj4F,GAAA,KACAA,EAAA,KACAA,EAAA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","file":"static/js/1.5fdc2f1fcb39a44ae812.js","sourcesContent":["webpackJsonp([1,7],[\n/* 0 */,\n/* 1 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/core/util\n\t */\n\t\n\t\n\t    // 用于处理merge时无法遍历Date等对象的问题\n\t    var BUILTIN_OBJECT = {\n\t        '[object Function]': 1,\n\t        '[object RegExp]': 1,\n\t        '[object Date]': 1,\n\t        '[object Error]': 1,\n\t        '[object CanvasGradient]': 1,\n\t        '[object CanvasPattern]': 1,\n\t        // For node-canvas\n\t        '[object Image]': 1,\n\t        '[object Canvas]': 1\n\t    };\n\t\n\t    var TYPED_ARRAY = {\n\t        '[object Int8Array]': 1,\n\t        '[object Uint8Array]': 1,\n\t        '[object Uint8ClampedArray]': 1,\n\t        '[object Int16Array]': 1,\n\t        '[object Uint16Array]': 1,\n\t        '[object Int32Array]': 1,\n\t        '[object Uint32Array]': 1,\n\t        '[object Float32Array]': 1,\n\t        '[object Float64Array]': 1\n\t    };\n\t\n\t    var objToString = Object.prototype.toString;\n\t\n\t    var arrayProto = Array.prototype;\n\t    var nativeForEach = arrayProto.forEach;\n\t    var nativeFilter = arrayProto.filter;\n\t    var nativeSlice = arrayProto.slice;\n\t    var nativeMap = arrayProto.map;\n\t    var nativeReduce = arrayProto.reduce;\n\t\n\t    /**\n\t     * Those data types can be cloned:\n\t     *     Plain object, Array, TypedArray, number, string, null, undefined.\n\t     * Those data types will be assgined using the orginal data:\n\t     *     BUILTIN_OBJECT\n\t     * Instance of user defined class will be cloned to a plain object, without\n\t     * properties in prototype.\n\t     * Other data types is not supported (not sure what will happen).\n\t     *\n\t     * Caution: do not support clone Date, for performance consideration.\n\t     * (There might be a large number of date in `series.data`).\n\t     * So date should not be modified in and out of echarts.\n\t     *\n\t     * @param {*} source\n\t     * @return {*} new\n\t     */\n\t    function clone(source) {\n\t        if (source == null || typeof source != 'object') {\n\t            return source;\n\t        }\n\t\n\t        var result = source;\n\t        var typeStr = objToString.call(source);\n\t\n\t        if (typeStr === '[object Array]') {\n\t            result = [];\n\t            for (var i = 0, len = source.length; i < len; i++) {\n\t                result[i] = clone(source[i]);\n\t            }\n\t        }\n\t        else if (TYPED_ARRAY[typeStr]) {\n\t            result = source.constructor.from(source);\n\t        }\n\t        else if (!BUILTIN_OBJECT[typeStr] && !isDom(source)) {\n\t            result = {};\n\t            for (var key in source) {\n\t                if (source.hasOwnProperty(key)) {\n\t                    result[key] = clone(source[key]);\n\t                }\n\t            }\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overwrite=false]\n\t     */\n\t    function merge(target, source, overwrite) {\n\t        // We should escapse that source is string\n\t        // and enter for ... in ...\n\t        if (!isObject(source) || !isObject(target)) {\n\t            return overwrite ? clone(source) : target;\n\t        }\n\t\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                var targetProp = target[key];\n\t                var sourceProp = source[key];\n\t\n\t                if (isObject(sourceProp)\n\t                    && isObject(targetProp)\n\t                    && !isArray(sourceProp)\n\t                    && !isArray(targetProp)\n\t                    && !isDom(sourceProp)\n\t                    && !isDom(targetProp)\n\t                    && !isBuildInObject(sourceProp)\n\t                    && !isBuildInObject(targetProp)\n\t                ) {\n\t                    // 如果需要递归覆盖，就递归调用merge\n\t                    merge(targetProp, sourceProp, overwrite);\n\t                }\n\t                else if (overwrite || !(key in target)) {\n\t                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n\t                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n\t                    target[key] = clone(source[key], true);\n\t                }\n\t            }\n\t        }\n\t\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t     * @param {boolean} [overwrite=false]\n\t     * @return {*} target\n\t     */\n\t    function mergeAll(targetAndSources, overwrite) {\n\t        var result = targetAndSources[0];\n\t        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t            result = merge(result, targetAndSources[i], overwrite);\n\t        }\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function extend(target, source) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolen} [overlay=false]\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function defaults(target, source, overlay) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)\n\t                && (overlay ? source[key] != null : target[key] == null)\n\t            ) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    function createCanvas() {\n\t        return document.createElement('canvas');\n\t    }\n\t    // FIXME\n\t    var _ctx;\n\t    function getContext() {\n\t        if (!_ctx) {\n\t            // Use util.createCanvas instead of createCanvas\n\t            // because createCanvas may be overwritten in different environment\n\t            _ctx = util.createCanvas().getContext('2d');\n\t        }\n\t        return _ctx;\n\t    }\n\t\n\t    /**\n\t     * 查询数组中元素的index\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function indexOf(array, value) {\n\t        if (array) {\n\t            if (array.indexOf) {\n\t                return array.indexOf(value);\n\t            }\n\t            for (var i = 0, len = array.length; i < len; i++) {\n\t                if (array[i] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    /**\n\t     * 构造类继承关系\n\t     *\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} clazz 源类\n\t     * @param {Function} baseClazz 基类\n\t     */\n\t    function inherits(clazz, baseClazz) {\n\t        var clazzPrototype = clazz.prototype;\n\t        function F() {}\n\t        F.prototype = baseClazz.prototype;\n\t        clazz.prototype = new F();\n\t\n\t        for (var prop in clazzPrototype) {\n\t            clazz.prototype[prop] = clazzPrototype[prop];\n\t        }\n\t        clazz.prototype.constructor = clazz;\n\t        clazz.superClass = baseClazz;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Function} target\n\t     * @param {Object|Function} sorce\n\t     * @param {boolean} overlay\n\t     */\n\t    function mixin(target, source, overlay) {\n\t        target = 'prototype' in target ? target.prototype : target;\n\t        source = 'prototype' in source ? source.prototype : source;\n\t\n\t        defaults(target, source, overlay);\n\t    }\n\t\n\t    /**\n\t     * @param {Array|TypedArray} data\n\t     */\n\t    function isArrayLike(data) {\n\t        if (! data) {\n\t            return;\n\t        }\n\t        if (typeof data == 'string') {\n\t            return false;\n\t        }\n\t        return typeof data.length == 'number';\n\t    }\n\t\n\t    /**\n\t     * 数组或对象遍历\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     */\n\t    function each(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.forEach && obj.forEach === nativeForEach) {\n\t            obj.forEach(cb, context);\n\t        }\n\t        else if (obj.length === +obj.length) {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                cb.call(context, obj[i], i, obj);\n\t            }\n\t        }\n\t        else {\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    cb.call(context, obj[key], key, obj);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组映射\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {Object} [memo]\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function reduce(obj, cb, memo, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.reduce && obj.reduce === nativeReduce) {\n\t            return obj.reduce(cb, memo, context);\n\t        }\n\t        else {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                memo = cb.call(context, memo, obj[i], i, obj);\n\t            }\n\t            return memo;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组过滤\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function filter(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.filter && obj.filter === nativeFilter) {\n\t            return obj.filter(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                if (cb.call(context, obj[i], i, obj)) {\n\t                    result.push(obj[i]);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组项查找\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function find(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        for (var i = 0, len = obj.length; i < len; i++) {\n\t            if (cb.call(context, obj[i], i, obj)) {\n\t                return obj[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @param {*} context\n\t     * @return {Function}\n\t     */\n\t    function bind(func, context) {\n\t        var args = nativeSlice.call(arguments, 2);\n\t        return function () {\n\t            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @return {Function}\n\t     */\n\t    function curry(func) {\n\t        var args = nativeSlice.call(arguments, 1);\n\t        return function () {\n\t            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isString(value) {\n\t        return objToString.call(value) === '[object String]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isObject(value) {\n\t        // Avoid a V8 JIT bug in Chrome 19-20.\n\t        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t        var type = typeof value;\n\t        return type === 'function' || (!!value && type == 'object');\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isBuildInObject(value) {\n\t        return !!BUILTIN_OBJECT[objToString.call(value)];\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isDom(value) {\n\t        return typeof value === 'object'\n\t            && typeof value.nodeType === 'number'\n\t            && typeof value.ownerDocument === 'object';\n\t    }\n\t\n\t    /**\n\t     * If value1 is not null, then return value1, otherwise judget rest of values.\n\t     * @memberOf module:zrender/core/util\n\t     * @return {*} Final value\n\t     */\n\t    function retrieve(values) {\n\t        for (var i = 0, len = arguments.length; i < len; i++) {\n\t            if (arguments[i] != null) {\n\t                return arguments[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} arr\n\t     * @param {number} startIndex\n\t     * @param {number} endIndex\n\t     * @return {Array}\n\t     */\n\t    function slice() {\n\t        return Function.call.apply(nativeSlice, arguments);\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {boolean} condition\n\t     * @param {string} message\n\t     */\n\t    function assert(condition, message) {\n\t        if (!condition) {\n\t            throw new Error(message);\n\t        }\n\t    }\n\t\n\t    var util = {\n\t        inherits: inherits,\n\t        mixin: mixin,\n\t        clone: clone,\n\t        merge: merge,\n\t        mergeAll: mergeAll,\n\t        extend: extend,\n\t        defaults: defaults,\n\t        getContext: getContext,\n\t        createCanvas: createCanvas,\n\t        indexOf: indexOf,\n\t        slice: slice,\n\t        find: find,\n\t        isArrayLike: isArrayLike,\n\t        each: each,\n\t        map: map,\n\t        reduce: reduce,\n\t        filter: filter,\n\t        bind: bind,\n\t        curry: curry,\n\t        isArray: isArray,\n\t        isString: isString,\n\t        isObject: isObject,\n\t        isFunction: isFunction,\n\t        isBuildInObject: isBuildInObject,\n\t        isDom: isDom,\n\t        retrieve: retrieve,\n\t        assert: assert,\n\t        noop: function () {}\n\t    };\n\t    module.exports = util;\n\t\n\n\n/***/ },\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {// Enable DEV mode when using source code without build. which has no __DEV__ variable\n\t// In build process 'typeof __DEV__' will be replace with 'boolean'\n\t// So this code will be removed or disabled anyway after built.\n\tif (typeof __DEV__ === 'undefined') {\n\t    // In browser\n\t    if (typeof window !== 'undefined') {\n\t        window.__DEV__ = true;\n\t    }\n\t    // In node\n\t    else if (typeof global !== 'undefined') {\n\t        global.__DEV__ = true;\n\t    }\n\t}\n\t\n\t/*!\n\t * ECharts, a javascript interactive chart library.\n\t *\n\t * Copyright (c) 2015, Baidu Inc.\n\t * All rights reserved.\n\t *\n\t * LICENSE\n\t * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n\t */\n\t\n\t/**\n\t * @module echarts\n\t */\n\t\n\t\n\t    var env = __webpack_require__(14);\n\t\n\t    var GlobalModel = __webpack_require__(123);\n\t    var ExtensionAPI = __webpack_require__(108);\n\t    var CoordinateSystemManager = __webpack_require__(70);\n\t    var OptionManager = __webpack_require__(124);\n\t\n\t    var ComponentModel = __webpack_require__(18);\n\t    var SeriesModel = __webpack_require__(88);\n\t\n\t    var ComponentView = __webpack_require__(137);\n\t    var ChartView = __webpack_require__(90);\n\t    var graphic = __webpack_require__(10);\n\t    var modelUtil = __webpack_require__(11);\n\t    var throttle = __webpack_require__(136);\n\t\n\t    var zrender = __webpack_require__(195);\n\t    var zrUtil = __webpack_require__(1);\n\t    var colorTool = __webpack_require__(29);\n\t    var Eventful = __webpack_require__(28);\n\t    var timsort = __webpack_require__(53);\n\t\n\t    var each = zrUtil.each;\n\t\n\t    var PRIORITY_PROCESSOR_FILTER = 1000;\n\t    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\t\n\t\n\t    var PRIORITY_VISUAL_LAYOUT = 1000;\n\t    var PRIORITY_VISUAL_GLOBAL = 2000;\n\t    var PRIORITY_VISUAL_CHART = 3000;\n\t    var PRIORITY_VISUAL_COMPONENT = 4000;\n\t    var PRIORITY_VISUAL_BRUSH = 5000;\n\t\n\t    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n\t    // where they must not be invoked nestedly, except the only case: invoke\n\t    // dispatchAction with updateMethod \"none\" in main process.\n\t    // This flag is used to carry out this rule.\n\t    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n\t    var IN_MAIN_PROCESS = '__flagInMainProcess';\n\t    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n\t    var OPTION_UPDATED = '__optionUpdated';\n\t\n\t    function createRegisterEventWithLowercaseName(method) {\n\t        return function (eventName, handler, context) {\n\t            // Event name is all lowercase\n\t            eventName = eventName && eventName.toLowerCase();\n\t            Eventful.prototype[method].call(this, eventName, handler, context);\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @module echarts~MessageCenter\n\t     */\n\t    function MessageCenter() {\n\t        Eventful.call(this);\n\t    }\n\t    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n\t    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n\t    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n\t    zrUtil.mixin(MessageCenter, Eventful);\n\t\n\t    /**\n\t     * @module echarts~ECharts\n\t     */\n\t    function ECharts (dom, theme, opts) {\n\t        opts = opts || {};\n\t\n\t        // Get theme by name\n\t        if (typeof theme === 'string') {\n\t            theme = themeStorage[theme];\n\t        }\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id;\n\t        /**\n\t         * Group id\n\t         * @type {string}\n\t         */\n\t        this.group;\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         * @private\n\t         */\n\t        this._dom = dom;\n\t        /**\n\t         * @type {module:zrender/ZRender}\n\t         * @private\n\t         */\n\t        var zr = this._zr = zrender.init(dom, {\n\t            renderer: opts.renderer || 'canvas',\n\t            devicePixelRatio: opts.devicePixelRatio,\n\t            width: opts.width,\n\t            height: opts.height\n\t        });\n\t\n\t        /**\n\t         * Expect 60 pfs.\n\t         * @type {Function}\n\t         * @private\n\t         */\n\t        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._theme = zrUtil.clone(theme);\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsViews = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsMap = {};\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsViews = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t\n\t        /**\n\t         * @type {module:echarts/ExtensionAPI}\n\t         * @private\n\t         */\n\t        this._api = new ExtensionAPI(this);\n\t\n\t        /**\n\t         * @type {module:echarts/CoordinateSystem}\n\t         * @private\n\t         */\n\t        this._coordSysMgr = new CoordinateSystemManager();\n\t\n\t        Eventful.call(this);\n\t\n\t        /**\n\t         * @type {module:echarts~MessageCenter}\n\t         * @private\n\t         */\n\t        this._messageCenter = new MessageCenter();\n\t\n\t        // Init mouse events\n\t        this._initEvents();\n\t\n\t        // In case some people write `window.onresize = chart.resize`\n\t        this.resize = zrUtil.bind(this.resize, this);\n\t\n\t        // Can't dispatch action during rendering procedure\n\t        this._pendingActions = [];\n\t        // Sort on demand\n\t        function prioritySortFunc(a, b) {\n\t            return a.prio - b.prio;\n\t        }\n\t        timsort(visualFuncs, prioritySortFunc);\n\t        timsort(dataProcessorFuncs, prioritySortFunc);\n\t\n\t        zr.animation.on('frame', this._onframe, this);\n\t    }\n\t\n\t    var echartsProto = ECharts.prototype;\n\t\n\t    echartsProto._onframe = function () {\n\t        // Lazy update\n\t        if (this[OPTION_UPDATED]) {\n\t\n\t            this[IN_MAIN_PROCESS] = true;\n\t\n\t            updateMethods.prepareAndUpdate.call(this);\n\t\n\t            this[IN_MAIN_PROCESS] = false;\n\t\n\t            this[OPTION_UPDATED] = false;\n\t        }\n\t    };\n\t    /**\n\t     * @return {HTMLDomElement}\n\t     */\n\t    echartsProto.getDom = function () {\n\t        return this._dom;\n\t    };\n\t\n\t    /**\n\t     * @return {module:zrender~ZRender}\n\t     */\n\t    echartsProto.getZr = function () {\n\t        return this._zr;\n\t    };\n\t\n\t    /**\n\t     * @param {Object} option\n\t     * @param {boolean} notMerge\n\t     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.\n\t     */\n\t    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n\t        if (__DEV__) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = true;\n\t\n\t        if (!this._model || notMerge) {\n\t            var optionManager = new OptionManager(this._api);\n\t            var theme = this._theme;\n\t            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n\t            ecModel.init(null, null, theme, optionManager);\n\t        }\n\t\n\t        // FIXME\n\t        // ugly\n\t        this.__lastOnlyGraphic = !!(option && option.graphic);\n\t        zrUtil.each(option, function (o, mainType) {\n\t            mainType !== 'graphic' && (this.__lastOnlyGraphic = false);\n\t        }, this);\n\t\n\t        this._model.setOption(option, optionPreprocessorFuncs);\n\t\n\t        if (lazyUpdate) {\n\t            this[OPTION_UPDATED] = true;\n\t        }\n\t        else {\n\t            updateMethods.prepareAndUpdate.call(this);\n\t            // Ensure zr refresh sychronously, and then pixel in canvas can be\n\t            // fetched after `setOption`.\n\t            this._zr.flush();\n\t            this[OPTION_UPDATED] = false;\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = false;\n\t\n\t        flushPendingActions.call(this, false);\n\t    };\n\t\n\t    /**\n\t     * @DEPRECATED\n\t     */\n\t    echartsProto.setTheme = function () {\n\t        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n\t    };\n\t\n\t    /**\n\t     * @return {module:echarts/model/Global}\n\t     */\n\t    echartsProto.getModel = function () {\n\t        return this._model;\n\t    };\n\t\n\t    /**\n\t     * @return {Object}\n\t     */\n\t    echartsProto.getOption = function () {\n\t        return this._model && this._model.getOption();\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getWidth = function () {\n\t        return this._zr.getWidth();\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getHeight = function () {\n\t        return this._zr.getHeight();\n\t    };\n\t\n\t    /**\n\t     * Get canvas which has all thing rendered\n\t     * @param {Object} opts\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getRenderedCanvas = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        opts = opts || {};\n\t        opts.pixelRatio = opts.pixelRatio || 1;\n\t        opts.backgroundColor = opts.backgroundColor\n\t            || this._model.get('backgroundColor');\n\t        var zr = this._zr;\n\t        var list = zr.storage.getDisplayList();\n\t        // Stop animations\n\t        zrUtil.each(list, function (el) {\n\t            el.stopAnimation(true);\n\t        });\n\t        return zr.painter.getRenderedCanvas(opts);\n\t    };\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     * @param {string} [opts.excludeComponents]\n\t     */\n\t    echartsProto.getDataURL = function (opts) {\n\t        opts = opts || {};\n\t        var excludeComponents = opts.excludeComponents;\n\t        var ecModel = this._model;\n\t        var excludesComponentViews = [];\n\t        var self = this;\n\t\n\t        each(excludeComponents, function (componentType) {\n\t            ecModel.eachComponent({\n\t                mainType: componentType\n\t            }, function (component) {\n\t                var view = self._componentsMap[component.__viewId];\n\t                if (!view.group.ignore) {\n\t                    excludesComponentViews.push(view);\n\t                    view.group.ignore = true;\n\t                }\n\t            });\n\t        });\n\t\n\t        var url = this.getRenderedCanvas(opts).toDataURL(\n\t            'image/' + (opts && opts.type || 'png')\n\t        );\n\t\n\t        each(excludesComponentViews, function (view) {\n\t            view.group.ignore = false;\n\t        });\n\t        return url;\n\t    };\n\t\n\t\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getConnectedDataURL = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        var groupId = this.group;\n\t        var mathMin = Math.min;\n\t        var mathMax = Math.max;\n\t        var MAX_NUMBER = Infinity;\n\t        if (connectedGroups[groupId]) {\n\t            var left = MAX_NUMBER;\n\t            var top = MAX_NUMBER;\n\t            var right = -MAX_NUMBER;\n\t            var bottom = -MAX_NUMBER;\n\t            var canvasList = [];\n\t            var dpr = (opts && opts.pixelRatio) || 1;\n\t\n\t            zrUtil.each(instances, function (chart, id) {\n\t                if (chart.group === groupId) {\n\t                    var canvas = chart.getRenderedCanvas(\n\t                        zrUtil.clone(opts)\n\t                    );\n\t                    var boundingRect = chart.getDom().getBoundingClientRect();\n\t                    left = mathMin(boundingRect.left, left);\n\t                    top = mathMin(boundingRect.top, top);\n\t                    right = mathMax(boundingRect.right, right);\n\t                    bottom = mathMax(boundingRect.bottom, bottom);\n\t                    canvasList.push({\n\t                        dom: canvas,\n\t                        left: boundingRect.left,\n\t                        top: boundingRect.top\n\t                    });\n\t                }\n\t            });\n\t\n\t            left *= dpr;\n\t            top *= dpr;\n\t            right *= dpr;\n\t            bottom *= dpr;\n\t            var width = right - left;\n\t            var height = bottom - top;\n\t            var targetCanvas = zrUtil.createCanvas();\n\t            targetCanvas.width = width;\n\t            targetCanvas.height = height;\n\t            var zr = zrender.init(targetCanvas);\n\t\n\t            each(canvasList, function (item) {\n\t                var img = new graphic.Image({\n\t                    style: {\n\t                        x: item.left * dpr - left,\n\t                        y: item.top * dpr - top,\n\t                        image: item.dom\n\t                    }\n\t                });\n\t                zr.add(img);\n\t            });\n\t            zr.refreshImmediately();\n\t\n\t            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n\t        }\n\t        else {\n\t            return this.getDataURL(opts);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Convert from logical coordinate system to pixel coordinate system.\n\t     * See CoordinateSystem#convertToPixel.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            geoIndex / geoId, geoName,\n\t     *            bmapIndex / bmapId / bmapName,\n\t     *            xAxisIndex / xAxisId / xAxisName,\n\t     *            yAxisIndex / yAxisId / yAxisName,\n\t     *            gridIndex / gridId / gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     * @param {Array|number} value\n\t     * @return {Array|number} result\n\t     */\n\t    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\t\n\t    /**\n\t     * Convert from pixel coordinate system to logical coordinate system.\n\t     * See CoordinateSystem#convertFromPixel.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            geoIndex / geoId / geoName,\n\t     *            bmapIndex / bmapId / bmapName,\n\t     *            xAxisIndex / xAxisId / xAxisName,\n\t     *            yAxisIndex / yAxisId / yAxisName\n\t     *            gridIndex / gridId / gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     * @param {Array|number} value\n\t     * @return {Array|number} result\n\t     */\n\t    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\t\n\t    function doConvertPixel(methodName, finder, value) {\n\t        var ecModel = this._model;\n\t        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n\t        var result;\n\t\n\t        finder = modelUtil.parseFinder(ecModel, finder);\n\t\n\t        for (var i = 0; i < coordSysList.length; i++) {\n\t            var coordSys = coordSysList[i];\n\t            if (coordSys[methodName]\n\t                && (result = coordSys[methodName](ecModel, finder, value)) != null\n\t            ) {\n\t                return result;\n\t            }\n\t        }\n\t\n\t        if (__DEV__) {\n\t            console.warn(\n\t                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n\t            );\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Is the specified coordinate systems or components contain the given pixel point.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            geoIndex / geoId / geoName,\n\t     *            bmapIndex / bmapId / bmapName,\n\t     *            xAxisIndex / xAxisId / xAxisName,\n\t     *            yAxisIndex / yAxisId / yAxisName\n\t     *            gridIndex / gridId / gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     * @param {Array|number} value\n\t     * @return {boolean} result\n\t     */\n\t    echartsProto.containPixel = function (finder, value) {\n\t        var ecModel = this._model;\n\t        var result;\n\t\n\t        finder = modelUtil.parseFinder(ecModel, finder);\n\t\n\t        zrUtil.each(finder, function (models, key) {\n\t            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n\t                var coordSys = model.coordinateSystem;\n\t                if (coordSys && coordSys.containPoint) {\n\t                    result |= !!coordSys.containPoint(value);\n\t                }\n\t                else if (key === 'seriesModels') {\n\t                    var view = this._chartsMap[model.__viewId];\n\t                    if (view && view.containPoint) {\n\t                        result |= view.containPoint(value, model);\n\t                    }\n\t                    else {\n\t                        if (__DEV__) {\n\t                            console.warn(key + ': ' + (view\n\t                                ? 'The found component do not support containPoint.'\n\t                                : 'No view mapping to the found component.'\n\t                            ));\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    if (__DEV__) {\n\t                        console.warn(key + ': containPoint is not supported');\n\t                    }\n\t                }\n\t            }, this);\n\t        }, this);\n\t\n\t        return !!result;\n\t    };\n\t\n\t    /**\n\t     * Get visual from series or data.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'series', means {seriesIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            dataIndex / dataIndexInside\n\t     *        }\n\t     *        If dataIndex is not specified, series visual will be fetched,\n\t     *        but not data item visual.\n\t     *        If all of seriesIndex, seriesId, seriesName are not specified,\n\t     *        visual will be fetched from first series.\n\t     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n\t     */\n\t    echartsProto.getVisual = function (finder, visualType) {\n\t        var ecModel = this._model;\n\t\n\t        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\t\n\t        var seriesModel = finder.seriesModel;\n\t\n\t        if (__DEV__) {\n\t            if (!seriesModel) {\n\t                console.warn('There is no specified seires model');\n\t            }\n\t        }\n\t\n\t        var data = seriesModel.getData();\n\t\n\t        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n\t            ? finder.dataIndexInside\n\t            : finder.hasOwnProperty('dataIndex')\n\t            ? data.indexOfRawIndex(finder.dataIndex)\n\t            : null;\n\t\n\t        return dataIndexInside != null\n\t            ? data.getItemVisual(dataIndexInside, visualType)\n\t            : data.getVisual(visualType);\n\t    };\n\t\n\t\n\t    var updateMethods = {\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        update: function (payload) {\n\t            // console.time && console.time('update');\n\t\n\t            var ecModel = this._model;\n\t            var api = this._api;\n\t            var coordSysMgr = this._coordSysMgr;\n\t            var zr = this._zr;\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            // Fixme First time update ?\n\t            ecModel.restoreData();\n\t\n\t            // TODO\n\t            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n\t            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\t\n\t            // Create new coordinate system each update\n\t            // In LineView may save the old coordinate system and use it to get the orignal point\n\t            coordSysMgr.create(this._model, this._api);\n\t\n\t            processData.call(this, ecModel, api);\n\t\n\t            stackSeriesData.call(this, ecModel);\n\t\n\t            coordSysMgr.update(ecModel, api);\n\t\n\t            doVisualEncoding.call(this, ecModel, payload);\n\t\n\t            doRender.call(this, ecModel, payload);\n\t\n\t            // Set background\n\t            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\t\n\t            var painter = zr.painter;\n\t            // TODO all use clearColor ?\n\t            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n\t                zr.configLayer(0, {\n\t                    clearColor: backgroundColor\n\t                });\n\t            }\n\t            else {\n\t                // In IE8\n\t                if (!env.canvasSupported) {\n\t                    var colorArr = colorTool.parse(backgroundColor);\n\t                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n\t                    if (colorArr[3] === 0) {\n\t                        backgroundColor = 'transparent';\n\t                    }\n\t                }\n\t                if (backgroundColor.colorStops || backgroundColor.image) {\n\t                    // Gradient background\n\t                    // FIXME Fixed layer？\n\t                    zr.configLayer(0, {\n\t                        clearColor: backgroundColor\n\t                    });\n\t                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\t\n\t                    this._dom.style.background = 'transparent';\n\t                }\n\t                else {\n\t                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n\t                        zr.configLayer(0, {\n\t                            clearColor: null\n\t                        });\n\t                    }\n\t                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\t\n\t                    this._dom.style.background = backgroundColor;\n\t                }\n\t            }\n\t\n\t            // console.time && console.timeEnd('update');\n\t        },\n\t\n\t        // PENDING\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        updateView: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                seriesModel.getData().clearAllVisual();\n\t            });\n\t\n\t            doVisualEncoding.call(this, ecModel, payload);\n\t\n\t            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        updateVisual: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                seriesModel.getData().clearAllVisual();\n\t            });\n\t\n\t            doVisualEncoding.call(this, ecModel, payload);\n\t\n\t            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        updateLayout: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            doLayout.call(this, ecModel, payload);\n\t\n\t            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        highlight: function (payload) {\n\t            toggleHighlight.call(this, 'highlight', payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        downplay: function (payload) {\n\t            toggleHighlight.call(this, 'downplay', payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        prepareAndUpdate: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            prepareView.call(this, 'component', ecModel);\n\t\n\t            prepareView.call(this, 'chart', ecModel);\n\t\n\t            // FIXME\n\t            // ugly\n\t            if (this.__lastOnlyGraphic) {\n\t                each(this._componentsViews, function (componentView) {\n\t                    var componentModel = componentView.__model;\n\t                    if (componentModel && componentModel.mainType === 'graphic') {\n\t                        componentView.render(componentModel, ecModel, this._api, payload);\n\t                        updateZ(componentModel, componentView);\n\t                    }\n\t                }, this);\n\t                this.__lastOnlyGraphic = false;\n\t            }\n\t            else {\n\t                updateMethods.update.call(this, payload);\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {Object} payload\n\t     * @private\n\t     */\n\t    function toggleHighlight(method, payload) {\n\t        var ecModel = this._model;\n\t\n\t        // dispatchAction before setOption\n\t        if (!ecModel) {\n\t            return;\n\t        }\n\t\n\t        ecModel.eachComponent(\n\t            {mainType: 'series', query: payload},\n\t            function (seriesModel, index) {\n\t                var chartView = this._chartsMap[seriesModel.__viewId];\n\t                if (chartView && chartView.__alive) {\n\t                    chartView[method](\n\t                        seriesModel, ecModel, this._api, payload\n\t                    );\n\t                }\n\t            },\n\t            this\n\t        );\n\t    }\n\t\n\t    /**\n\t     * Resize the chart\n\t     * @param {Object} opts\n\t     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     */\n\t    echartsProto.resize = function (opts) {\n\t        if (__DEV__) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = true;\n\t\n\t        this._zr.resize(opts);\n\t\n\t        var optionChanged = this._model && this._model.resetOption('media');\n\t        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);\n\t\n\t        // Resize loading effect\n\t        this._loadingFX && this._loadingFX.resize();\n\t\n\t        this[IN_MAIN_PROCESS] = false;\n\t\n\t        flushPendingActions.call(this);\n\t    };\n\t\n\t    /**\n\t     * Show loading effect\n\t     * @param  {string} [name='default']\n\t     * @param  {Object} [cfg]\n\t     */\n\t    echartsProto.showLoading = function (name, cfg) {\n\t        if (zrUtil.isObject(name)) {\n\t            cfg = name;\n\t            name = '';\n\t        }\n\t        name = name || 'default';\n\t\n\t        this.hideLoading();\n\t        if (!loadingEffects[name]) {\n\t            if (__DEV__) {\n\t                console.warn('Loading effects ' + name + ' not exists.');\n\t            }\n\t            return;\n\t        }\n\t        var el = loadingEffects[name](this._api, cfg);\n\t        var zr = this._zr;\n\t        this._loadingFX = el;\n\t\n\t        zr.add(el);\n\t    };\n\t\n\t    /**\n\t     * Hide loading effect\n\t     */\n\t    echartsProto.hideLoading = function () {\n\t        this._loadingFX && this._zr.remove(this._loadingFX);\n\t        this._loadingFX = null;\n\t    };\n\t\n\t    /**\n\t     * @param {Object} eventObj\n\t     * @return {Object}\n\t     */\n\t    echartsProto.makeActionFromEvent = function (eventObj) {\n\t        var payload = zrUtil.extend({}, eventObj);\n\t        payload.type = eventActionMap[eventObj.type];\n\t        return payload;\n\t    };\n\t\n\t    /**\n\t     * @pubilc\n\t     * @param {Object} payload\n\t     * @param {string} [payload.type] Action type\n\t     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n\t     * @param {boolean} [opt.silent=false] Whether trigger events.\n\t     * @param {boolean} [opt.flush=undefined]\n\t     *                  true: Flush immediately, and then pixel in canvas can be fetched\n\t     *                      immediately. Caution: it might affect performance.\n\t     *                  false: Not not flush.\n\t     *                  undefined: Auto decide whether perform flush.\n\t     */\n\t    echartsProto.dispatchAction = function (payload, opt) {\n\t        if (!zrUtil.isObject(opt)) {\n\t            opt = {silent: !!opt};\n\t        }\n\t\n\t        if (!actions[payload.type]) {\n\t            return;\n\t        }\n\t\n\t        // if (__DEV__) {\n\t        //     zrUtil.assert(\n\t        //         !this[IN_MAIN_PROCESS],\n\t        //         '`dispatchAction` should not be called during main process.'\n\t        //         + 'unless updateMathod is \"none\".'\n\t        //     );\n\t        // }\n\t\n\t        // May dispatchAction in rendering procedure\n\t        if (this[IN_MAIN_PROCESS]) {\n\t            this._pendingActions.push(payload);\n\t            return;\n\t        }\n\t\n\t        doDispatchAction.call(this, payload, opt.silent);\n\t\n\t        if (opt.flush) {\n\t            this._zr.flush(true);\n\t        }\n\t        else if (opt.flush !== false && env.browser.weChat) {\n\t            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n\t            // hang when sliding page (on touch event), which cause that zr does not\n\t            // refresh util user interaction finished, which is not expected.\n\t            // But `dispatchAction` may be called too frequently when pan on touch\n\t            // screen, which impacts performance if do not throttle them.\n\t            this._throttledZrFlush();\n\t        }\n\t\n\t        flushPendingActions.call(this, opt.silent);\n\t    };\n\t\n\t    function doDispatchAction(payload, silent) {\n\t        var actionWrap = actions[payload.type];\n\t        var actionInfo = actionWrap.actionInfo;\n\t        var updateMethod = actionInfo.update || 'update';\n\t\n\t        this[IN_MAIN_PROCESS] = true;\n\t\n\t        var payloads = [payload];\n\t        var batched = false;\n\t        // Batch action\n\t        if (payload.batch) {\n\t            batched = true;\n\t            payloads = zrUtil.map(payload.batch, function (item) {\n\t                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n\t                item.batch = null;\n\t                return item;\n\t            });\n\t        }\n\t\n\t        var eventObjBatch = [];\n\t        var eventObj;\n\t        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';\n\t        for (var i = 0; i < payloads.length; i++) {\n\t            var batchItem = payloads[i];\n\t            // Action can specify the event by return it.\n\t            eventObj = actionWrap.action(batchItem, this._model);\n\t            // Emit event outside\n\t            eventObj = eventObj || zrUtil.extend({}, batchItem);\n\t            // Convert type to eventType\n\t            eventObj.type = actionInfo.event || eventObj.type;\n\t            eventObjBatch.push(eventObj);\n\t\n\t            // Highlight and downplay are special.\n\t            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);\n\t        }\n\t\n\t        if (updateMethod !== 'none' && !isHighlightOrDownplay) {\n\t            // Still dirty\n\t            if (this[OPTION_UPDATED]) {\n\t                // FIXME Pass payload ?\n\t                updateMethods.prepareAndUpdate.call(this, payload);\n\t                this[OPTION_UPDATED] = false;\n\t            }\n\t            else {\n\t                updateMethods[updateMethod].call(this, payload);\n\t            }\n\t        }\n\t\n\t        // Follow the rule of action batch\n\t        if (batched) {\n\t            eventObj = {\n\t                type: actionInfo.event || payload.type,\n\t                batch: eventObjBatch\n\t            };\n\t        }\n\t        else {\n\t            eventObj = eventObjBatch[0];\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = false;\n\t\n\t        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n\t    }\n\t\n\t    function flushPendingActions(silent) {\n\t        var pendingActions = this._pendingActions;\n\t        while (pendingActions.length) {\n\t            var payload = pendingActions.shift();\n\t            doDispatchAction.call(this, payload, silent);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Register event\n\t     * @method\n\t     */\n\t    echartsProto.on = createRegisterEventWithLowercaseName('on');\n\t    echartsProto.off = createRegisterEventWithLowercaseName('off');\n\t    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\t\n\t    /**\n\t     * @param {string} methodName\n\t     * @private\n\t     */\n\t    function invokeUpdateMethod(methodName, ecModel, payload) {\n\t        var api = this._api;\n\t\n\t        // Update all components\n\t        each(this._componentsViews, function (component) {\n\t            var componentModel = component.__model;\n\t            component[methodName](componentModel, ecModel, api, payload);\n\t\n\t            updateZ(componentModel, component);\n\t        }, this);\n\t\n\t        // Upate all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chart = this._chartsMap[seriesModel.__viewId];\n\t            chart[methodName](seriesModel, ecModel, api, payload);\n\t\n\t            updateZ(seriesModel, chart);\n\t\n\t            updateProgressiveAndBlend(seriesModel, chart);\n\t        }, this);\n\t\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t    }\n\t\n\t    /**\n\t     * Prepare view instances of charts and components\n\t     * @param  {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function prepareView(type, ecModel) {\n\t        var isComponent = type === 'component';\n\t        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n\t        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n\t        var zr = this._zr;\n\t\n\t        for (var i = 0; i < viewList.length; i++) {\n\t            viewList[i].__alive = false;\n\t        }\n\t\n\t        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n\t            if (isComponent) {\n\t                if (componentType === 'series') {\n\t                    return;\n\t                }\n\t            }\n\t            else {\n\t                model = componentType;\n\t            }\n\t\n\t            // Consider: id same and type changed.\n\t            var viewId = model.id + '_' + model.type;\n\t            var view = viewMap[viewId];\n\t            if (!view) {\n\t                var classType = ComponentModel.parseClassType(model.type);\n\t                var Clazz = isComponent\n\t                    ? ComponentView.getClass(classType.main, classType.sub)\n\t                    : ChartView.getClass(classType.sub);\n\t                if (Clazz) {\n\t                    view = new Clazz();\n\t                    view.init(ecModel, this._api);\n\t                    viewMap[viewId] = view;\n\t                    viewList.push(view);\n\t                    zr.add(view.group);\n\t                }\n\t                else {\n\t                    // Error\n\t                    return;\n\t                }\n\t            }\n\t\n\t            model.__viewId = viewId;\n\t            view.__alive = true;\n\t            view.__id = viewId;\n\t            view.__model = model;\n\t        }, this);\n\t\n\t        for (var i = 0; i < viewList.length;) {\n\t            var view = viewList[i];\n\t            if (!view.__alive) {\n\t                zr.remove(view.group);\n\t                view.dispose(ecModel, this._api);\n\t                viewList.splice(i, 1);\n\t                delete viewMap[view.__id];\n\t            }\n\t            else {\n\t                i++;\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Processor data in each series\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function processData(ecModel, api) {\n\t        each(dataProcessorFuncs, function (process) {\n\t            process.func(ecModel, api);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    function stackSeriesData(ecModel) {\n\t        var stackedDataMap = {};\n\t        ecModel.eachSeries(function (series) {\n\t            var stack = series.get('stack');\n\t            var data = series.getData();\n\t            if (stack && data.type === 'list') {\n\t                var previousStack = stackedDataMap[stack];\n\t                if (previousStack) {\n\t                    data.stackedOn = previousStack;\n\t                }\n\t                stackedDataMap[stack] = data;\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Layout before each chart render there series, special visual encoding stage\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function doLayout(ecModel, payload) {\n\t        var api = this._api;\n\t        each(visualFuncs, function (visual) {\n\t            if (visual.isLayout) {\n\t                visual.func(ecModel, api, payload);\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Encode visual infomation from data after data processing\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function doVisualEncoding(ecModel, payload) {\n\t        var api = this._api;\n\t        ecModel.clearColorPalette();\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            seriesModel.clearColorPalette();\n\t        });\n\t        each(visualFuncs, function (visual) {\n\t            visual.func(ecModel, api, payload);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Render each chart and component\n\t     * @private\n\t     */\n\t    function doRender(ecModel, payload) {\n\t        var api = this._api;\n\t        // Render all components\n\t        each(this._componentsViews, function (componentView) {\n\t            var componentModel = componentView.__model;\n\t            componentView.render(componentModel, ecModel, api, payload);\n\t\n\t            updateZ(componentModel, componentView);\n\t        }, this);\n\t\n\t        each(this._chartsViews, function (chart) {\n\t            chart.__alive = false;\n\t        }, this);\n\t\n\t        // Render all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chartView = this._chartsMap[seriesModel.__viewId];\n\t            chartView.__alive = true;\n\t            chartView.render(seriesModel, ecModel, api, payload);\n\t\n\t            chartView.group.silent = !!seriesModel.get('silent');\n\t\n\t            updateZ(seriesModel, chartView);\n\t\n\t            updateProgressiveAndBlend(seriesModel, chartView);\n\t\n\t        }, this);\n\t\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t\n\t        // Remove groups of unrendered charts\n\t        each(this._chartsViews, function (chart) {\n\t            if (!chart.__alive) {\n\t                chart.remove(ecModel, api);\n\t            }\n\t        }, this);\n\t    }\n\t\n\t    var MOUSE_EVENT_NAMES = [\n\t        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n\t        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n\t    ];\n\t    /**\n\t     * @private\n\t     */\n\t    echartsProto._initEvents = function () {\n\t        each(MOUSE_EVENT_NAMES, function (eveName) {\n\t            this._zr.on(eveName, function (e) {\n\t                var ecModel = this.getModel();\n\t                var el = e.target;\n\t                var params;\n\t\n\t                // no e.target when 'globalout'.\n\t                if (eveName === 'globalout') {\n\t                    params = {};\n\t                }\n\t                else if (el && el.dataIndex != null) {\n\t                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n\t                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n\t                }\n\t                // If element has custom eventData of components\n\t                else if (el && el.eventData) {\n\t                    params = zrUtil.extend({}, el.eventData);\n\t                }\n\t\n\t                if (params) {\n\t                    params.event = e;\n\t                    params.type = eveName;\n\t                    this.trigger(eveName, params);\n\t                }\n\t\n\t            }, this);\n\t        }, this);\n\t\n\t        each(eventActionMap, function (actionType, eventType) {\n\t            this._messageCenter.on(eventType, function (event) {\n\t                this.trigger(eventType, event);\n\t            }, this);\n\t        }, this);\n\t    };\n\t\n\t    /**\n\t     * @return {boolean}\n\t     */\n\t    echartsProto.isDisposed = function () {\n\t        return this._disposed;\n\t    };\n\t\n\t    /**\n\t     * Clear\n\t     */\n\t    echartsProto.clear = function () {\n\t        this.setOption({ series: [] }, true);\n\t    };\n\t    /**\n\t     * Dispose instance\n\t     */\n\t    echartsProto.dispose = function () {\n\t        if (this._disposed) {\n\t            if (__DEV__) {\n\t                console.warn('Instance ' + this.id + ' has been disposed');\n\t            }\n\t            return;\n\t        }\n\t        this._disposed = true;\n\t\n\t        var api = this._api;\n\t        var ecModel = this._model;\n\t\n\t        each(this._componentsViews, function (component) {\n\t            component.dispose(ecModel, api);\n\t        });\n\t        each(this._chartsViews, function (chart) {\n\t            chart.dispose(ecModel, api);\n\t        });\n\t\n\t        // Dispose after all views disposed\n\t        this._zr.dispose();\n\t\n\t        delete instances[this.id];\n\t    };\n\t\n\t    zrUtil.mixin(ECharts, Eventful);\n\t\n\t    function updateHoverLayerStatus(zr, ecModel) {\n\t        var storage = zr.storage;\n\t        var elCount = 0;\n\t        storage.traverse(function (el) {\n\t            if (!el.isGroup) {\n\t                elCount++;\n\t            }\n\t        });\n\t        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n\t            storage.traverse(function (el) {\n\t                if (!el.isGroup) {\n\t                    el.useHoverLayer = true;\n\t                }\n\t            });\n\t        }\n\t    }\n\t    /**\n\t     * Update chart progressive and blend.\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateProgressiveAndBlend(seriesModel, chartView) {\n\t        // Progressive configuration\n\t        var elCount = 0;\n\t        chartView.group.traverse(function (el) {\n\t            if (el.type !== 'group' && !el.ignore) {\n\t                elCount++;\n\t            }\n\t        });\n\t        var frameDrawNum = +seriesModel.get('progressive');\n\t        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n\t        if (needProgressive) {\n\t            chartView.group.traverse(function (el) {\n\t                // FIXME marker and other components\n\t                if (!el.isGroup) {\n\t                    el.progressive = needProgressive ?\n\t                        Math.floor(elCount++ / frameDrawNum) : -1;\n\t                    if (needProgressive) {\n\t                        el.stopAnimation(true);\n\t                    }\n\t                }\n\t            });\n\t        }\n\t\n\t        // Blend configration\n\t        var blendMode = seriesModel.get('blendMode') || null;\n\t        if (__DEV__) {\n\t            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n\t                console.warn('Only canvas support blendMode');\n\t            }\n\t        }\n\t        chartView.group.traverse(function (el) {\n\t            // FIXME marker and other components\n\t            if (!el.isGroup) {\n\t                el.setStyle('blend', blendMode);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateZ(model, view) {\n\t        var z = model.get('z');\n\t        var zlevel = model.get('zlevel');\n\t        // Set z and zlevel\n\t        view.group.traverse(function (el) {\n\t            if (el.type !== 'group') {\n\t                z != null && (el.z = z);\n\t                zlevel != null && (el.zlevel = zlevel);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var actions = [];\n\t\n\t    /**\n\t     * Map eventType to actionType\n\t     * @type {Object}\n\t     */\n\t    var eventActionMap = {};\n\t\n\t    /**\n\t     * Data processor functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var dataProcessorFuncs = [];\n\t\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var optionPreprocessorFuncs = [];\n\t\n\t    /**\n\t     * Visual encoding functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var visualFuncs = [];\n\t    /**\n\t     * Theme storage\n\t     * @type {Object.<key, Object>}\n\t     */\n\t    var themeStorage = {};\n\t    /**\n\t     * Loading effects\n\t     */\n\t    var loadingEffects = {};\n\t\n\t\n\t    var instances = {};\n\t    var connectedGroups = {};\n\t\n\t    var idBase = new Date() - 0;\n\t    var groupIdBase = new Date() - 0;\n\t    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\t    /**\n\t     * @alias module:echarts\n\t     */\n\t    var echarts = {\n\t        /**\n\t         * @type {number}\n\t         */\n\t        version: '3.3.2',\n\t        dependencies: {\n\t            zrender: '3.2.2'\n\t        }\n\t    };\n\t\n\t    function enableConnect(chart) {\n\t\n\t        var STATUS_PENDING = 0;\n\t        var STATUS_UPDATING = 1;\n\t        var STATUS_UPDATED = 2;\n\t        var STATUS_KEY = '__connectUpdateStatus';\n\t        function updateConnectedChartsStatus(charts, status) {\n\t            for (var i = 0; i < charts.length; i++) {\n\t                var otherChart = charts[i];\n\t                otherChart[STATUS_KEY] = status;\n\t            }\n\t        }\n\t        zrUtil.each(eventActionMap, function (actionType, eventType) {\n\t            chart._messageCenter.on(eventType, function (event) {\n\t                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n\t                    var action = chart.makeActionFromEvent(event);\n\t                    var otherCharts = [];\n\t\n\t                    zrUtil.each(instances, function (otherChart) {\n\t                        if (otherChart !== chart && otherChart.group === chart.group) {\n\t                            otherCharts.push(otherChart);\n\t                        }\n\t                    });\n\t\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n\t                    each(otherCharts, function (otherChart) {\n\t                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n\t                            otherChart.dispatchAction(action);\n\t                        }\n\t                    });\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n\t                }\n\t            });\n\t        });\n\t\n\t    }\n\t    /**\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} [theme]\n\t     * @param {Object} opts\n\t     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n\t     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n\t     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n\t     *                              Can be 'auto' (the same as null/undefined)\n\t     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n\t     *                               Can be 'auto' (the same as null/undefined)\n\t     */\n\t    echarts.init = function (dom, theme, opts) {\n\t        if (__DEV__) {\n\t            // Check version\n\t            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n\t                throw new Error(\n\t                    'ZRender ' + zrender.version\n\t                    + ' is too old for ECharts ' + echarts.version\n\t                    + '. Current version need ZRender '\n\t                    + echarts.dependencies.zrender + '+'\n\t                );\n\t            }\n\t            if (!dom) {\n\t                throw new Error('Initialize failed: invalid dom.');\n\t            }\n\t            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n\t                console.warn('Can\\'t get dom width or height');\n\t            }\n\t        }\n\t\n\t        var chart = new ECharts(dom, theme, opts);\n\t        chart.id = 'ec_' + idBase++;\n\t        instances[chart.id] = chart;\n\t\n\t        dom.setAttribute &&\n\t            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\t\n\t        enableConnect(chart);\n\t\n\t        return chart;\n\t    };\n\t\n\t    /**\n\t     * @return {string|Array.<module:echarts~ECharts>} groupId\n\t     */\n\t    echarts.connect = function (groupId) {\n\t        // Is array of charts\n\t        if (zrUtil.isArray(groupId)) {\n\t            var charts = groupId;\n\t            groupId = null;\n\t            // If any chart has group\n\t            zrUtil.each(charts, function (chart) {\n\t                if (chart.group != null) {\n\t                    groupId = chart.group;\n\t                }\n\t            });\n\t            groupId = groupId || ('g_' + groupIdBase++);\n\t            zrUtil.each(charts, function (chart) {\n\t                chart.group = groupId;\n\t            });\n\t        }\n\t        connectedGroups[groupId] = true;\n\t        return groupId;\n\t    };\n\t\n\t    /**\n\t     * @return {string} groupId\n\t     */\n\t    echarts.disConnect = function (groupId) {\n\t        connectedGroups[groupId] = false;\n\t    };\n\t\n\t    /**\n\t     * Dispose a chart instance\n\t     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n\t     */\n\t    echarts.dispose = function (chart) {\n\t        if (zrUtil.isDom(chart)) {\n\t            chart = echarts.getInstanceByDom(chart);\n\t        }\n\t        else if (typeof chart === 'string') {\n\t            chart = instances[chart];\n\t        }\n\t        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n\t            chart.dispose();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param  {HTMLDomElement} dom\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceByDom = function (dom) {\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n\t        return instances[key];\n\t    };\n\t    /**\n\t     * @param {string} key\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceById = function (key) {\n\t        return instances[key];\n\t    };\n\t\n\t    /**\n\t     * Register theme\n\t     */\n\t    echarts.registerTheme = function (name, theme) {\n\t        themeStorage[name] = theme;\n\t    };\n\t\n\t    /**\n\t     * Register option preprocessor\n\t     * @param {Function} preprocessorFunc\n\t     */\n\t    echarts.registerPreprocessor = function (preprocessorFunc) {\n\t        optionPreprocessorFuncs.push(preprocessorFunc);\n\t    };\n\t\n\t    /**\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} processorFunc\n\t     */\n\t    echarts.registerProcessor = function (priority, processorFunc) {\n\t        if (typeof priority === 'function') {\n\t            processorFunc = priority;\n\t            priority = PRIORITY_PROCESSOR_FILTER;\n\t        }\n\t        if (__DEV__) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown processor priority');\n\t            }\n\t        }\n\t        dataProcessorFuncs.push({\n\t            prio: priority,\n\t            func: processorFunc\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Usage:\n\t     * registerAction('someAction', 'someEvent', function () { ... });\n\t     * registerAction('someAction', function () { ... });\n\t     * registerAction(\n\t     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n\t     *     function () { ... }\n\t     * );\n\t     *\n\t     * @param {(string|Object)} actionInfo\n\t     * @param {string} actionInfo.type\n\t     * @param {string} [actionInfo.event]\n\t     * @param {string} [actionInfo.update]\n\t     * @param {string} [eventName]\n\t     * @param {Function} action\n\t     */\n\t    echarts.registerAction = function (actionInfo, eventName, action) {\n\t        if (typeof eventName === 'function') {\n\t            action = eventName;\n\t            eventName = '';\n\t        }\n\t        var actionType = zrUtil.isObject(actionInfo)\n\t            ? actionInfo.type\n\t            : ([actionInfo, actionInfo = {\n\t                event: eventName\n\t            }][0]);\n\t\n\t        // Event name is all lowercase\n\t        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n\t        eventName = actionInfo.event;\n\t\n\t        if (!actions[actionType]) {\n\t            actions[actionType] = {action: action, actionInfo: actionInfo};\n\t        }\n\t        eventActionMap[eventName] = actionType;\n\t    };\n\t\n\t    /**\n\t     * @param {string} type\n\t     * @param {*} CoordinateSystem\n\t     */\n\t    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n\t        CoordinateSystemManager.register(type, CoordinateSystem);\n\t    };\n\t\n\t    /**\n\t     * Layout is a special stage of visual encoding\n\t     * Most visual encoding like color are common for different chart\n\t     * But each chart has it's own layout algorithm\n\t     *\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} layoutFunc\n\t     */\n\t    echarts.registerLayout = function (priority, layoutFunc) {\n\t        if (typeof priority === 'function') {\n\t            layoutFunc = priority;\n\t            priority = PRIORITY_VISUAL_LAYOUT;\n\t        }\n\t        if (__DEV__) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown layout priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: layoutFunc,\n\t            isLayout: true\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @param {number} [priority=3000]\n\t     * @param {Function} visualFunc\n\t     */\n\t    echarts.registerVisual = function (priority, visualFunc) {\n\t        if (typeof priority === 'function') {\n\t            visualFunc = priority;\n\t            priority = PRIORITY_VISUAL_CHART;\n\t        }\n\t        if (__DEV__) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown visual priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: visualFunc\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @param {string} name\n\t     */\n\t    echarts.registerLoading = function (name, loadingFx) {\n\t        loadingEffects[name] = loadingFx;\n\t    };\n\t\n\t\n\t    var parseClassType = ComponentModel.parseClassType;\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentModel = function (opts, superClass) {\n\t        var Clazz = ComponentModel;\n\t        if (superClass) {\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentView = function (opts, superClass) {\n\t        var Clazz = ComponentView;\n\t        if (superClass) {\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendSeriesModel = function (opts, superClass) {\n\t        var Clazz = SeriesModel;\n\t        if (superClass) {\n\t            superClass = 'series.' + superClass.replace('series.', '');\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendChartView = function (opts, superClass) {\n\t        var Clazz = ChartView;\n\t        if (superClass) {\n\t            superClass.replace('series.', '');\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ChartView.getClass(classType.main, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * ZRender need a canvas context to do measureText.\n\t     * But in node environment canvas may be created by node-canvas.\n\t     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n\t     *\n\t     * Be careful of using it in the browser.\n\t     *\n\t     * @param {Function} creator\n\t     * @example\n\t     *     var Canvas = require('canvas');\n\t     *     var echarts = require('echarts');\n\t     *     echarts.setCanvasCreator(function () {\n\t     *         // Small size is enough.\n\t     *         return new Canvas(32, 32);\n\t     *     });\n\t     */\n\t    echarts.setCanvasCreator = function (creator) {\n\t        zrUtil.createCanvas = creator;\n\t    };\n\t\n\t    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, __webpack_require__(138));\n\t    echarts.registerPreprocessor(__webpack_require__(132));\n\t    echarts.registerLoading('default', __webpack_require__(122));\n\t\n\t    // Default action\n\t    echarts.registerAction({\n\t        type: 'highlight',\n\t        event: 'highlight',\n\t        update: 'highlight'\n\t    }, zrUtil.noop);\n\t    echarts.registerAction({\n\t        type: 'downplay',\n\t        event: 'downplay',\n\t        update: 'downplay'\n\t    }, zrUtil.noop);\n\t\n\t\n\t    // --------\n\t    // Exports\n\t    // --------\n\t    //\n\t    echarts.List = __webpack_require__(71);\n\t    echarts.Model = __webpack_require__(15);\n\t\n\t    echarts.graphic = __webpack_require__(10);\n\t    echarts.number = __webpack_require__(12);\n\t    echarts.format = __webpack_require__(9);\n\t    echarts.matrix = __webpack_require__(27);\n\t    echarts.vector = __webpack_require__(7);\n\t    echarts.color = __webpack_require__(29);\n\t\n\t    echarts.util = {};\n\t    each([\n\t            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n\t            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n\t            'extend', 'defaults', 'clone'\n\t        ],\n\t        function (name) {\n\t            echarts.util[name] = zrUtil[name];\n\t        }\n\t    );\n\t\n\t    // PRIORITY\n\t    echarts.PRIORITY = {\n\t        PROCESSOR: {\n\t            FILTER: PRIORITY_PROCESSOR_FILTER,\n\t            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n\t        },\n\t        VISUAL: {\n\t            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n\t            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n\t            CHART: PRIORITY_VISUAL_CHART,\n\t            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n\t            BRUSH: PRIORITY_VISUAL_BRUSH\n\t        }\n\t    };\n\t\n\t    module.exports = echarts;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Path element\n\t * @module zrender/graphic/Path\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(54);\n\t    var zrUtil = __webpack_require__(1);\n\t    var PathProxy = __webpack_require__(41);\n\t    var pathContain = __webpack_require__(166);\n\t\n\t    var Pattern = __webpack_require__(80);\n\t    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\t\n\t    var abs = Math.abs;\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Path\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function Path(opts) {\n\t        Displayable.call(this, opts);\n\t\n\t        /**\n\t         * @type {module:zrender/core/PathProxy}\n\t         * @readOnly\n\t         */\n\t        this.path = new PathProxy();\n\t    }\n\t\n\t    Path.prototype = {\n\t\n\t        constructor: Path,\n\t\n\t        type: 'path',\n\t\n\t        __dirtyPath: true,\n\t\n\t        strokeContainThreshold: 5,\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var path = this.path;\n\t            var hasStroke = style.hasStroke();\n\t            var hasFill = style.hasFill();\n\t            var fill = style.fill;\n\t            var stroke = style.stroke;\n\t            var hasFillGradient = hasFill && !!(fill.colorStops);\n\t            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n\t            var hasFillPattern = hasFill && !!(fill.image);\n\t            var hasStrokePattern = hasStroke && !!(stroke.image);\n\t\n\t            style.bind(ctx, this, prevEl);\n\t            this.setTransform(ctx);\n\t\n\t            if (this.__dirty) {\n\t                var rect = this.getBoundingRect();\n\t                // Update gradient because bounding rect may changed\n\t                if (hasFillGradient) {\n\t                    this._fillGradient = style.getGradient(ctx, fill, rect);\n\t                }\n\t                if (hasStrokeGradient) {\n\t                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t                }\n\t            }\n\t            // Use the gradient or pattern\n\t            if (hasFillGradient) {\n\t                // PENDING If may have affect the state\n\t                ctx.fillStyle = this._fillGradient;\n\t            }\n\t            else if (hasFillPattern) {\n\t                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t            }\n\t            if (hasStrokeGradient) {\n\t                ctx.strokeStyle = this._strokeGradient;\n\t            }\n\t            else if (hasStrokePattern) {\n\t                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t            }\n\t\n\t            var lineDash = style.lineDash;\n\t            var lineDashOffset = style.lineDashOffset;\n\t\n\t            var ctxLineDash = !!ctx.setLineDash;\n\t\n\t            // Update path sx, sy\n\t            var scale = this.getGlobalScale();\n\t            path.setScale(scale[0], scale[1]);\n\t\n\t            // Proxy context\n\t            // Rebuild path in following 2 cases\n\t            // 1. Path is dirty\n\t            // 2. Path needs javascript implemented lineDash stroking.\n\t            //    In this case, lineDash information will not be saved in PathProxy\n\t            if (this.__dirtyPath || (\n\t                lineDash && !ctxLineDash && hasStroke\n\t            )) {\n\t                path = this.path.beginPath(ctx);\n\t\n\t                // Setting line dash before build path\n\t                if (lineDash && !ctxLineDash) {\n\t                    path.setLineDash(lineDash);\n\t                    path.setLineDashOffset(lineDashOffset);\n\t                }\n\t\n\t                this.buildPath(path, this.shape, false);\n\t\n\t                // Clear path dirty flag\n\t                this.__dirtyPath = false;\n\t            }\n\t            else {\n\t                // Replay path building\n\t                ctx.beginPath();\n\t                this.path.rebuildPath(ctx);\n\t            }\n\t\n\t            hasFill && path.fill(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                ctx.setLineDash(lineDash);\n\t                ctx.lineDashOffset = lineDashOffset;\n\t            }\n\t\n\t            hasStroke && path.stroke(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                // PENDING\n\t                // Remove lineDash\n\t                ctx.setLineDash([]);\n\t            }\n\t\n\t\n\t            this.restoreTransform(ctx);\n\t\n\t            // Draw rect text\n\t            if (style.text != null) {\n\t                // var rect = this.getBoundingRect();\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t        },\n\t\n\t        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n\t        // Like in circle\n\t        buildPath: function (ctx, shapeCfg, inBundle) {},\n\t\n\t        getBoundingRect: function () {\n\t            var rect = this._rect;\n\t            var style = this.style;\n\t            var needsUpdateRect = !rect;\n\t            if (needsUpdateRect) {\n\t                var path = this.path;\n\t                if (this.__dirtyPath) {\n\t                    path.beginPath();\n\t                    this.buildPath(path, this.shape, false);\n\t                }\n\t                rect = path.getBoundingRect();\n\t            }\n\t            this._rect = rect;\n\t\n\t            if (style.hasStroke()) {\n\t                // Needs update rect with stroke lineWidth when\n\t                // 1. Element changes scale or lineWidth\n\t                // 2. Shape is changed\n\t                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t                if (this.__dirty || needsUpdateRect) {\n\t                    rectWithStroke.copy(rect);\n\t                    // FIXME Must after updateTransform\n\t                    var w = style.lineWidth;\n\t                    // PENDING, Min line width is needed when line is horizontal or vertical\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t\n\t                    // Only add extra hover lineWidth when there are no fill\n\t                    if (!style.hasFill()) {\n\t                        w = Math.max(w, this.strokeContainThreshold || 4);\n\t                    }\n\t                    // Consider line width\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        rectWithStroke.width += w / lineScale;\n\t                        rectWithStroke.height += w / lineScale;\n\t                        rectWithStroke.x -= w / lineScale / 2;\n\t                        rectWithStroke.y -= w / lineScale / 2;\n\t                    }\n\t                }\n\t\n\t                // Return rect with stroke\n\t                return rectWithStroke;\n\t            }\n\t\n\t            return rect;\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var localPos = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            var style = this.style;\n\t            x = localPos[0];\n\t            y = localPos[1];\n\t\n\t            if (rect.contain(x, y)) {\n\t                var pathData = this.path.data;\n\t                if (style.hasStroke()) {\n\t                    var lineWidth = style.lineWidth;\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        // Only add extra hover lineWidth when there are no fill\n\t                        if (!style.hasFill()) {\n\t                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t                        }\n\t                        if (pathContain.containStroke(\n\t                            pathData, lineWidth / lineScale, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                if (style.hasFill()) {\n\t                    return pathContain.contain(pathData, x, y);\n\t                }\n\t            }\n\t            return false;\n\t        },\n\t\n\t        /**\n\t         * @param  {boolean} dirtyPath\n\t         */\n\t        dirty: function (dirtyPath) {\n\t            if (dirtyPath == null) {\n\t                dirtyPath = true;\n\t            }\n\t            // Only mark dirty, not mark clean\n\t            if (dirtyPath) {\n\t                this.__dirtyPath = dirtyPath;\n\t                this._rect = null;\n\t            }\n\t\n\t            this.__dirty = true;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t\n\t            // Used as a clipping path\n\t            if (this.__clipTarget) {\n\t                this.__clipTarget.dirty();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Alias for animate('shape')\n\t         * @param {boolean} loop\n\t         */\n\t        animateShape: function (loop) {\n\t            return this.animate('shape', loop);\n\t        },\n\t\n\t        // Overwrite attrKV\n\t        attrKV: function (key, value) {\n\t            // FIXME\n\t            if (key === 'shape') {\n\t                this.setShape(value);\n\t                this.__dirtyPath = true;\n\t                this._rect = null;\n\t            }\n\t            else {\n\t                Displayable.prototype.attrKV.call(this, key, value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setShape: function (key, value) {\n\t            var shape = this.shape;\n\t            // Path from string may not have shape\n\t            if (shape) {\n\t                if (zrUtil.isObject(key)) {\n\t                    for (var name in key) {\n\t                        if (key.hasOwnProperty(name)) {\n\t                            shape[name] = key[name];\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    shape[key] = value;\n\t                }\n\t                this.dirty(true);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        getLineScale: function () {\n\t            var m = this.transform;\n\t            // Get the line scale.\n\t            // Determinant of `m` means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n\t                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n\t                : 1;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * 扩展一个 Path element, 比如星形，圆等。\n\t     * Extend a path element\n\t     * @param {Object} props\n\t     * @param {string} props.type Path type\n\t     * @param {Function} props.init Initialize\n\t     * @param {Function} props.buildPath Overwrite buildPath method\n\t     * @param {Object} [props.style] Extended default style config\n\t     * @param {Object} [props.shape] Extended default shape config\n\t     */\n\t    Path.extend = function (defaults) {\n\t        var Sub = function (opts) {\n\t            Path.call(this, opts);\n\t\n\t            if (defaults.style) {\n\t                // Extend default style\n\t                this.style.extendFrom(defaults.style, false);\n\t            }\n\t\n\t            // Extend default shape\n\t            var defaultShape = defaults.shape;\n\t            if (defaultShape) {\n\t                this.shape = this.shape || {};\n\t                var thisShape = this.shape;\n\t                for (var name in defaultShape) {\n\t                    if (\n\t                        ! thisShape.hasOwnProperty(name)\n\t                        && defaultShape.hasOwnProperty(name)\n\t                    ) {\n\t                        thisShape[name] = defaultShape[name];\n\t                    }\n\t                }\n\t            }\n\t\n\t            defaults.init && defaults.init.call(this, opts);\n\t        };\n\t\n\t        zrUtil.inherits(Sub, Path);\n\t\n\t        // FIXME 不能 extend position, rotation 等引用对象\n\t        for (var name in defaults) {\n\t            // Extending prototype values and methods\n\t            if (name !== 'style' && name !== 'shape') {\n\t                Sub.prototype[name] = defaults[name];\n\t            }\n\t        }\n\t\n\t        return Sub;\n\t    };\n\t\n\t    zrUtil.inherits(Path, Displayable);\n\t\n\t    module.exports = Path;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t\n\t    /**\n\t     * @typedef {Float32Array|Array.<number>} Vector2\n\t     */\n\t    /**\n\t     * 二维向量类\n\t     * @exports zrender/tool/vector\n\t     */\n\t    var vector = {\n\t        /**\n\t         * 创建一个向量\n\t         * @param {number} [x=0]\n\t         * @param {number} [y=0]\n\t         * @return {Vector2}\n\t         */\n\t        create: function (x, y) {\n\t            var out = new ArrayCtor(2);\n\t            if (x == null) {\n\t                x = 0;\n\t            }\n\t            if (y == null) {\n\t                y = 0;\n\t            }\n\t            out[0] = x;\n\t            out[1] = y;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 复制向量数据\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        copy: function (out, v) {\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 克隆一个向量\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        clone: function (v) {\n\t            var out = new ArrayCtor(2);\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 设置向量的两个项\n\t         * @param {Vector2} out\n\t         * @param {number} a\n\t         * @param {number} b\n\t         * @return {Vector2} 结果\n\t         */\n\t        set: function (out, a, b) {\n\t            out[0] = a;\n\t            out[1] = b;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量相加\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        add: function (out, v1, v2) {\n\t            out[0] = v1[0] + v2[0];\n\t            out[1] = v1[1] + v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量缩放后相加\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} a\n\t         */\n\t        scaleAndAdd: function (out, v1, v2, a) {\n\t            out[0] = v1[0] + v2[0] * a;\n\t            out[1] = v1[1] + v2[1] * a;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量相减\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        sub: function (out, v1, v2) {\n\t            out[0] = v1[0] - v2[0];\n\t            out[1] = v1[1] - v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量长度\n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        len: function (v) {\n\t            return Math.sqrt(this.lenSquare(v));\n\t        },\n\t\n\t        /**\n\t         * 向量长度平方\n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        lenSquare: function (v) {\n\t            return v[0] * v[0] + v[1] * v[1];\n\t        },\n\t\n\t        /**\n\t         * 向量乘法\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        mul: function (out, v1, v2) {\n\t            out[0] = v1[0] * v2[0];\n\t            out[1] = v1[1] * v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量除法\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        div: function (out, v1, v2) {\n\t            out[0] = v1[0] / v2[0];\n\t            out[1] = v1[1] / v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量点乘\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        dot: function (v1, v2) {\n\t            return v1[0] * v2[0] + v1[1] * v2[1];\n\t        },\n\t\n\t        /**\n\t         * 向量缩放\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {number} s\n\t         */\n\t        scale: function (out, v, s) {\n\t            out[0] = v[0] * s;\n\t            out[1] = v[1] * s;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量归一化\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        normalize: function (out, v) {\n\t            var d = vector.len(v);\n\t            if (d === 0) {\n\t                out[0] = 0;\n\t                out[1] = 0;\n\t            }\n\t            else {\n\t                out[0] = v[0] / d;\n\t                out[1] = v[1] / d;\n\t            }\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 计算向量间距离\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distance: function (v1, v2) {\n\t            return Math.sqrt(\n\t                (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n\t            );\n\t        },\n\t\n\t        /**\n\t         * 向量距离平方\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distanceSquare: function (v1, v2) {\n\t            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t        },\n\t\n\t        /**\n\t         * 求负向量\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        negate: function (out, v) {\n\t            out[0] = -v[0];\n\t            out[1] = -v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 插值两个点\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} t\n\t         */\n\t        lerp: function (out, v1, v2, t) {\n\t            out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t            out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 矩阵左乘向量\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {Vector2} m\n\t         */\n\t        applyTransform: function (out, v, m) {\n\t            var x = v[0];\n\t            var y = v[1];\n\t            out[0] = m[0] * x + m[2] * y + m[4];\n\t            out[1] = m[1] * x + m[3] * y + m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * 求两个向量最小值\n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        min: function (out, v1, v2) {\n\t            out[0] = Math.min(v1[0], v2[0]);\n\t            out[1] = Math.min(v1[1], v2[1]);\n\t            return out;\n\t        },\n\t        /**\n\t         * 求两个向量最大值\n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        max: function (out, v1, v2) {\n\t            out[0] = Math.max(v1[0], v2[0]);\n\t            out[1] = Math.max(v1[1], v2[1]);\n\t            return out;\n\t        }\n\t    };\n\t\n\t    vector.length = vector.len;\n\t    vector.lengthSquare = vector.lenSquare;\n\t    vector.dist = vector.distance;\n\t    vector.distSquare = vector.distanceSquare;\n\t\n\t    module.exports = vector;\n\t\n\n\n/***/ },\n/* 8 */,\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var numberUtil = __webpack_require__(12);\n\t    var textContain = __webpack_require__(26);\n\t\n\t    var formatUtil = {};\n\t    /**\n\t     * 每三位默认加,格式化\n\t     * @type {string|number} x\n\t     */\n\t    formatUtil.addCommas = function (x) {\n\t        if (isNaN(x)) {\n\t            return '-';\n\t        }\n\t        x = (x + '').split('.');\n\t        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n\t               + (x.length > 1 ? ('.' + x[1]) : '');\n\t    };\n\t\n\t    /**\n\t     * @param {string} str\n\t     * @param {boolean} [upperCaseFirst=false]\n\t     * @return {string} str\n\t     */\n\t    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n\t        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n\t            return group1.toUpperCase();\n\t        });\n\t\n\t        if (upperCaseFirst && str) {\n\t            str = str.charAt(0).toUpperCase() + str.slice(1);\n\t        }\n\t\n\t        return str;\n\t    };\n\t\n\t    /**\n\t     * Normalize css liked array configuration\n\t     * e.g.\n\t     *  3 => [3, 3, 3, 3]\n\t     *  [4, 2] => [4, 2, 4, 2]\n\t     *  [4, 3, 2] => [4, 3, 2, 3]\n\t     * @param {number|Array.<number>} val\n\t     */\n\t    formatUtil.normalizeCssArray = function (val) {\n\t        var len = val.length;\n\t        if (typeof (val) === 'number') {\n\t            return [val, val, val, val];\n\t        }\n\t        else if (len === 2) {\n\t            // vertical | horizontal\n\t            return [val[0], val[1], val[0], val[1]];\n\t        }\n\t        else if (len === 3) {\n\t            // top | horizontal | bottom\n\t            return [val[0], val[1], val[2], val[1]];\n\t        }\n\t        return val;\n\t    };\n\t\n\t    formatUtil.encodeHTML = function (source) {\n\t        return String(source)\n\t            .replace(/&/g, '&amp;')\n\t            .replace(/</g, '&lt;')\n\t            .replace(/>/g, '&gt;')\n\t            .replace(/\"/g, '&quot;')\n\t            .replace(/'/g, '&#39;');\n\t    };\n\t\n\t    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\t\n\t    var wrapVar = function (varName, seriesIdx) {\n\t        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n\t    };\n\t\n\t    /**\n\t     * Template formatter\n\t     * @param  {string} tpl\n\t     * @param  {Array.<Object>|Object} paramsList\n\t     * @return {string}\n\t     */\n\t    formatUtil.formatTpl = function (tpl, paramsList) {\n\t        if (!zrUtil.isArray(paramsList)) {\n\t            paramsList = [paramsList];\n\t        }\n\t        var seriesLen = paramsList.length;\n\t        if (!seriesLen) {\n\t            return '';\n\t        }\n\t\n\t        var $vars = paramsList[0].$vars || [];\n\t        for (var i = 0; i < $vars.length; i++) {\n\t            var alias = TPL_VAR_ALIAS[i];\n\t            tpl = tpl.replace(wrapVar(alias),  wrapVar(alias, 0));\n\t        }\n\t        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n\t            for (var k = 0; k < $vars.length; k++) {\n\t                tpl = tpl.replace(\n\t                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n\t                    paramsList[seriesIdx][$vars[k]]\n\t                );\n\t            }\n\t        }\n\t\n\t        return tpl;\n\t    };\n\t\n\t\n\t    /**\n\t     * @param {string} str\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    var s2d = function (str) {\n\t        return str < 10 ? ('0' + str) : str;\n\t    };\n\t\n\t    /**\n\t     * ISO Date format\n\t     * @param {string} tpl\n\t     * @param {number} value\n\t     * @inner\n\t     */\n\t    formatUtil.formatTime = function (tpl, value) {\n\t        if (tpl === 'week'\n\t            || tpl === 'month'\n\t            || tpl === 'quarter'\n\t            || tpl === 'half-year'\n\t            || tpl === 'year'\n\t        ) {\n\t            tpl = 'MM-dd\\nyyyy';\n\t        }\n\t\n\t        var date = numberUtil.parseDate(value);\n\t        var y = date.getFullYear();\n\t        var M = date.getMonth() + 1;\n\t        var d = date.getDate();\n\t        var h = date.getHours();\n\t        var m = date.getMinutes();\n\t        var s = date.getSeconds();\n\t\n\t        tpl = tpl.replace('MM', s2d(M))\n\t            .toLowerCase()\n\t            .replace('yyyy', y)\n\t            .replace('yy', y % 100)\n\t            .replace('dd', s2d(d))\n\t            .replace('d', d)\n\t            .replace('hh', s2d(h))\n\t            .replace('h', h)\n\t            .replace('mm', s2d(m))\n\t            .replace('m', m)\n\t            .replace('ss', s2d(s))\n\t            .replace('s', s);\n\t\n\t        return tpl;\n\t    };\n\t\n\t    /**\n\t     * Capital first\n\t     * @param {string} str\n\t     * @return {string}\n\t     */\n\t    formatUtil.capitalFirst = function (str) {\n\t        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n\t    };\n\t\n\t    formatUtil.truncateText = textContain.truncateText;\n\t\n\t    module.exports = formatUtil;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var pathTool = __webpack_require__(193);\n\t    var round = Math.round;\n\t    var Path = __webpack_require__(6);\n\t    var colorTool = __webpack_require__(29);\n\t    var matrix = __webpack_require__(27);\n\t    var vector = __webpack_require__(7);\n\t\n\t    var graphic = {};\n\t\n\t    graphic.Group = __webpack_require__(40);\n\t\n\t    graphic.Image = __webpack_require__(79);\n\t\n\t    graphic.Text = __webpack_require__(176);\n\t\n\t    graphic.Circle = __webpack_require__(183);\n\t\n\t    graphic.Sector = __webpack_require__(189);\n\t\n\t    graphic.Ring = __webpack_require__(188);\n\t\n\t    graphic.Polygon = __webpack_require__(185);\n\t\n\t    graphic.Polyline = __webpack_require__(186);\n\t\n\t    graphic.Rect = __webpack_require__(187);\n\t\n\t    graphic.Line = __webpack_require__(184);\n\t\n\t    graphic.BezierCurve = __webpack_require__(182);\n\t\n\t    graphic.Arc = __webpack_require__(181);\n\t\n\t    graphic.CompoundPath = __webpack_require__(173);\n\t\n\t    graphic.LinearGradient = __webpack_require__(174);\n\t\n\t    graphic.RadialGradient = __webpack_require__(175);\n\t\n\t    graphic.BoundingRect = __webpack_require__(13);\n\t\n\t    /**\n\t     * Extend shape with parameters\n\t     */\n\t    graphic.extendShape = function (opts) {\n\t        return Path.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * Extend path\n\t     */\n\t    graphic.extendPath = function (pathData, opts) {\n\t        return pathTool.extendFromString(pathData, opts);\n\t    };\n\t\n\t    /**\n\t     * Create a path element from path data string\n\t     * @param {string} pathData\n\t     * @param {Object} opts\n\t     * @param {module:zrender/core/BoundingRect} rect\n\t     * @param {string} [layout=cover] 'center' or 'cover'\n\t     */\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\n\t        var path = pathTool.createFromString(pathData, opts);\n\t        var boundingRect = path.getBoundingRect();\n\t        if (rect) {\n\t            var aspect = boundingRect.width / boundingRect.height;\n\t\n\t            if (layout === 'center') {\n\t                // Set rect to center, keep width / height ratio.\n\t                var width = rect.height * aspect;\n\t                var height;\n\t                if (width <= rect.width) {\n\t                    height = rect.height;\n\t                }\n\t                else {\n\t                    width = rect.width;\n\t                    height = width / aspect;\n\t                }\n\t                var cx = rect.x + rect.width / 2;\n\t                var cy = rect.y + rect.height / 2;\n\t\n\t                rect.x = cx - width / 2;\n\t                rect.y = cy - height / 2;\n\t                rect.width = width;\n\t                rect.height = height;\n\t            }\n\t\n\t            this.resizePath(path, rect);\n\t        }\n\t        return path;\n\t    };\n\t\n\t    graphic.mergePath = pathTool.mergePath,\n\t\n\t    /**\n\t     * Resize a path to fit the rect\n\t     * @param {module:zrender/graphic/Path} path\n\t     * @param {Object} rect\n\t     */\n\t    graphic.resizePath = function (path, rect) {\n\t        if (!path.applyTransform) {\n\t            return;\n\t        }\n\t\n\t        var pathRect = path.getBoundingRect();\n\t\n\t        var m = pathRect.calculateTransform(rect);\n\t\n\t        path.applyTransform(m);\n\t    };\n\t\n\t    /**\n\t     * Sub pixel optimize line for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x1]\n\t     * @param {number} [param.shape.y1]\n\t     * @param {number} [param.shape.x2]\n\t     * @param {number} [param.shape.y2]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeLine = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n\t        }\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n\t        }\n\t        return param;\n\t    };\n\t\n\t    /**\n\t     * Sub pixel optimize rect for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x]\n\t     * @param {number} [param.shape.y]\n\t     * @param {number} [param.shape.width]\n\t     * @param {number} [param.shape.height]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeRect = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t        var originX = shape.x;\n\t        var originY = shape.y;\n\t        var originWidth = shape.width;\n\t        var originHeight = shape.height;\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n\t        shape.width = Math.max(\n\t            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n\t            originWidth === 0 ? 0 : 1\n\t        );\n\t        shape.height = Math.max(\n\t            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n\t            originHeight === 0 ? 0 : 1\n\t        );\n\t        return param;\n\t    };\n\t\n\t    /**\n\t     * Sub pixel optimize for canvas\n\t     *\n\t     * @param {number} position Coordinate, such as x, y\n\t     * @param {number} lineWidth Should be nonnegative integer.\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\n\t     * @return {number} Optimized position.\n\t     */\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\n\t        // otherwise line will be fuzzy in canvas.\n\t        var doubledPosition = round(position * 2);\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0\n\t            ? doubledPosition / 2\n\t            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n\t    };\n\t\n\t    function hasFillOrStroke(fillOrStroke) {\n\t        return fillOrStroke != null && fillOrStroke != 'none';\n\t    }\n\t\n\t    function liftColor(color) {\n\t        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    function cacheElementStl(el) {\n\t        if (el.__hoverStlDirty) {\n\t            var stroke = el.style.stroke;\n\t            var fill = el.style.fill;\n\t\n\t            // Create hoverStyle on mouseover\n\t            var hoverStyle = el.__hoverStl;\n\t            hoverStyle.fill = hoverStyle.fill\n\t                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n\t            hoverStyle.stroke = hoverStyle.stroke\n\t                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\t\n\t            var normalStyle = {};\n\t            for (var name in hoverStyle) {\n\t                if (hoverStyle.hasOwnProperty(name)) {\n\t                    normalStyle[name] = el.style[name];\n\t                }\n\t            }\n\t\n\t            el.__normalStl = normalStyle;\n\t\n\t            el.__hoverStlDirty = false;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    function doSingleEnterHover(el) {\n\t        if (el.__isHover) {\n\t            return;\n\t        }\n\t\n\t        cacheElementStl(el);\n\t\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n\t        }\n\t        else {\n\t            el.setStyle(el.__hoverStl);\n\t            el.z2 += 1;\n\t        }\n\t\n\t        el.__isHover = true;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function doSingleLeaveHover(el) {\n\t        if (!el.__isHover) {\n\t            return;\n\t        }\n\t\n\t        var normalStl = el.__normalStl;\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.removeHover(el);\n\t        }\n\t        else {\n\t            normalStl && el.setStyle(normalStl);\n\t            el.z2 -= 1;\n\t        }\n\t\n\t        el.__isHover = false;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function doEnterHover(el) {\n\t        el.type === 'group'\n\t            ? el.traverse(function (child) {\n\t                if (child.type !== 'group') {\n\t                    doSingleEnterHover(child);\n\t                }\n\t            })\n\t            : doSingleEnterHover(el);\n\t    }\n\t\n\t    function doLeaveHover(el) {\n\t        el.type === 'group'\n\t            ? el.traverse(function (child) {\n\t                if (child.type !== 'group') {\n\t                    doSingleLeaveHover(child);\n\t                }\n\t            })\n\t            : doSingleLeaveHover(el);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function setElementHoverStl(el, hoverStl) {\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n\t        // Often used when item group has a label element and it's hoverStyle is different\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\n\t        el.__hoverStlDirty = true;\n\t\n\t        if (el.__isHover) {\n\t            cacheElementStl(el);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOver(e) {\n\t        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n\t            return;\n\t        }\n\t\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doEnterHover(this);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOut(e) {\n\t        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n\t            return;\n\t        }\n\t\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doLeaveHover(this);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function enterEmphasis() {\n\t        this.__isEmphasis = true;\n\t        doEnterHover(this);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function leaveEmphasis() {\n\t        this.__isEmphasis = false;\n\t        doLeaveHover(this);\n\t    }\n\t\n\t    /**\n\t     * Set hover style of element\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} [hoverStyle]\n\t     * @param {Object} [opt]\n\t     * @param {boolean} [opt.hoverSilentOnTouch=false]\n\t     *        In touch device, mouseover event will be trigger on touchstart event\n\t     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n\t     *        conviniently use hoverStyle when tap on touch screen without additional\n\t     *        code for compatibility.\n\t     *        But if the chart/component has select feature, which usually also use\n\t     *        hoverStyle, there might be conflict between 'select-highlight' and\n\t     *        'hover-highlight' especially when roam is enabled (see geo for example).\n\t     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n\t     *        on touch device.\n\t     */\n\t    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n\t        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\t\n\t        el.type === 'group'\n\t            ? el.traverse(function (child) {\n\t                if (child.type !== 'group') {\n\t                    setElementHoverStl(child, hoverStyle);\n\t                }\n\t            })\n\t            : setElementHoverStl(el, hoverStyle);\n\t\n\t        // Duplicated function will be auto-ignored, see Eventful.js.\n\t        el.on('mouseover', onElementMouseOver)\n\t          .on('mouseout', onElementMouseOut);\n\t\n\t        // Emphasis, normal can be triggered manually\n\t        el.on('emphasis', enterEmphasis)\n\t          .on('normal', leaveEmphasis);\n\t    };\n\t\n\t    /**\n\t     * Set text option in the style\n\t     * @param {Object} textStyle\n\t     * @param {module:echarts/model/Model} labelModel\n\t     * @param {string} color\n\t     */\n\t    graphic.setText = function (textStyle, labelModel, color) {\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        zrUtil.extend(textStyle, {\n\t            textDistance: labelModel.getShallow('distance') || 5,\n\t            textFont: textStyleModel.getFont(),\n\t            textPosition: labelPosition,\n\t            textFill: textStyleModel.getTextColor() || labelColor\n\t        });\n\t    };\n\t\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n\t        if (typeof dataIndex === 'function') {\n\t            cb = dataIndex;\n\t            dataIndex = null;\n\t        }\n\t        var animationEnabled = animatableModel\n\t            && (\n\t                animatableModel.ifEnableAnimation\n\t                ? animatableModel.ifEnableAnimation()\n\t                // Directly use animation property\n\t                : animatableModel.getShallow('animation')\n\t            );\n\t\n\t        if (animationEnabled) {\n\t            var postfix = isUpdate ? 'Update' : '';\n\t            var duration = animatableModel\n\t                && animatableModel.getShallow('animationDuration' + postfix);\n\t            var animationEasing = animatableModel\n\t                && animatableModel.getShallow('animationEasing' + postfix);\n\t            var animationDelay = animatableModel\n\t                && animatableModel.getShallow('animationDelay' + postfix);\n\t            if (typeof animationDelay === 'function') {\n\t                animationDelay = animationDelay(dataIndex);\n\t            }\n\t            duration > 0\n\t                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n\t                : (el.attr(props), cb && cb());\n\t        }\n\t        else {\n\t            el.attr(props);\n\t            cb && cb();\n\t        }\n\t    }\n\t    /**\n\t     * Update graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} [cb]\n\t     * @example\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n\t     *     // Or\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, function () { console.log('Animation done!'); });\n\t     */\n\t    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t\n\t    /**\n\t     * Init graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} cb\n\t     */\n\t    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t\n\t    /**\n\t     * Get transform matrix of target (param target),\n\t     * in coordinate of its ancestor (param ancestor)\n\t     *\n\t     * @param {module:zrender/mixin/Transformable} target\n\t     * @param {module:zrender/mixin/Transformable} [ancestor]\n\t     */\n\t    graphic.getTransform = function (target, ancestor) {\n\t        var mat = matrix.identity([]);\n\t\n\t        while (target && target !== ancestor) {\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\n\t            target = target.parent;\n\t        }\n\t\n\t        return mat;\n\t    };\n\t\n\t    /**\n\t     * Apply transform to an vertex.\n\t     * @param {Array.<number>} vertex [x, y]\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {Array.<number>} [x, y]\n\t     */\n\t    graphic.applyTransform = function (vertex, transform, invert) {\n\t        if (invert) {\n\t            transform = matrix.invert([], transform);\n\t        }\n\t        return vector.applyTransform([], vertex, transform);\n\t    };\n\t\n\t    /**\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n\t     */\n\t    graphic.transformDirection = function (direction, transform, invert) {\n\t\n\t        // Pick a base, ensure that transform result will not be (0, 0).\n\t        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n\t            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n\t        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n\t            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\t\n\t        var vertex = [\n\t            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n\t            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n\t        ];\n\t\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\n\t\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n\t            ? (vertex[0] > 0 ? 'right' : 'left')\n\t            : (vertex[1] > 0 ? 'bottom' : 'top');\n\t    };\n\t\n\t    /**\n\t     * Apply group transition animation from g1 to g2\n\t     */\n\t    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n\t        if (!g1 || !g2) {\n\t            return;\n\t        }\n\t\n\t        function getElMap(g) {\n\t            var elMap = {};\n\t            g.traverse(function (el) {\n\t                if (!el.isGroup && el.anid) {\n\t                    elMap[el.anid] = el;\n\t                }\n\t            });\n\t            return elMap;\n\t        }\n\t        function getAnimatableProps(el) {\n\t            var obj = {\n\t                position: vector.clone(el.position),\n\t                rotation: el.rotation\n\t            };\n\t            if (el.shape) {\n\t                obj.shape = zrUtil.extend({}, el.shape);\n\t            }\n\t            return obj;\n\t        }\n\t        var elMap1 = getElMap(g1);\n\t\n\t        g2.traverse(function (el) {\n\t            if (!el.isGroup && el.anid) {\n\t                var oldEl = elMap1[el.anid];\n\t                if (oldEl) {\n\t                    var newProp = getAnimatableProps(el);\n\t                    el.attr(getAnimatableProps(oldEl));\n\t                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n\t                }\n\t                // else {\n\t                //     if (el.previousProps) {\n\t                //         graphic.updateProps\n\t                //     }\n\t                // }\n\t            }\n\t        });\n\t    };\n\t\n\t    module.exports = graphic;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var formatUtil = __webpack_require__(9);\n\t    var nubmerUtil = __webpack_require__(12);\n\t    var Model = __webpack_require__(15);\n\t    var zrUtil = __webpack_require__(1);\n\t    var each = zrUtil.each;\n\t    var isObject = zrUtil.isObject;\n\t\n\t    var modelUtil = {};\n\t\n\t    /**\n\t     * If value is not array, then translate it to array.\n\t     * @param  {*} value\n\t     * @return {Array} [value] or value\n\t     */\n\t    modelUtil.normalizeToArray = function (value) {\n\t        return value instanceof Array\n\t            ? value\n\t            : value == null\n\t            ? []\n\t            : [value];\n\t    };\n\t\n\t    /**\n\t     * Sync default option between normal and emphasis like `position` and `show`\n\t     * In case some one will write code like\n\t     *     label: {\n\t     *         normal: {\n\t     *             show: false,\n\t     *             position: 'outside',\n\t     *             textStyle: {\n\t     *                 fontSize: 18\n\t     *             }\n\t     *         },\n\t     *         emphasis: {\n\t     *             show: true\n\t     *         }\n\t     *     }\n\t     * @param {Object} opt\n\t     * @param {Array.<string>} subOpts\n\t     */\n\t     modelUtil.defaultEmphasis = function (opt, subOpts) {\n\t        if (opt) {\n\t            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n\t            var normalOpt = opt.normal = opt.normal || {};\n\t\n\t            // Default emphasis option from normal\n\t            each(subOpts, function (subOptName) {\n\t                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n\t                if (val != null) {\n\t                    emphasisOpt[subOptName] = val;\n\t                }\n\t            });\n\t        }\n\t    };\n\t\n\t    modelUtil.LABEL_OPTIONS = ['position', 'show', 'textStyle', 'distance', 'formatter'];\n\t\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method retieves value from data.\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     * @return {number|string|Date|Array.<number|string|Date>}\n\t     */\n\t    modelUtil.getDataItemValue = function (dataItem) {\n\t        // Performance sensitive.\n\t        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n\t    };\n\t\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method determine if dataItem has extra option besides value\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     */\n\t    modelUtil.isDataItemOption = function (dataItem) {\n\t        return isObject(dataItem)\n\t            && !(dataItem instanceof Array);\n\t            // // markLine data can be array\n\t            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n\t    };\n\t\n\t    /**\n\t     * This helper method convert value in data.\n\t     * @param {string|number|Date} value\n\t     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n\t     */\n\t    modelUtil.converDataValue = function (value, dimInfo) {\n\t        // Performance sensitive.\n\t        var dimType = dimInfo && dimInfo.type;\n\t        if (dimType === 'ordinal') {\n\t            return value;\n\t        }\n\t\n\t        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n\t            value = +nubmerUtil.parseDate(value);\n\t        }\n\t\n\t        // dimType defaults 'number'.\n\t        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n\t        // parse to NaN.\n\t        return (value == null || value === '')\n\t            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n\t    };\n\t\n\t    /**\n\t     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Object} opt\n\t     * @param {string} [opt.seriesIndex]\n\t     * @param {Object} [opt.name]\n\t     * @param {Object} [opt.mainType]\n\t     * @param {Object} [opt.subType]\n\t     */\n\t    modelUtil.createDataFormatModel = function (data, opt) {\n\t        var model = new Model();\n\t        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n\t        model.seriesIndex = opt.seriesIndex;\n\t        model.name = opt.name || '';\n\t        model.mainType = opt.mainType;\n\t        model.subType = opt.subType;\n\t\n\t        model.getData = function () {\n\t            return data;\n\t        };\n\t        return model;\n\t    };\n\t\n\t    // PENDING A little ugly\n\t    modelUtil.dataFormatMixin = {\n\t        /**\n\t         * Get params for formatter\n\t         * @param {number} dataIndex\n\t         * @param {string} [dataType]\n\t         * @return {Object}\n\t         */\n\t        getDataParams: function (dataIndex, dataType) {\n\t            var data = this.getData(dataType);\n\t\n\t            var seriesIndex = this.seriesIndex;\n\t            var seriesName = this.name;\n\t\n\t            var rawValue = this.getRawValue(dataIndex, dataType);\n\t            var rawDataIndex = data.getRawIndex(dataIndex);\n\t            var name = data.getName(dataIndex, true);\n\t            var itemOpt = data.getRawDataItem(dataIndex);\n\t\n\t            return {\n\t                componentType: this.mainType,\n\t                componentSubType: this.subType,\n\t                seriesType: this.mainType === 'series' ? this.subType : null,\n\t                seriesIndex: seriesIndex,\n\t                seriesName: seriesName,\n\t                name: name,\n\t                dataIndex: rawDataIndex,\n\t                data: itemOpt,\n\t                dataType: dataType,\n\t                value: rawValue,\n\t                color: data.getItemVisual(dataIndex, 'color'),\n\t\n\t                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n\t                $vars: ['seriesName', 'name', 'value']\n\t            };\n\t        },\n\t\n\t        /**\n\t         * Format label\n\t         * @param {number} dataIndex\n\t         * @param {string} [status='normal'] 'normal' or 'emphasis'\n\t         * @param {string} [dataType]\n\t         * @param {number} [dimIndex]\n\t         * @return {string}\n\t         */\n\t        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n\t            status = status || 'normal';\n\t            var data = this.getData(dataType);\n\t            var itemModel = data.getItemModel(dataIndex);\n\t\n\t            var params = this.getDataParams(dataIndex, dataType);\n\t            if (dimIndex != null && (params.value instanceof Array)) {\n\t                params.value = params.value[dimIndex];\n\t            }\n\t\n\t            var formatter = itemModel.get(['label', status, 'formatter']);\n\t\n\t            if (typeof formatter === 'function') {\n\t                params.status = status;\n\t                return formatter(params);\n\t            }\n\t            else if (typeof formatter === 'string') {\n\t                return formatUtil.formatTpl(formatter, params);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get raw value in option\n\t         * @param {number} idx\n\t         * @param {string} [dataType]\n\t         * @return {Object}\n\t         */\n\t        getRawValue: function (idx, dataType) {\n\t            var data = this.getData(dataType);\n\t            var dataItem = data.getRawDataItem(idx);\n\t            if (dataItem != null) {\n\t                return (isObject(dataItem) && !(dataItem instanceof Array))\n\t                    ? dataItem.value : dataItem;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Should be implemented.\n\t         * @param {number} dataIndex\n\t         * @param {boolean} [multipleSeries=false]\n\t         * @param {number} [dataType]\n\t         * @return {string} tooltip string\n\t         */\n\t        formatTooltip: zrUtil.noop\n\t    };\n\t\n\t    /**\n\t     * Mapping to exists for merge.\n\t     *\n\t     * @public\n\t     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n\t     * @param {Object|Array.<Object>} newCptOptions\n\t     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n\t     *                          index of which is the same as exists.\n\t     */\n\t    modelUtil.mappingToExists = function (exists, newCptOptions) {\n\t        // Mapping by the order by original option (but not order of\n\t        // new option) in merge mode. Because we should ensure\n\t        // some specified index (like xAxisIndex) is consistent with\n\t        // original option, which is easy to understand, espatially in\n\t        // media query. And in most case, merge option is used to\n\t        // update partial option but not be expected to change order.\n\t        newCptOptions = (newCptOptions || []).slice();\n\t\n\t        var result = zrUtil.map(exists || [], function (obj, index) {\n\t            return {exist: obj};\n\t        });\n\t\n\t        // Mapping by id or name if specified.\n\t        each(newCptOptions, function (cptOption, index) {\n\t            if (!isObject(cptOption)) {\n\t                return;\n\t            }\n\t\n\t            // id has highest priority.\n\t            for (var i = 0; i < result.length; i++) {\n\t                if (!result[i].option // Consider name: two map to one.\n\t                    && cptOption.id != null\n\t                    && result[i].exist.id === cptOption.id + ''\n\t                ) {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t\n\t            for (var i = 0; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option // Consider name: two map to one.\n\t                    // Can not match when both ids exist but different.\n\t                    && (exist.id == null || cptOption.id == null)\n\t                    && cptOption.name != null\n\t                    && !modelUtil.isIdInner(cptOption)\n\t                    && !modelUtil.isIdInner(exist)\n\t                    && exist.name === cptOption.name + ''\n\t                ) {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t        });\n\t\n\t        // Otherwise mapping by index.\n\t        each(newCptOptions, function (cptOption, index) {\n\t            if (!isObject(cptOption)) {\n\t                return;\n\t            }\n\t\n\t            var i = 0;\n\t            for (; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option\n\t                    // Existing model that already has id should be able to\n\t                    // mapped to (because after mapping performed model may\n\t                    // be assigned with a id, whish should not affect next\n\t                    // mapping), except those has inner id.\n\t                    && !modelUtil.isIdInner(exist)\n\t                    // Caution:\n\t                    // Do not overwrite id. But name can be overwritten,\n\t                    // because axis use name as 'show label text'.\n\t                    // 'exist' always has id and name and we dont\n\t                    // need to check it.\n\t                    && cptOption.id == null\n\t                ) {\n\t                    result[i].option = cptOption;\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (i >= result.length) {\n\t                result.push({option: cptOption});\n\t            }\n\t        });\n\t\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * Make id and name for mapping result (result of mappingToExists)\n\t     * into `keyInfo` field.\n\t     *\n\t     * @public\n\t     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n\t     *                          which order is the same as exists.\n\t     * @return {Array.<Object>} The input.\n\t     */\n\t    modelUtil.makeIdAndName = function (mapResult) {\n\t        // We use this id to hash component models and view instances\n\t        // in echarts. id can be specified by user, or auto generated.\n\t\n\t        // The id generation rule ensures new view instance are able\n\t        // to mapped to old instance when setOption are called in\n\t        // no-merge mode. So we generate model id by name and plus\n\t        // type in view id.\n\t\n\t        // name can be duplicated among components, which is convenient\n\t        // to specify multi components (like series) by one name.\n\t\n\t        // Ensure that each id is distinct.\n\t        var idMap = {};\n\t\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            existCpt && (idMap[existCpt.id] = item);\n\t        });\n\t\n\t        each(mapResult, function (item, index) {\n\t            var opt = item.option;\n\t\n\t            zrUtil.assert(\n\t                !opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item,\n\t                'id duplicates: ' + (opt && opt.id)\n\t            );\n\t\n\t            opt && opt.id != null && (idMap[opt.id] = item);\n\t            !item.keyInfo && (item.keyInfo = {});\n\t        });\n\t\n\t        // Make name and id.\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            var opt = item.option;\n\t            var keyInfo = item.keyInfo;\n\t\n\t            if (!isObject(opt)) {\n\t                return;\n\t            }\n\t\n\t            // name can be overwitten. Consider case: axis.name = '20km'.\n\t            // But id generated by name will not be changed, which affect\n\t            // only in that case: setOption with 'not merge mode' and view\n\t            // instance will be recreated, which can be accepted.\n\t            keyInfo.name = opt.name != null\n\t                ? opt.name + ''\n\t                : existCpt\n\t                ? existCpt.name\n\t                : '\\0-';\n\t\n\t            if (existCpt) {\n\t                keyInfo.id = existCpt.id;\n\t            }\n\t            else if (opt.id != null) {\n\t                keyInfo.id = opt.id + '';\n\t            }\n\t            else {\n\t                // Consider this situatoin:\n\t                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n\t                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n\t                // Series with the same name between optionA and optionB\n\t                // should be mapped.\n\t                var idNum = 0;\n\t                do {\n\t                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n\t                }\n\t                while (idMap[keyInfo.id]);\n\t            }\n\t\n\t            idMap[keyInfo.id] = item;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @public\n\t     * @param {Object} cptOption\n\t     * @return {boolean}\n\t     */\n\t    modelUtil.isIdInner = function (cptOption) {\n\t        return isObject(cptOption)\n\t            && cptOption.id\n\t            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n\t    };\n\t\n\t    /**\n\t     * A helper for removing duplicate items between batchA and batchB,\n\t     * and in themselves, and categorize by series.\n\t     *\n\t     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n\t     */\n\t    modelUtil.compressBatches = function (batchA, batchB) {\n\t        var mapA = {};\n\t        var mapB = {};\n\t\n\t        makeMap(batchA || [], mapA);\n\t        makeMap(batchB || [], mapB, mapA);\n\t\n\t        return [mapToArray(mapA), mapToArray(mapB)];\n\t\n\t        function makeMap(sourceBatch, map, otherMap) {\n\t            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n\t                var seriesId = sourceBatch[i].seriesId;\n\t                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n\t                var otherDataIndices = otherMap && otherMap[seriesId];\n\t\n\t                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n\t                    var dataIndex = dataIndices[j];\n\t\n\t                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n\t                        otherDataIndices[dataIndex] = null;\n\t                    }\n\t                    else {\n\t                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        function mapToArray(map, isData) {\n\t            var result = [];\n\t            for (var i in map) {\n\t                if (map.hasOwnProperty(i) && map[i] != null) {\n\t                    if (isData) {\n\t                        result.push(+i);\n\t                    }\n\t                    else {\n\t                        var dataIndices = mapToArray(map[i], true);\n\t                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n\t                    }\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n\t     *                         each of which can be Array or primary type.\n\t     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n\t     */\n\t    modelUtil.queryDataIndex = function (data, payload) {\n\t        if (payload.dataIndexInside != null) {\n\t            return payload.dataIndexInside;\n\t        }\n\t        else if (payload.dataIndex != null) {\n\t            return zrUtil.isArray(payload.dataIndex)\n\t                ? zrUtil.map(payload.dataIndex, function (value) {\n\t                    return data.indexOfRawIndex(value);\n\t                })\n\t                : data.indexOfRawIndex(payload.dataIndex);\n\t        }\n\t        else if (payload.name != null) {\n\t            return zrUtil.isArray(payload.name)\n\t                ? zrUtil.map(payload.name, function (value) {\n\t                    return data.indexOfName(value);\n\t                })\n\t                : data.indexOfName(payload.name);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex, seriesId, seriesName,\n\t     *            geoIndex, geoId, goeName,\n\t     *            bmapIndex, bmapId, bmapName,\n\t     *            xAxisIndex, xAxisId, xAxisName,\n\t     *            yAxisIndex, yAxisId, yAxisName,\n\t     *            gridIndex, gridId, gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     *        Each properties can be number|string|Array.<number>|Array.<string>\n\t     *        For example, a finder could be\n\t     *        {\n\t     *            seriesIndex: 3,\n\t     *            geoId: ['aa', 'cc'],\n\t     *            gridName: ['xx', 'rr']\n\t     *        }\n\t     * @param {Object} [opt]\n\t     * @param {string} [opt.defaultMainType]\n\t     * @return {Object} result like:\n\t     *        {\n\t     *            seriesModels: [seriesModel1, seriesModel2],\n\t     *            seriesModel: seriesModel1, // The first model\n\t     *            geoModels: [geoModel1, geoModel2],\n\t     *            geoModel: geoModel1, // The first model\n\t     *            ...\n\t     *        }\n\t     */\n\t    modelUtil.parseFinder = function (ecModel, finder, opt) {\n\t        if (zrUtil.isString(finder)) {\n\t            var obj = {};\n\t            obj[finder + 'Index'] = 0;\n\t            finder = obj;\n\t        }\n\t\n\t        var defaultMainType = opt && opt.defaultMainType;\n\t        if (defaultMainType\n\t            && !has(finder, defaultMainType + 'Index')\n\t            && !has(finder, defaultMainType + 'Id')\n\t            && !has(finder, defaultMainType + 'Name')\n\t        ) {\n\t            finder[defaultMainType + 'Index'] = 0;\n\t        }\n\t\n\t        var result = {};\n\t\n\t        each(finder, function (value, key) {\n\t            var value = finder[key];\n\t\n\t            // Exclude 'dataIndex' and other illgal keys.\n\t            if (key === 'dataIndex' || key === 'dataIndexInside') {\n\t                result[key] = value;\n\t                return;\n\t            }\n\t\n\t            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n\t            var mainType = parsedKey[1];\n\t            var queryType = parsedKey[2];\n\t\n\t            if (!mainType || !queryType) {\n\t                return;\n\t            }\n\t\n\t            var queryParam = {mainType: mainType};\n\t            queryParam[queryType.toLowerCase()] = value;\n\t            var models = ecModel.queryComponents(queryParam);\n\t            result[mainType + 'Models'] = models;\n\t            result[mainType + 'Model'] = models[0];\n\t        });\n\t\n\t        return result;\n\t    };\n\t\n\t    function has(obj, prop) {\n\t        return obj && obj.hasOwnProperty(prop);\n\t    }\n\t\n\t    module.exports = modelUtil;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t/**\n\t * 数值处理模块\n\t * @module echarts/util/number\n\t */\n\t\n\t\n\t\n\t    var number = {};\n\t\n\t    var RADIAN_EPSILON = 1e-4;\n\t\n\t    function _trim(str) {\n\t        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n\t    }\n\t\n\t    /**\n\t     * Linear mapping a value from domain to range\n\t     * @memberOf module:echarts/util/number\n\t     * @param  {(number|Array.<number>)} val\n\t     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n\t     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n\t     * @param  {boolean} clamp\n\t     * @return {(number|Array.<number>}\n\t     */\n\t    number.linearMap = function (val, domain, range, clamp) {\n\t        var subDomain = domain[1] - domain[0];\n\t        var subRange = range[1] - range[0];\n\t\n\t        if (subDomain === 0) {\n\t            return subRange === 0\n\t                ? range[0]\n\t                : (range[0] + range[1]) / 2;\n\t        }\n\t\n\t        // Avoid accuracy problem in edge, such as\n\t        // 146.39 - 62.83 === 83.55999999999999.\n\t        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n\t        // It is a little verbose for efficiency considering this method\n\t        // is a hotspot.\n\t        if (clamp) {\n\t            if (subDomain > 0) {\n\t                if (val <= domain[0]) {\n\t                    return range[0];\n\t                }\n\t                else if (val >= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            }\n\t            else {\n\t                if (val >= domain[0]) {\n\t                    return range[0];\n\t                }\n\t                else if (val <= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            if (val === domain[0]) {\n\t                return range[0];\n\t            }\n\t            if (val === domain[1]) {\n\t                return range[1];\n\t            }\n\t        }\n\t\n\t        return (val - domain[0]) / subDomain * subRange + range[0];\n\t    };\n\t\n\t    /**\n\t     * Convert a percent string to absolute number.\n\t     * Returns NaN if percent is not a valid string or number\n\t     * @memberOf module:echarts/util/number\n\t     * @param {string|number} percent\n\t     * @param {number} all\n\t     * @return {number}\n\t     */\n\t    number.parsePercent = function(percent, all) {\n\t        switch (percent) {\n\t            case 'center':\n\t            case 'middle':\n\t                percent = '50%';\n\t                break;\n\t            case 'left':\n\t            case 'top':\n\t                percent = '0%';\n\t                break;\n\t            case 'right':\n\t            case 'bottom':\n\t                percent = '100%';\n\t                break;\n\t        }\n\t        if (typeof percent === 'string') {\n\t            if (_trim(percent).match(/%$/)) {\n\t                return parseFloat(percent) / 100 * all;\n\t            }\n\t\n\t            return parseFloat(percent);\n\t        }\n\t\n\t        return percent == null ? NaN : +percent;\n\t    };\n\t\n\t    /**\n\t     * Fix rounding error of float numbers\n\t     * @param {number} x\n\t     * @return {number}\n\t     */\n\t    number.round = function (x, precision) {\n\t        if (precision == null) {\n\t            precision = 10;\n\t        }\n\t        // Avoid range error\n\t        precision = Math.min(Math.max(0, precision), 20);\n\t        return +(+x).toFixed(precision);\n\t    };\n\t\n\t    number.asc = function (arr) {\n\t        arr.sort(function (a, b) {\n\t            return a - b;\n\t        });\n\t        return arr;\n\t    };\n\t\n\t    /**\n\t     * Get precision\n\t     * @param {number} val\n\t     */\n\t    number.getPrecision = function (val) {\n\t        val = +val;\n\t        if (isNaN(val)) {\n\t            return 0;\n\t        }\n\t        // It is much faster than methods converting number to string as follows\n\t        //      var tmp = val.toString();\n\t        //      return tmp.length - 1 - tmp.indexOf('.');\n\t        // especially when precision is low\n\t        var e = 1;\n\t        var count = 0;\n\t        while (Math.round(val * e) / e !== val) {\n\t            e *= 10;\n\t            count++;\n\t        }\n\t        return count;\n\t    };\n\t\n\t    number.getPrecisionSafe = function (val) {\n\t        var str = val.toString();\n\t        var dotIndex = str.indexOf('.');\n\t        if (dotIndex < 0) {\n\t            return 0;\n\t        }\n\t        return str.length - 1 - dotIndex;\n\t    };\n\t\n\t    /**\n\t     * @param {Array.<number>} dataExtent\n\t     * @param {Array.<number>} pixelExtent\n\t     * @return {number}  precision\n\t     */\n\t    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n\t        var log = Math.log;\n\t        var LN10 = Math.LN10;\n\t        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n\t        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n\t        return Math.max(\n\t            -dataQuantity + sizeQuantity,\n\t            0\n\t        );\n\t    };\n\t\n\t    // Number.MAX_SAFE_INTEGER, ie do not support.\n\t    number.MAX_SAFE_INTEGER = 9007199254740991;\n\t\n\t    /**\n\t     * To 0 - 2 * PI, considering negative radian.\n\t     * @param {number} radian\n\t     * @return {number}\n\t     */\n\t    number.remRadian = function (radian) {\n\t        var pi2 = Math.PI * 2;\n\t        return (radian % pi2 + pi2) % pi2;\n\t    };\n\t\n\t    /**\n\t     * @param {type} radian\n\t     * @return {boolean}\n\t     */\n\t    number.isRadianAroundZero = function (val) {\n\t        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n\t    };\n\t\n\t    /**\n\t     * @param {string|Date|number} value\n\t     * @return {Date} date\n\t     */\n\t    number.parseDate = function (value) {\n\t        if (value instanceof Date) {\n\t            return value;\n\t        }\n\t        else if (typeof value === 'string') {\n\t            // Treat as ISO format. See issue #3623\n\t            var ret = new Date(value);\n\t            if (isNaN(+ret)) {\n\t                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n\t                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n\t            }\n\t            return ret;\n\t        }\n\t\n\t        return new Date(Math.round(value));\n\t    };\n\t\n\t    /**\n\t     * Quantity of a number. e.g. 0.1, 1, 10, 100\n\t     * @param  {number} val\n\t     * @return {number}\n\t     */\n\t    number.quantity = function (val) {\n\t        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n\t    };\n\t\n\t    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t    /**\n\t     * find a “nice” number approximately equal to x. Round the number if round = true, take ceiling if round = false\n\t     * The primary observation is that the “nicest” numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n\t     * @param  {number} val\n\t     * @param  {boolean} round\n\t     * @return {number}\n\t     */\n\t    number.nice = function (val, round) {\n\t        var exp10 = number.quantity(val);\n\t        var f = val / exp10; // between 1 and 10\n\t        var nf;\n\t        if (round) {\n\t            if (f < 1.5) { nf = 1; }\n\t            else if (f < 2.5) { nf = 2; }\n\t            else if (f < 4) { nf = 3; }\n\t            else if (f < 7) { nf = 5; }\n\t            else { nf = 10; }\n\t        }\n\t        else {\n\t            if (f < 1) { nf = 1; }\n\t            else if (f < 2) { nf = 2; }\n\t            else if (f < 3) { nf = 3; }\n\t            else if (f < 5) { nf = 5; }\n\t            else { nf = 10; }\n\t        }\n\t        return nf * exp10;\n\t    };\n\t\n\t    /**\n\t     * Order intervals asc, and split them when overlap.\n\t     * expect(numberUtil.reformIntervals([\n\t     *     {interval: [18, 62], close: [1, 1]},\n\t     *     {interval: [-Infinity, -70], close: [0, 0]},\n\t     *     {interval: [-70, -26], close: [1, 1]},\n\t     *     {interval: [-26, 18], close: [1, 1]},\n\t     *     {interval: [62, 150], close: [1, 1]},\n\t     *     {interval: [106, 150], close: [1, 1]},\n\t     *     {interval: [150, Infinity], close: [0, 0]}\n\t     * ])).toEqual([\n\t     *     {interval: [-Infinity, -70], close: [0, 0]},\n\t     *     {interval: [-70, -26], close: [1, 1]},\n\t     *     {interval: [-26, 18], close: [0, 1]},\n\t     *     {interval: [18, 62], close: [0, 1]},\n\t     *     {interval: [62, 150], close: [0, 1]},\n\t     *     {interval: [150, Infinity], close: [0, 0]}\n\t     * ]);\n\t     * @param {Array.<Object>} list, where `close` mean open or close\n\t     *        of the interval, and Infinity can be used.\n\t     * @return {Array.<Object>} The origin list, which has been reformed.\n\t     */\n\t    number.reformIntervals = function (list) {\n\t        list.sort(function (a, b) {\n\t            return littleThan(a, b, 0) ? -1 : 1;\n\t        });\n\t\n\t        var curr = -Infinity;\n\t        var currClose = 1;\n\t        for (var i = 0; i < list.length;) {\n\t            var interval = list[i].interval;\n\t            var close = list[i].close;\n\t\n\t            for (var lg = 0; lg < 2; lg++) {\n\t                if (interval[lg] <= curr) {\n\t                    interval[lg] = curr;\n\t                    close[lg] = !lg ? 1 - currClose : 1;\n\t                }\n\t                curr = interval[lg];\n\t                currClose = close[lg];\n\t            }\n\t\n\t            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n\t                list.splice(i, 1);\n\t            }\n\t            else {\n\t                i++;\n\t            }\n\t        }\n\t\n\t        return list;\n\t\n\t        function littleThan(a, b, lg) {\n\t            return a.interval[lg] < b.interval[lg]\n\t                || (\n\t                    a.interval[lg] === b.interval[lg]\n\t                    && (\n\t                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n\t                        || (!lg && littleThan(a, b, 1))\n\t                    )\n\t                );\n\t        }\n\t    };\n\t\n\t    module.exports = number;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module echarts/core/BoundingRect\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(7);\n\t    var matrix = __webpack_require__(27);\n\t\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    /**\n\t     * @alias module:echarts/core/BoundingRect\n\t     */\n\t    function BoundingRect(x, y, width, height) {\n\t\n\t        if (width < 0) {\n\t            x = x + width;\n\t            width = -width;\n\t        }\n\t        if (height < 0) {\n\t            y = y + height;\n\t            height = -height;\n\t        }\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.x = x;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.y = y;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.width = width;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.height = height;\n\t    }\n\t\n\t    BoundingRect.prototype = {\n\t\n\t        constructor: BoundingRect,\n\t\n\t        /**\n\t         * @param {module:echarts/core/BoundingRect} other\n\t         */\n\t        union: function (other) {\n\t            var x = mathMin(other.x, this.x);\n\t            var y = mathMin(other.y, this.y);\n\t\n\t            this.width = mathMax(\n\t                    other.x + other.width,\n\t                    this.x + this.width\n\t                ) - x;\n\t            this.height = mathMax(\n\t                    other.y + other.height,\n\t                    this.y + this.height\n\t                ) - y;\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} m\n\t         * @methods\n\t         */\n\t        applyTransform: (function () {\n\t            var lt = [];\n\t            var rb = [];\n\t            var lb = [];\n\t            var rt = [];\n\t            return function (m) {\n\t                // In case usage like this\n\t                // el.getBoundingRect().applyTransform(el.transform)\n\t                // And element has no transform\n\t                if (!m) {\n\t                    return;\n\t                }\n\t                lt[0] = lb[0] = this.x;\n\t                lt[1] = rt[1] = this.y;\n\t                rb[0] = rt[0] = this.x + this.width;\n\t                rb[1] = lb[1] = this.y + this.height;\n\t\n\t                v2ApplyTransform(lt, lt, m);\n\t                v2ApplyTransform(rb, rb, m);\n\t                v2ApplyTransform(lb, lb, m);\n\t                v2ApplyTransform(rt, rt, m);\n\t\n\t                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n\t                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n\t                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n\t                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n\t                this.width = maxX - this.x;\n\t                this.height = maxY - this.y;\n\t            };\n\t        })(),\n\t\n\t        /**\n\t         * Calculate matrix of transforming from self to target rect\n\t         * @param  {module:zrender/core/BoundingRect} b\n\t         * @return {Array.<number>}\n\t         */\n\t        calculateTransform: function (b) {\n\t            var a = this;\n\t            var sx = b.width / a.width;\n\t            var sy = b.height / a.height;\n\t\n\t            var m = matrix.create();\n\t\n\t            // 矩阵右乘\n\t            matrix.translate(m, m, [-a.x, -a.y]);\n\t            matrix.scale(m, m, [sx, sy]);\n\t            matrix.translate(m, m, [b.x, b.y]);\n\t\n\t            return m;\n\t        },\n\t\n\t        /**\n\t         * @param {(module:echarts/core/BoundingRect|Object)} b\n\t         * @return {boolean}\n\t         */\n\t        intersect: function (b) {\n\t            if (!b) {\n\t                return false;\n\t            }\n\t\n\t            if (!(b instanceof BoundingRect)) {\n\t                // Normalize negative width/height.\n\t                b = BoundingRect.create(b);\n\t            }\n\t\n\t            var a = this;\n\t            var ax0 = a.x;\n\t            var ax1 = a.x + a.width;\n\t            var ay0 = a.y;\n\t            var ay1 = a.y + a.height;\n\t\n\t            var bx0 = b.x;\n\t            var bx1 = b.x + b.width;\n\t            var by0 = b.y;\n\t            var by1 = b.y + b.height;\n\t\n\t            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var rect = this;\n\t            return x >= rect.x\n\t                && x <= (rect.x + rect.width)\n\t                && y >= rect.y\n\t                && y <= (rect.y + rect.height);\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/core/BoundingRect}\n\t         */\n\t        clone: function () {\n\t            return new BoundingRect(this.x, this.y, this.width, this.height);\n\t        },\n\t\n\t        /**\n\t         * Copy from another rect\n\t         */\n\t        copy: function (other) {\n\t            this.x = other.x;\n\t            this.y = other.y;\n\t            this.width = other.width;\n\t            this.height = other.height;\n\t        },\n\t\n\t        plain: function () {\n\t            return {\n\t                x: this.x,\n\t                y: this.y,\n\t                width: this.width,\n\t                height: this.height\n\t            };\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {Object|module:zrender/core/BoundingRect} rect\n\t     * @param {number} rect.x\n\t     * @param {number} rect.y\n\t     * @param {number} rect.width\n\t     * @param {number} rect.height\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    BoundingRect.create = function (rect) {\n\t        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n\t    };\n\t\n\t    module.exports = BoundingRect;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t/**\n\t * echarts设备环境识别\n\t *\n\t * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n\t * @author firede[firede@firede.us]\n\t * @desc thanks zepto.\n\t */\n\t\n\t    var env = {};\n\t    if (typeof navigator === 'undefined') {\n\t        // In node\n\t        env = {\n\t            browser: {},\n\t            os: {},\n\t            node: true,\n\t            // Assume canvas is supported\n\t            canvasSupported: true\n\t        };\n\t    }\n\t    else {\n\t        env = detect(navigator.userAgent);\n\t    }\n\t\n\t    module.exports = env;\n\t\n\t    // Zepto.js\n\t    // (c) 2010-2013 Thomas Fuchs\n\t    // Zepto.js may be freely distributed under the MIT license.\n\t\n\t    function detect(ua) {\n\t        var os = {};\n\t        var browser = {};\n\t        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t        // var touchpad = webos && ua.match(/TouchPad/);\n\t        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t        // var playbook = ua.match(/PlayBook/);\n\t        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n\t        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n\t            // IE 11 Trident/7.0; rv:11.0\n\t            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\t\n\t        var weChat = (/micromessenger/i).test(ua);\n\t\n\t        // Todo: clean this up with a better OS/browser seperation:\n\t        // - discern (more) between multiple browsers on android\n\t        // - decide if kindle fire in silk mode is android or not\n\t        // - Firefox on Android doesn't specify the Android version\n\t        // - possibly devide in os, device and browser hashes\n\t\n\t        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t\n\t        // if (android) os.android = true, os.version = android[2];\n\t        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t        // if (webos) os.webos = true, os.version = webos[2];\n\t        // if (touchpad) os.touchpad = true;\n\t        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t        // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t        // if (playbook) browser.playbook = true;\n\t        // if (kindle) os.kindle = true, os.version = kindle[1];\n\t        // if (silk) browser.silk = true, browser.version = silk[1];\n\t        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t        if (firefox) {\n\t            browser.firefox = true;\n\t            browser.version = firefox[1];\n\t        }\n\t        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t        // if (webview) browser.webview = true;\n\t\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t\n\t        if (edge) {\n\t            browser.edge = true;\n\t            browser.version = edge[1];\n\t        }\n\t\n\t        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n\t        // not be set on win phone. So we do not consider Win Phone.\n\t        if (weChat) {\n\t            browser.weChat = true;\n\t        }\n\t\n\t        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t\n\t        return {\n\t            browser: browser,\n\t            os: os,\n\t            node: false,\n\t            // 原生canvas支持，改极端点了\n\t            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n\t            canvasSupported : document.createElement('canvas').getContext ? true : false,\n\t            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n\t            // works on most browsers\n\t            // IE10/11 does not support touch event, and MS Edge supports them but not by\n\t            // default, so we dont check navigator.maxTouchPoints for them here.\n\t            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t            // <http://caniuse.com/#search=pointer%20event>.\n\t            pointerEventsSupported: 'onpointerdown' in window\n\t                // Firefox supports pointer but not by default,\n\t                // only MS browsers are reliable on pointer events currently.\n\t                && (browser.edge || (browser.ie && browser.version >= 10))\n\t        };\n\t    }\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/model/Model\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var clazzUtil = __webpack_require__(21);\n\t\n\t    /**\n\t     * @alias module:echarts/model/Model\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} [parentModel]\n\t     * @param {module:echarts/model/Global} [ecModel]\n\t     */\n\t    function Model(option, parentModel, ecModel) {\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         * @readOnly\n\t         */\n\t        this.parentModel = parentModel;\n\t\n\t        /**\n\t         * @type {module:echarts/model/Global}\n\t         * @readOnly\n\t         */\n\t        this.ecModel = ecModel;\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        this.option = option;\n\t\n\t        // Simple optimization\n\t        // if (this.init) {\n\t        //     if (arguments.length <= 4) {\n\t        //         this.init(option, parentModel, ecModel, extraOpt);\n\t        //     }\n\t        //     else {\n\t        //         this.init.apply(this, arguments);\n\t        //     }\n\t        // }\n\t    }\n\t\n\t    Model.prototype = {\n\t\n\t        constructor: Model,\n\t\n\t        /**\n\t         * Model 的初始化函数\n\t         * @param {Object} option\n\t         */\n\t        init: null,\n\t\n\t        /**\n\t         * 从新的 Option merge\n\t         */\n\t        mergeOption: function (option) {\n\t            zrUtil.merge(this.option, option, true);\n\t        },\n\t\n\t        /**\n\t         * @param {string} path\n\t         * @param {boolean} [ignoreParent=false]\n\t         * @return {*}\n\t         */\n\t        get: function (path, ignoreParent) {\n\t            if (!path) {\n\t                return this.option;\n\t            }\n\t\n\t            if (typeof path === 'string') {\n\t                path = path.split('.');\n\t            }\n\t\n\t            var obj = this.option;\n\t            var parentModel = this.parentModel;\n\t            for (var i = 0; i < path.length; i++) {\n\t                // Ignore empty\n\t                if (!path[i]) {\n\t                    continue;\n\t                }\n\t                // obj could be number/string/... (like 0)\n\t                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\n\t                if (obj == null) {\n\t                    break;\n\t                }\n\t            }\n\t            if (obj == null && parentModel && !ignoreParent) {\n\t                obj = parentModel.get(path);\n\t            }\n\t            return obj;\n\t        },\n\t\n\t        /**\n\t         * @param {string} key\n\t         * @param {boolean} [ignoreParent=false]\n\t         * @return {*}\n\t         */\n\t        getShallow: function (key, ignoreParent) {\n\t            var option = this.option;\n\t\n\t            var val = option == null ? option : option[key];\n\t            var parentModel = this.parentModel;\n\t            if (val == null && parentModel && !ignoreParent) {\n\t                val = parentModel.getShallow(key);\n\t            }\n\t            return val;\n\t        },\n\t\n\t        /**\n\t         * @param {string} path\n\t         * @param {module:echarts/model/Model} [parentModel]\n\t         * @return {module:echarts/model/Model}\n\t         */\n\t        getModel: function (path, parentModel) {\n\t            var obj = this.get(path, true);\n\t            var thisParentModel = this.parentModel;\n\t            var model = new Model(\n\t                obj, parentModel || (thisParentModel && thisParentModel.getModel(path)),\n\t                this.ecModel\n\t            );\n\t            return model;\n\t        },\n\t\n\t        /**\n\t         * If model has option\n\t         */\n\t        isEmpty: function () {\n\t            return this.option == null;\n\t        },\n\t\n\t        restoreData: function () {},\n\t\n\t        // Pending\n\t        clone: function () {\n\t            var Ctor = this.constructor;\n\t            return new Ctor(zrUtil.clone(this.option));\n\t        },\n\t\n\t        setReadOnly: function (properties) {\n\t            clazzUtil.setReadOnly(this, properties);\n\t        }\n\t    };\n\t\n\t    // Enable Model.extend.\n\t    clazzUtil.enableClassExtend(Model);\n\t\n\t    var mixin = zrUtil.mixin;\n\t    mixin(Model, __webpack_require__(129));\n\t    mixin(Model, __webpack_require__(126));\n\t    mixin(Model, __webpack_require__(130));\n\t    mixin(Model, __webpack_require__(128));\n\t\n\t    module.exports = Model;\n\n\n/***/ },\n/* 16 */,\n/* 17 */,\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Component model\n\t *\n\t * @module echarts/model/Component\n\t */\n\t\n\t\n\t    var Model = __webpack_require__(15);\n\t    var zrUtil = __webpack_require__(1);\n\t    var arrayPush = Array.prototype.push;\n\t    var componentUtil = __webpack_require__(48);\n\t    var clazzUtil = __webpack_require__(21);\n\t    var layout = __webpack_require__(25);\n\t\n\t    /**\n\t     * @alias module:echarts/model/Component\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {module:echarts/model/Model} ecModel\n\t     */\n\t    var ComponentModel = Model.extend({\n\t\n\t        type: 'component',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {string}\n\t         */\n\t        id: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        name: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {string}\n\t         */\n\t        mainType: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {string}\n\t         */\n\t        subType: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {number}\n\t         */\n\t        componentIndex: 0,\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        defaultOption: null,\n\t\n\t        /**\n\t         * @type {module:echarts/model/Global}\n\t         * @readOnly\n\t         */\n\t        ecModel: null,\n\t\n\t        /**\n\t         * key: componentType\n\t         * value:  Component model list, can not be null.\n\t         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n\t         * @readOnly\n\t         */\n\t        dependentModels: [],\n\t\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        uid: null,\n\t\n\t        /**\n\t         * Support merge layout params.\n\t         * Only support 'box' now (left/right/top/bottom/width/height).\n\t         * @type {string|Object} Object can be {ignoreSize: true}\n\t         * @readOnly\n\t         */\n\t        layoutMode: null,\n\t\n\t        $constructor: function (option, parentModel, ecModel, extraOpt) {\n\t            Model.call(this, option, parentModel, ecModel, extraOpt);\n\t\n\t            this.uid = componentUtil.getUID('componentModel');\n\t        },\n\t\n\t\n\t        init: function (option, parentModel, ecModel, extraOpt) {\n\t            this.mergeDefaultAndTheme(option, ecModel);\n\t        },\n\t\n\t        mergeDefaultAndTheme: function (option, ecModel) {\n\t            var layoutMode = this.layoutMode;\n\t            var inputPositionParams = layoutMode\n\t                ? layout.getLayoutParams(option) : {};\n\t\n\t            var themeModel = ecModel.getTheme();\n\t            zrUtil.merge(option, themeModel.get(this.mainType));\n\t            zrUtil.merge(option, this.getDefaultOption());\n\t\n\t            if (layoutMode) {\n\t                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t            }\n\t        },\n\t\n\t        mergeOption: function (option, extraOpt) {\n\t            zrUtil.merge(this.option, option, true);\n\t\n\t            var layoutMode = this.layoutMode;\n\t            if (layoutMode) {\n\t                layout.mergeLayoutParam(this.option, option, layoutMode);\n\t            }\n\t        },\n\t\n\t        // Hooker after init or mergeOption\n\t        optionUpdated: function (newCptOption, isInit) {},\n\t\n\t        getDefaultOption: function () {\n\t            if (!this.hasOwnProperty('__defaultOption')) {\n\t                var optList = [];\n\t                var Class = this.constructor;\n\t                while (Class) {\n\t                    var opt = Class.prototype.defaultOption;\n\t                    opt && optList.push(opt);\n\t                    Class = Class.superClass;\n\t                }\n\t\n\t                var defaultOption = {};\n\t                for (var i = optList.length - 1; i >= 0; i--) {\n\t                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n\t                }\n\t                this.__defaultOption = defaultOption;\n\t            }\n\t            return this.__defaultOption;\n\t        },\n\t\n\t        getReferringComponents: function (mainType) {\n\t            return this.ecModel.queryComponents({\n\t                mainType: mainType,\n\t                index: this.get(mainType + 'Index', true),\n\t                id: this.get(mainType + 'Id', true)\n\t            });\n\t        }\n\t\n\t    });\n\t\n\t    // Reset ComponentModel.extend, add preConstruct.\n\t    // clazzUtil.enableClassExtend(\n\t    //     ComponentModel,\n\t    //     function (option, parentModel, ecModel, extraOpt) {\n\t    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n\t    //         zrUtil.extend(this, extraOpt);\n\t\n\t    //         this.uid = componentUtil.getUID('componentModel');\n\t\n\t    //         // this.setReadOnly([\n\t    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n\t    //         //     'dependentModels', 'componentIndex'\n\t    //         // ]);\n\t    //     }\n\t    // );\n\t\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(\n\t        ComponentModel, {registerWhenExtend: true}\n\t    );\n\t    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\t\n\t    // Add capability of ComponentModel.topologicalTravel.\n\t    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\t\n\t    function getDependencies(componentType) {\n\t        var deps = [];\n\t        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n\t            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n\t        });\n\t        // Ensure main type\n\t        return zrUtil.map(deps, function (type) {\n\t            return clazzUtil.parseClassType(type).main;\n\t        });\n\t    }\n\t\n\t    zrUtil.mixin(ComponentModel, __webpack_require__(127));\n\t\n\t    module.exports = ComponentModel;\n\n\n/***/ },\n/* 19 */,\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 曲线辅助模块\n\t * @module zrender/core/curve\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(7);\n\t    var v2Create = vec2.create;\n\t    var v2DistSquare = vec2.distSquare;\n\t    var mathPow = Math.pow;\n\t    var mathSqrt = Math.sqrt;\n\t\n\t    var EPSILON = 1e-8;\n\t    var EPSILON_NUMERIC = 1e-4;\n\t\n\t    var THREE_SQRT = mathSqrt(3);\n\t    var ONE_THIRD = 1 / 3;\n\t\n\t    // 临时变量\n\t    var _v0 = v2Create();\n\t    var _v1 = v2Create();\n\t    var _v2 = v2Create();\n\t    // var _v3 = vec2.create();\n\t\n\t    function isAroundZero(val) {\n\t        return val > -EPSILON && val < EPSILON;\n\t    }\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * 计算三次贝塞尔值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return onet * onet * (onet * p0 + 3 * t * p1)\n\t             + t * t * (t * p3 + 3 * onet * p2);\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔导数值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return 3 * (\n\t            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n\t            + (p3 - p2) * t * t\n\t        );\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔方程根，使用盛金公式\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} val\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t        // Evaluate roots of cubic functions\n\t        var a = p3 + 3 * (p1 - p2) - p0;\n\t        var b = 3 * (p2 - p1 * 2 + p0);\n\t        var c = 3 * (p1  - p0);\n\t        var d = p0 - val;\n\t\n\t        var A = b * b - 3 * a * c;\n\t        var B = b * c - 9 * a * d;\n\t        var C = c * c - 3 * b * d;\n\t\n\t        var n = 0;\n\t\n\t        if (isAroundZero(A) && isAroundZero(B)) {\n\t            if (isAroundZero(b)) {\n\t                roots[0] = 0;\n\t            }\n\t            else {\n\t                var t1 = -c / b;  //t1, t2, t3, b is not zero\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = B * B - 4 * A * C;\n\t\n\t            if (isAroundZero(disc)) {\n\t                var K = B / A;\n\t                var t1 = -b / a + K;  // t1, a is not zero\n\t                var t2 = -K / 2;  // t2, t3\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t                if (Y1 < 0) {\n\t                    Y1 = -mathPow(-Y1, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y1 = mathPow(Y1, ONE_THIRD);\n\t                }\n\t                if (Y2 < 0) {\n\t                    Y2 = -mathPow(-Y2, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y2 = mathPow(Y2, ONE_THIRD);\n\t                }\n\t                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else {\n\t                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t                var theta = Math.acos(T) / 3;\n\t                var ASqrt = mathSqrt(A);\n\t                var tmp = Math.cos(theta);\n\t\n\t                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t                if (t3 >= 0 && t3 <= 1) {\n\t                    roots[n++] = t3;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔方程极限值的位置\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {Array.<number>} extrema\n\t     * @return {number} 有效数目\n\t     */\n\t    function cubicExtrema(p0, p1, p2, p3, extrema) {\n\t        var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t        var c = 3 * p1 - 3 * p0;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <=1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                extrema[0] = -b / (2 * a);\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    extrema[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 细分三次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p23 = (p3 - p2) * t + p2;\n\t\n\t        var p012 = (p12 - p01) * t + p01;\n\t        var p123 = (p23 - p12) * t + p12;\n\t\n\t        var p0123 = (p123 - p012) * t + p012;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        out[3] = p0123;\n\t        // Seg1\n\t        out[4] = p0123;\n\t        out[5] = p123;\n\t        out[6] = p23;\n\t        out[7] = p3;\n\t    }\n\t\n\t    /**\n\t     * 投射点到三次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} [out] 投射点\n\t     * @return {number}\n\t     */\n\t    function cubicProjectPoint(\n\t        x0, y0, x1, y1, x2, y2, x3, y3,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        var prev;\n\t        var next;\n\t        var d1;\n\t        var d2;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t            d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            prev = t - interval;\n\t            next = t + interval;\n\t            // t - interval\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t\n\t            d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t                d2 = v2DistSquare(_v2, _v0);\n\t\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = cubicAt(x0, x1, x2, x3, t);\n\t            out[1] = cubicAt(y0, y1, y2, y3, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticAt(p0, p1, p2, t) {\n\t        var onet = 1 - t;\n\t        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔导数值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticDerivativeAt(p0, p1, p2, t) {\n\t        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔方程根\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function quadraticRootAt(p0, p1, p2, val, roots) {\n\t        var a = p0 - 2 * p1 + p2;\n\t        var b = 2 * (p1 - p0);\n\t        var c = p0 - val;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                var t1 = -b / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 计算二次贝塞尔方程极限值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @return {number}\n\t     */\n\t    function quadraticExtremum(p0, p1, p2) {\n\t        var divider = p0 + p2 - 2 * p1;\n\t        if (divider === 0) {\n\t            // p1 is center of p0 and p2\n\t            return 0.5;\n\t        }\n\t        else {\n\t            return (p0 - p1) / divider;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 细分二次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function quadraticSubdivide(p0, p1, p2, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p012 = (p12 - p01) * t + p01;\n\t\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t\n\t        // Seg1\n\t        out[3] = p012;\n\t        out[4] = p12;\n\t        out[5] = p2;\n\t    }\n\t\n\t    /**\n\t     * 投射点到二次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} out 投射点\n\t     * @return {number}\n\t     */\n\t    function quadraticProjectPoint(\n\t        x0, y0, x1, y1, x2, y2,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t            _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t            var d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            var prev = t - interval;\n\t            var next = t + interval;\n\t            // t - interval\n\t            _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t\n\t            var d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = quadraticAt(x0, x1, x2, next);\n\t                _v2[1] = quadraticAt(y0, y1, y2, next);\n\t                var d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = quadraticAt(x0, x1, x2, t);\n\t            out[1] = quadraticAt(y0, y1, y2, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        cubicAt: cubicAt,\n\t\n\t        cubicDerivativeAt: cubicDerivativeAt,\n\t\n\t        cubicRootAt: cubicRootAt,\n\t\n\t        cubicExtrema: cubicExtrema,\n\t\n\t        cubicSubdivide: cubicSubdivide,\n\t\n\t        cubicProjectPoint: cubicProjectPoint,\n\t\n\t        quadraticAt: quadraticAt,\n\t\n\t        quadraticDerivativeAt: quadraticDerivativeAt,\n\t\n\t        quadraticRootAt: quadraticRootAt,\n\t\n\t        quadraticExtremum: quadraticExtremum,\n\t\n\t        quadraticSubdivide: quadraticSubdivide,\n\t\n\t        quadraticProjectPoint: quadraticProjectPoint\n\t    };\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var clazz = {};\n\t\n\t    var TYPE_DELIMITER = '.';\n\t    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n\t    /**\n\t     * @public\n\t     */\n\t    var parseClassType = clazz.parseClassType = function (componentType) {\n\t        var ret = {main: '', sub: ''};\n\t        if (componentType) {\n\t            componentType = componentType.split(TYPE_DELIMITER);\n\t            ret.main = componentType[0] || '';\n\t            ret.sub = componentType[1] || '';\n\t        }\n\t        return ret;\n\t    };\n\t    /**\n\t     * @public\n\t     */\n\t    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\t\n\t        RootClass.$constructor = RootClass;\n\t        RootClass.extend = function (proto) {\n\t\n\t            if (__DEV__) {\n\t                zrUtil.each(mandatoryMethods, function (method) {\n\t                    if (!proto[method]) {\n\t                        console.warn(\n\t                            'Method `' + method + '` should be implemented'\n\t                            + (proto.type ? ' in ' + proto.type : '') + '.'\n\t                        );\n\t                    }\n\t                });\n\t            }\n\t\n\t            var superClass = this;\n\t            var ExtendedClass = function () {\n\t                if (!proto.$constructor) {\n\t                    superClass.apply(this, arguments);\n\t                }\n\t                else {\n\t                    proto.$constructor.apply(this, arguments);\n\t                }\n\t            };\n\t\n\t            zrUtil.extend(ExtendedClass.prototype, proto);\n\t\n\t            ExtendedClass.extend = this.extend;\n\t            ExtendedClass.superCall = superCall;\n\t            ExtendedClass.superApply = superApply;\n\t            zrUtil.inherits(ExtendedClass, this);\n\t            ExtendedClass.superClass = superClass;\n\t\n\t            return ExtendedClass;\n\t        };\n\t    };\n\t\n\t    // superCall should have class info, which can not be fetch from 'this'.\n\t    // Consider this case:\n\t    // class A has method f,\n\t    // class B inherits class A, overrides method f, f call superApply('f'),\n\t    // class C inherits class B, do not overrides method f,\n\t    // then when method of class C is called, dead loop occured.\n\t    function superCall(context, methodName) {\n\t        var args = zrUtil.slice(arguments, 2);\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t\n\t    function superApply(context, methodName, args) {\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t\n\t    /**\n\t     * @param {Object} entity\n\t     * @param {Object} options\n\t     * @param {boolean} [options.registerWhenExtend]\n\t     * @public\n\t     */\n\t    clazz.enableClassManagement = function (entity, options) {\n\t        options = options || {};\n\t\n\t        /**\n\t         * Component model classes\n\t         * key: componentType,\n\t         * value:\n\t         *     componentClass, when componentType is 'xxx'\n\t         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n\t         * @type {Object}\n\t         */\n\t        var storage = {};\n\t\n\t        entity.registerClass = function (Clazz, componentType) {\n\t            if (componentType) {\n\t                componentType = parseClassType(componentType);\n\t\n\t                if (!componentType.sub) {\n\t                    if (__DEV__) {\n\t                        if (storage[componentType.main]) {\n\t                            console.warn(componentType.main + ' exists.');\n\t                        }\n\t                    }\n\t                    storage[componentType.main] = Clazz;\n\t                }\n\t                else if (componentType.sub !== IS_CONTAINER) {\n\t                    var container = makeContainer(componentType);\n\t                    container[componentType.sub] = Clazz;\n\t                }\n\t            }\n\t            return Clazz;\n\t        };\n\t\n\t        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\n\t            var Clazz = storage[componentTypeMain];\n\t\n\t            if (Clazz && Clazz[IS_CONTAINER]) {\n\t                Clazz = subType ? Clazz[subType] : null;\n\t            }\n\t\n\t            if (throwWhenNotFound && !Clazz) {\n\t                throw new Error(\n\t                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\n\t                );\n\t            }\n\t\n\t            return Clazz;\n\t        };\n\t\n\t        entity.getClassesByMainType = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t\n\t            var result = [];\n\t            var obj = storage[componentType.main];\n\t\n\t            if (obj && obj[IS_CONTAINER]) {\n\t                zrUtil.each(obj, function (o, type) {\n\t                    type !== IS_CONTAINER && result.push(o);\n\t                });\n\t            }\n\t            else {\n\t                result.push(obj);\n\t            }\n\t\n\t            return result;\n\t        };\n\t\n\t        entity.hasClass = function (componentType) {\n\t            // Just consider componentType.main.\n\t            componentType = parseClassType(componentType);\n\t            return !!storage[componentType.main];\n\t        };\n\t\n\t        /**\n\t         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n\t         */\n\t        entity.getAllClassMainTypes = function () {\n\t            var types = [];\n\t            zrUtil.each(storage, function (obj, type) {\n\t                types.push(type);\n\t            });\n\t            return types;\n\t        };\n\t\n\t        /**\n\t         * If a main type is container and has sub types\n\t         * @param  {string}  mainType\n\t         * @return {boolean}\n\t         */\n\t        entity.hasSubTypes = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t            var obj = storage[componentType.main];\n\t            return obj && obj[IS_CONTAINER];\n\t        };\n\t\n\t        entity.parseClassType = parseClassType;\n\t\n\t        function makeContainer(componentType) {\n\t            var container = storage[componentType.main];\n\t            if (!container || !container[IS_CONTAINER]) {\n\t                container = storage[componentType.main] = {};\n\t                container[IS_CONTAINER] = true;\n\t            }\n\t            return container;\n\t        }\n\t\n\t        if (options.registerWhenExtend) {\n\t            var originalExtend = entity.extend;\n\t            if (originalExtend) {\n\t                entity.extend = function (proto) {\n\t                    var ExtendedClass = originalExtend.call(this, proto);\n\t                    return entity.registerClass(ExtendedClass, proto.type);\n\t                };\n\t            }\n\t        }\n\t\n\t        return entity;\n\t    };\n\t\n\t    /**\n\t     * @param {string|Array.<string>} properties\n\t     */\n\t    clazz.setReadOnly = function (obj, properties) {\n\t        // FIXME It seems broken in IE8 simulation of IE11\n\t        // if (!zrUtil.isArray(properties)) {\n\t        //     properties = properties != null ? [properties] : [];\n\t        // }\n\t        // zrUtil.each(properties, function (prop) {\n\t        //     var value = obj[prop];\n\t\n\t        //     Object.defineProperty\n\t        //         && Object.defineProperty(obj, prop, {\n\t        //             value: value, writable: false\n\t        //         });\n\t        //     zrUtil.isArray(obj[prop])\n\t        //         && Object.freeze\n\t        //         && Object.freeze(obj[prop]);\n\t        // });\n\t    };\n\t\n\t    module.exports = clazz;\n\n\n/***/ },\n/* 22 */,\n/* 23 */,\n/* 24 */,\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Layout helpers for each component positioning\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var BoundingRect = __webpack_require__(13);\n\t    var numberUtil = __webpack_require__(12);\n\t    var formatUtil = __webpack_require__(9);\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var each = zrUtil.each;\n\t\n\t    var layout = {};\n\t\n\t    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n\t        'left', 'right', 'top', 'bottom', 'width', 'height'\n\t    ];\n\t\n\t    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n\t        var x = 0;\n\t        var y = 0;\n\t        if (maxWidth == null) {\n\t            maxWidth = Infinity;\n\t        }\n\t        if (maxHeight == null) {\n\t            maxHeight = Infinity;\n\t        }\n\t        var currentLineMaxSize = 0;\n\t        group.eachChild(function (child, idx) {\n\t            var position = child.position;\n\t            var rect = child.getBoundingRect();\n\t            var nextChild = group.childAt(idx + 1);\n\t            var nextChildRect = nextChild && nextChild.getBoundingRect();\n\t            var nextX;\n\t            var nextY;\n\t            if (orient === 'horizontal') {\n\t                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n\t                nextX = x + moveX;\n\t                // Wrap when width exceeds maxWidth or meet a `newline` group\n\t                if (nextX > maxWidth || child.newline) {\n\t                    x = 0;\n\t                    nextX = moveX;\n\t                    y += currentLineMaxSize + gap;\n\t                    currentLineMaxSize = rect.height;\n\t                }\n\t                else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n\t                }\n\t            }\n\t            else {\n\t                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n\t                nextY = y + moveY;\n\t                // Wrap when width exceeds maxHeight or meet a `newline` group\n\t                if (nextY > maxHeight || child.newline) {\n\t                    x += currentLineMaxSize + gap;\n\t                    y = 0;\n\t                    nextY = moveY;\n\t                    currentLineMaxSize = rect.width;\n\t                }\n\t                else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n\t                }\n\t            }\n\t\n\t            if (child.newline) {\n\t                return;\n\t            }\n\t\n\t            position[0] = x;\n\t            position[1] = y;\n\t\n\t            orient === 'horizontal'\n\t                ? (x = nextX + gap)\n\t                : (y = nextY + gap);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * VBox or HBox layouting\n\t     * @param {string} orient\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.box = boxLayout;\n\t\n\t    /**\n\t     * VBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\t\n\t    /**\n\t     * HBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\t\n\t    /**\n\t     * If x or x2 is not specified or 'center' 'left' 'right',\n\t     * the width would be as long as possible.\n\t     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n\t     * the height would be as long as possible.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.x]\n\t     * @param {number|string} [positionInfo.y]\n\t     * @param {number|string} [positionInfo.x2]\n\t     * @param {number|string} [positionInfo.y2]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     * @return {Object} {width, height}\n\t     */\n\t    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t\n\t        var x = parsePercent(positionInfo.x, containerWidth);\n\t        var y = parsePercent(positionInfo.y, containerHeight);\n\t        var x2 = parsePercent(positionInfo.x2, containerWidth);\n\t        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\t\n\t        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n\t        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n\t        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n\t        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\t\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t\n\t        return {\n\t            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n\t            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Parse position info.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {number|string} [positionInfo.width]\n\t     * @param {number|string} [positionInfo.height]\n\t     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n\t     * @param {Object} containerRect\n\t     * @param {string|number} [margin]\n\t     *\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    layout.getLayoutRect = function (\n\t        positionInfo, containerRect, margin\n\t    ) {\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t\n\t        var left = parsePercent(positionInfo.left, containerWidth);\n\t        var top = parsePercent(positionInfo.top, containerHeight);\n\t        var right = parsePercent(positionInfo.right, containerWidth);\n\t        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n\t        var width = parsePercent(positionInfo.width, containerWidth);\n\t        var height = parsePercent(positionInfo.height, containerHeight);\n\t\n\t        var verticalMargin = margin[2] + margin[0];\n\t        var horizontalMargin = margin[1] + margin[3];\n\t        var aspect = positionInfo.aspect;\n\t\n\t        // If width is not specified, calculate width from left and right\n\t        if (isNaN(width)) {\n\t            width = containerWidth - right - horizontalMargin - left;\n\t        }\n\t        if (isNaN(height)) {\n\t            height = containerHeight - bottom - verticalMargin - top;\n\t        }\n\t\n\t        // If width and height are not given\n\t        // 1. Graph should not exceeds the container\n\t        // 2. Aspect must be keeped\n\t        // 3. Graph should take the space as more as possible\n\t        if (isNaN(width) && isNaN(height)) {\n\t            if (aspect > containerWidth / containerHeight) {\n\t                width = containerWidth * 0.8;\n\t            }\n\t            else {\n\t                height = containerHeight * 0.8;\n\t            }\n\t        }\n\t\n\t        if (aspect != null) {\n\t            // Calculate width or height with given aspect\n\t            if (isNaN(width)) {\n\t                width = aspect * height;\n\t            }\n\t            if (isNaN(height)) {\n\t                height = width / aspect;\n\t            }\n\t        }\n\t\n\t        // If left is not specified, calculate left from right and width\n\t        if (isNaN(left)) {\n\t            left = containerWidth - right - width - horizontalMargin;\n\t        }\n\t        if (isNaN(top)) {\n\t            top = containerHeight - bottom - height - verticalMargin;\n\t        }\n\t\n\t        // Align left and top\n\t        switch (positionInfo.left || positionInfo.right) {\n\t            case 'center':\n\t                left = containerWidth / 2 - width / 2 - margin[3];\n\t                break;\n\t            case 'right':\n\t                left = containerWidth - width - horizontalMargin;\n\t                break;\n\t        }\n\t        switch (positionInfo.top || positionInfo.bottom) {\n\t            case 'middle':\n\t            case 'center':\n\t                top = containerHeight / 2 - height / 2 - margin[0];\n\t                break;\n\t            case 'bottom':\n\t                top = containerHeight - height - verticalMargin;\n\t                break;\n\t        }\n\t        // If something is wrong and left, top, width, height are calculated as NaN\n\t        left = left || 0;\n\t        top = top || 0;\n\t        if (isNaN(width)) {\n\t            // Width may be NaN if only one value is given except width\n\t            width = containerWidth - left - (right || 0);\n\t        }\n\t        if (isNaN(height)) {\n\t            // Height may be NaN if only one value is given except height\n\t            height = containerHeight - top - (bottom || 0);\n\t        }\n\t\n\t        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n\t        rect.margin = margin;\n\t        return rect;\n\t    };\n\t\n\t\n\t    /**\n\t     * Position a zr element in viewport\n\t     *  Group position is specified by either\n\t     *  {left, top}, {right, bottom}\n\t     *  If all properties exists, right and bottom will be igonred.\n\t     *\n\t     * Logic:\n\t     *     1. Scale (against origin point in parent coord)\n\t     *     2. Rotate (against origin point in parent coord)\n\t     *     3. Traslate (with el.position by this method)\n\t     * So this method only fixes the last step 'Traslate', which does not affect\n\t     * scaling and rotating.\n\t     *\n\t     * If be called repeatly with the same input el, the same result will be gotten.\n\t     *\n\t     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     * @param {Object} [opt]\n\t     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n\t     * @param {Array.<number>} [opt.boundingMode='all']\n\t     *        Specify how to calculate boundingRect when locating.\n\t     *        'all': Position the boundingRect that is transformed and uioned\n\t     *               both itself and its descendants.\n\t     *               This mode simplies confine the elements in the bounding\n\t     *               of their container (e.g., using 'right: 0').\n\t     *        'raw': Position the boundingRect that is not transformed and only itself.\n\t     *               This mode is useful when you want a element can overflow its\n\t     *               container. (Consider a rotated circle needs to be located in a corner.)\n\t     *               In this mode positionInfo.width/height can only be number.\n\t     */\n\t    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n\t        var h = !opt || !opt.hv || opt.hv[0];\n\t        var v = !opt || !opt.hv || opt.hv[1];\n\t        var boundingMode = opt && opt.boundingMode || 'all';\n\t\n\t        if (!h && !v) {\n\t            return;\n\t        }\n\t\n\t        var rect;\n\t        if (boundingMode === 'raw') {\n\t            rect = el.type === 'group'\n\t                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n\t                : el.getBoundingRect();\n\t        }\n\t        else {\n\t            rect = el.getBoundingRect();\n\t            if (el.needLocalTransform()) {\n\t                var transform = el.getLocalTransform();\n\t                // Notice: raw rect may be inner object of el,\n\t                // which should not be modified.\n\t                rect = rect.clone();\n\t                rect.applyTransform(transform);\n\t            }\n\t        }\n\t\n\t        positionInfo = layout.getLayoutRect(\n\t            zrUtil.defaults(\n\t                {width: rect.width, height: rect.height},\n\t                positionInfo\n\t            ),\n\t            containerRect,\n\t            margin\n\t        );\n\t\n\t        // Because 'tranlate' is the last step in transform\n\t        // (see zrender/core/Transformable#getLocalTransfrom),\n\t        // we can just only modify el.position to get final result.\n\t        var elPos = el.position;\n\t        var dx = h ? positionInfo.x - rect.x : 0;\n\t        var dy = v ? positionInfo.y - rect.y : 0;\n\t\n\t        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n\t    };\n\t\n\t    /**\n\t     * Consider Case:\n\t     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n\t     * through setOption or media query, using normal zrUtil.merge will cause\n\t     * {right: 0} does not take effect.\n\t     *\n\t     * @example\n\t     * ComponentModel.extend({\n\t     *     init: function () {\n\t     *         ...\n\t     *         var inputPositionParams = layout.getLayoutParams(option);\n\t     *         this.mergeOption(inputPositionParams);\n\t     *     },\n\t     *     mergeOption: function (newOption) {\n\t     *         newOption && zrUtil.merge(thisOption, newOption, true);\n\t     *         layout.mergeLayoutParam(thisOption, newOption);\n\t     *     }\n\t     * });\n\t     *\n\t     * @param {Object} targetOption\n\t     * @param {Object} newOption\n\t     * @param {Object|string} [opt]\n\t     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n\t     */\n\t    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n\t        !zrUtil.isObject(opt) && (opt = {});\n\t        var hNames = ['width', 'left', 'right']; // Order by priority.\n\t        var vNames = ['height', 'top', 'bottom']; // Order by priority.\n\t        var hResult = merge(hNames);\n\t        var vResult = merge(vNames);\n\t\n\t        copy(hNames, targetOption, hResult);\n\t        copy(vNames, targetOption, vResult);\n\t\n\t        function merge(names) {\n\t            var newParams = {};\n\t            var newValueCount = 0;\n\t            var merged = {};\n\t            var mergedValueCount = 0;\n\t            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n\t\n\t            each(names, function (name) {\n\t                merged[name] = targetOption[name];\n\t            });\n\t            each(names, function (name) {\n\t                // Consider case: newOption.width is null, which is\n\t                // set by user for removing width setting.\n\t                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n\t                hasValue(newParams, name) && newValueCount++;\n\t                hasValue(merged, name) && mergedValueCount++;\n\t            });\n\t\n\t            // Case: newOption: {width: ..., right: ...},\n\t            // or targetOption: {right: ...} and newOption: {width: ...},\n\t            // There is no conflict when merged only has params count\n\t            // little than enoughParamNumber.\n\t            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n\t                return merged;\n\t            }\n\t            // Case: newOption: {width: ..., right: ...},\n\t            // Than we can make sure user only want those two, and ignore\n\t            // all origin params in targetOption.\n\t            else if (newValueCount >= enoughParamNumber) {\n\t                return newParams;\n\t            }\n\t            else {\n\t                // Chose another param from targetOption by priority.\n\t                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n\t                for (var i = 0; i < names.length; i++) {\n\t                    var name = names[i];\n\t                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n\t                        newParams[name] = targetOption[name];\n\t                        break;\n\t                    }\n\t                }\n\t                return newParams;\n\t            }\n\t        }\n\t\n\t        function hasProp(obj, name) {\n\t            return obj.hasOwnProperty(name);\n\t        }\n\t\n\t        function hasValue(obj, name) {\n\t            return obj[name] != null && obj[name] !== 'auto';\n\t        }\n\t\n\t        function copy(names, target, source) {\n\t            each(names, function (name) {\n\t                target[name] = source[name];\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.getLayoutParams = function (source) {\n\t        return layout.copyLayoutParams({}, source);\n\t    };\n\t\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.copyLayoutParams = function (target, source) {\n\t        source && target && each(LOCATION_PARAMS, function (name) {\n\t            source.hasOwnProperty(name) && (target[name] = source[name]);\n\t        });\n\t        return target;\n\t    };\n\t\n\t    module.exports = layout;\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var textWidthCache = {};\n\t    var textWidthCacheCounter = 0;\n\t    var TEXT_CACHE_MAX = 5000;\n\t\n\t    var util = __webpack_require__(1);\n\t    var BoundingRect = __webpack_require__(13);\n\t    var retrieve = util.retrieve;\n\t\n\t    function getTextWidth(text, textFont) {\n\t        var key = text + ':' + textFont;\n\t        if (textWidthCache[key]) {\n\t            return textWidthCache[key];\n\t        }\n\t\n\t        var textLines = (text + '').split('\\n');\n\t        var width = 0;\n\t\n\t        for (var i = 0, l = textLines.length; i < l; i++) {\n\t            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n\t            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n\t        }\n\t\n\t        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t            textWidthCacheCounter = 0;\n\t            textWidthCache = {};\n\t        }\n\t        textWidthCacheCounter++;\n\t        textWidthCache[key] = width;\n\t\n\t        return width;\n\t    }\n\t\n\t    function getTextRect(text, textFont, textAlign, textBaseline) {\n\t        var textLineLen = ((text || '') + '').split('\\n').length;\n\t\n\t        var width = getTextWidth(text, textFont);\n\t        // FIXME 高度计算比较粗暴\n\t        var lineHeight = getTextWidth('国', textFont);\n\t        var height = textLineLen * lineHeight;\n\t\n\t        var rect = new BoundingRect(0, 0, width, height);\n\t        // Text has a special line height property\n\t        rect.lineHeight = lineHeight;\n\t\n\t        switch (textBaseline) {\n\t            case 'bottom':\n\t            case 'alphabetic':\n\t                rect.y -= lineHeight;\n\t                break;\n\t            case 'middle':\n\t                rect.y -= lineHeight / 2;\n\t                break;\n\t            // case 'hanging':\n\t            // case 'top':\n\t        }\n\t\n\t        // FIXME Right to left language\n\t        switch (textAlign) {\n\t            case 'end':\n\t            case 'right':\n\t                rect.x -= rect.width;\n\t                break;\n\t            case 'center':\n\t                rect.x -= rect.width / 2;\n\t                break;\n\t            // case 'start':\n\t            // case 'left':\n\t        }\n\t\n\t        return rect;\n\t    }\n\t\n\t    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\t\n\t        var x = rect.x;\n\t        var y = rect.y;\n\t\n\t        var height = rect.height;\n\t        var width = rect.width;\n\t\n\t        var textHeight = textRect.height;\n\t\n\t        var halfHeight = height / 2 - textHeight / 2;\n\t\n\t        var textAlign = 'left';\n\t\n\t        switch (textPosition) {\n\t            case 'left':\n\t                x -= distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'right':\n\t                x += distance + width;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'top':\n\t                x += width / 2;\n\t                y -= distance + textHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'bottom':\n\t                x += width / 2;\n\t                y += height + distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'inside':\n\t                x += width / 2;\n\t                y += halfHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideLeft':\n\t                x += distance;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideRight':\n\t                x += width - distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideTop':\n\t                x += width / 2;\n\t                y += distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideBottom':\n\t                x += width / 2;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideTopLeft':\n\t                x += distance;\n\t                y += distance;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideTopRight':\n\t                x += width - distance;\n\t                y += distance;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideBottomLeft':\n\t                x += distance;\n\t                y += height - textHeight - distance;\n\t                break;\n\t            case 'insideBottomRight':\n\t                x += width - distance;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'right';\n\t                break;\n\t        }\n\t\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            textAlign: textAlign,\n\t            textBaseline: 'top'\n\t        };\n\t    }\n\t\n\t    /**\n\t     * Show ellipsis if overflow.\n\t     *\n\t     * @param  {string} text\n\t     * @param  {string} containerWidth\n\t     * @param  {string} textFont\n\t     * @param  {number} [ellipsis='...']\n\t     * @param  {Object} [options]\n\t     * @param  {number} [options.maxIterations=3]\n\t     * @param  {number} [options.minChar=0] If truncate result are less\n\t     *                  then minChar, ellipsis will not show, which is\n\t     *                  better for user hint in some cases.\n\t     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t     * @return {string}\n\t     */\n\t    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t\n\t        options = options || {};\n\t\n\t        ellipsis = retrieve(ellipsis, '...');\n\t        var maxIterations = retrieve(options.maxIterations, 2);\n\t        var minChar = retrieve(options.minChar, 0);\n\t        // FIXME\n\t        // Other languages?\n\t        var cnCharWidth = getTextWidth('国', textFont);\n\t        // FIXME\n\t        // Consider proportional font?\n\t        var ascCharWidth = getTextWidth('a', textFont);\n\t        var placeholder = retrieve(options.placeholder, '');\n\t\n\t        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\t        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\t        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t            contentWidth -= ascCharWidth;\n\t        }\n\t\n\t        var ellipsisWidth = getTextWidth(ellipsis);\n\t        if (ellipsisWidth > contentWidth) {\n\t            ellipsis = '';\n\t            ellipsisWidth = 0;\n\t        }\n\t\n\t        contentWidth = containerWidth - ellipsisWidth;\n\t\n\t        var textLines = (text + '').split('\\n');\n\t\n\t        for (var i = 0, len = textLines.length; i < len; i++) {\n\t            var textLine = textLines[i];\n\t            var lineWidth = getTextWidth(textLine, textFont);\n\t\n\t            if (lineWidth <= containerWidth) {\n\t                continue;\n\t            }\n\t\n\t            for (var j = 0;; j++) {\n\t                if (lineWidth <= contentWidth || j >= maxIterations) {\n\t                    textLine += ellipsis;\n\t                    break;\n\t                }\n\t\n\t                var subLength = j === 0\n\t                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n\t                    : lineWidth > 0\n\t                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n\t                    : 0;\n\t\n\t                textLine = textLine.substr(0, subLength);\n\t                lineWidth = getTextWidth(textLine, textFont);\n\t            }\n\t\n\t            if (textLine === '') {\n\t                textLine = placeholder;\n\t            }\n\t\n\t            textLines[i] = textLine;\n\t        }\n\t\n\t        return textLines.join('\\n');\n\t    }\n\t\n\t    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t        var width = 0;\n\t        var i = 0;\n\t        for (var len = text.length; i < len && width < contentWidth; i++) {\n\t            var charCode = text.charCodeAt(i);\n\t            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n\t        }\n\t        return i;\n\t    }\n\t\n\t    var textContain = {\n\t\n\t        getWidth: getTextWidth,\n\t\n\t        getBoundingRect: getTextRect,\n\t\n\t        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\t\n\t        truncateText: truncateText,\n\t\n\t        measureText: function (text, textFont) {\n\t            var ctx = util.getContext();\n\t            ctx.font = textFont || '12px sans-serif';\n\t            return ctx.measureText(text);\n\t        }\n\t    };\n\t\n\t    module.exports = textContain;\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t    /**\n\t     * 3x2矩阵操作类\n\t     * @exports zrender/tool/matrix\n\t     */\n\t    var matrix = {\n\t        /**\n\t         * 创建一个单位矩阵\n\t         * @return {Float32Array|Array.<number>}\n\t         */\n\t        create : function() {\n\t            var out = new ArrayCtor(6);\n\t            matrix.identity(out);\n\t\n\t            return out;\n\t        },\n\t        /**\n\t         * 设置矩阵为单位矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         */\n\t        identity : function(out) {\n\t            out[0] = 1;\n\t            out[1] = 0;\n\t            out[2] = 0;\n\t            out[3] = 1;\n\t            out[4] = 0;\n\t            out[5] = 0;\n\t            return out;\n\t        },\n\t        /**\n\t         * 复制矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m\n\t         */\n\t        copy: function(out, m) {\n\t            out[0] = m[0];\n\t            out[1] = m[1];\n\t            out[2] = m[2];\n\t            out[3] = m[3];\n\t            out[4] = m[4];\n\t            out[5] = m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * 矩阵相乘\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m1\n\t         * @param {Float32Array|Array.<number>} m2\n\t         */\n\t        mul : function (out, m1, m2) {\n\t            // Consider matrix.mul(m, m2, m);\n\t            // where out is the same as m2.\n\t            // So use temp variable to escape error.\n\t            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t            out[0] = out0;\n\t            out[1] = out1;\n\t            out[2] = out2;\n\t            out[3] = out3;\n\t            out[4] = out4;\n\t            out[5] = out5;\n\t            return out;\n\t        },\n\t        /**\n\t         * 平移变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        translate : function(out, a, v) {\n\t            out[0] = a[0];\n\t            out[1] = a[1];\n\t            out[2] = a[2];\n\t            out[3] = a[3];\n\t            out[4] = a[4] + v[0];\n\t            out[5] = a[5] + v[1];\n\t            return out;\n\t        },\n\t        /**\n\t         * 旋转变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {number} rad\n\t         */\n\t        rotate : function(out, a, rad) {\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t            var st = Math.sin(rad);\n\t            var ct = Math.cos(rad);\n\t\n\t            out[0] = aa * ct + ab * st;\n\t            out[1] = -aa * st + ab * ct;\n\t            out[2] = ac * ct + ad * st;\n\t            out[3] = -ac * st + ct * ad;\n\t            out[4] = ct * atx + st * aty;\n\t            out[5] = ct * aty - st * atx;\n\t            return out;\n\t        },\n\t        /**\n\t         * 缩放变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        scale : function(out, a, v) {\n\t            var vx = v[0];\n\t            var vy = v[1];\n\t            out[0] = a[0] * vx;\n\t            out[1] = a[1] * vy;\n\t            out[2] = a[2] * vx;\n\t            out[3] = a[3] * vy;\n\t            out[4] = a[4] * vx;\n\t            out[5] = a[5] * vy;\n\t            return out;\n\t        },\n\t        /**\n\t         * 求逆矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         */\n\t        invert : function(out, a) {\n\t\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t\n\t            var det = aa * ad - ab * ac;\n\t            if (!det) {\n\t                return null;\n\t            }\n\t            det = 1.0 / det;\n\t\n\t            out[0] = ad * det;\n\t            out[1] = -ab * det;\n\t            out[2] = -ac * det;\n\t            out[3] = aa * det;\n\t            out[4] = (ac * aty - ad * atx) * det;\n\t            out[5] = (ab * atx - aa * aty) * det;\n\t            return out;\n\t        }\n\t    };\n\t\n\t    module.exports = matrix;\n\t\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t/**\n\t * 事件扩展\n\t * @module zrender/mixin/Eventful\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var arrySlice = Array.prototype.slice;\n\t\n\t    /**\n\t     * 事件分发器\n\t     * @alias module:zrender/mixin/Eventful\n\t     * @constructor\n\t     */\n\t    var Eventful = function () {\n\t        this._$handlers = {};\n\t    };\n\t\n\t    Eventful.prototype = {\n\t\n\t        constructor: Eventful,\n\t\n\t        /**\n\t         * 单次触发绑定，trigger后销毁\n\t         *\n\t         * @param {string} event 事件名\n\t         * @param {Function} handler 响应函数\n\t         * @param {Object} context\n\t         */\n\t        one: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: true,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 绑定事件\n\t         * @param {string} event 事件名\n\t         * @param {Function} handler 事件处理函数\n\t         * @param {Object} [context]\n\t         */\n\t        on: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: false,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 是否绑定了事件\n\t         * @param  {string}  event\n\t         * @return {boolean}\n\t         */\n\t        isSilent: function (event) {\n\t            var _h = this._$handlers;\n\t            return _h[event] && _h[event].length;\n\t        },\n\t\n\t        /**\n\t         * 解绑事件\n\t         * @param {string} event 事件名\n\t         * @param {Function} [handler] 事件处理函数\n\t         */\n\t        off: function (event, handler) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!event) {\n\t                this._$handlers = {};\n\t                return this;\n\t            }\n\t\n\t            if (handler) {\n\t                if (_h[event]) {\n\t                    var newList = [];\n\t                    for (var i = 0, l = _h[event].length; i < l; i++) {\n\t                        if (_h[event][i]['h'] != handler) {\n\t                            newList.push(_h[event][i]);\n\t                        }\n\t                    }\n\t                    _h[event] = newList;\n\t                }\n\t\n\t                if (_h[event] && _h[event].length === 0) {\n\t                    delete _h[event];\n\t                }\n\t            }\n\t            else {\n\t                delete _h[event];\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 事件分发\n\t         *\n\t         * @param {string} type 事件类型\n\t         */\n\t        trigger: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 3) {\n\t                    args = arrySlice.call(args, 1);\n\t                }\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(_h[i]['ctx']);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(_h[i]['ctx'], args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 带有context的事件分发, 最后一个参数是事件回调的context\n\t         * @param {string} type 事件类型\n\t         */\n\t        triggerWithContext: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 4) {\n\t                    args = arrySlice.call(args, 1, args.length - 1);\n\t                }\n\t                var ctx = args[args.length - 1];\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(ctx);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(ctx, args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(ctx, args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(ctx, args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    // 对象可以通过 onxxxx 绑定事件\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onclick\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseout\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousemove\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousewheel\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousedown\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseup\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrag\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragstart\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragend\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragenter\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragleave\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrop\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t\n\t    module.exports = Eventful;\n\t\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/tool/color\n\t */\n\t\n\t\n\t    var kCSSColorTable = {\n\t        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n\t        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n\t        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n\t        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n\t        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n\t        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n\t        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n\t        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n\t        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n\t        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n\t        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n\t        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n\t        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n\t        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n\t        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n\t        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n\t        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n\t        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n\t        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n\t        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n\t        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n\t        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n\t        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n\t        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n\t        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n\t        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n\t        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n\t        'gray': [128,128,128,1], 'green': [0,128,0,1],\n\t        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n\t        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n\t        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n\t        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n\t        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n\t        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n\t        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n\t        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n\t        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n\t        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n\t        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n\t        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n\t        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n\t        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n\t        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n\t        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n\t        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n\t        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n\t        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n\t        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n\t        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n\t        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n\t        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n\t        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n\t        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n\t        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n\t        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n\t        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n\t        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n\t        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n\t        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n\t        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n\t        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n\t        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n\t        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n\t        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n\t        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n\t        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n\t        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n\t        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n\t        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n\t        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n\t        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n\t        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n\t        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n\t        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n\t    };\n\t\n\t    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 255 ? 255 : i;\n\t    }\n\t\n\t    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 360 ? 360 : i;\n\t    }\n\t\n\t    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n\t        return f < 0 ? 0 : f > 1 ? 1 : f;\n\t    }\n\t\n\t    function parseCssInt(str) {  // int or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssByte(parseFloat(str) / 100 * 255);\n\t        }\n\t        return clampCssByte(parseInt(str, 10));\n\t    }\n\t\n\t    function parseCssFloat(str) {  // float or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssFloat(parseFloat(str) / 100);\n\t        }\n\t        return clampCssFloat(parseFloat(str));\n\t    }\n\t\n\t    function cssHueToRgb(m1, m2, h) {\n\t        if (h < 0) {\n\t            h += 1;\n\t        }\n\t        else if (h > 1) {\n\t            h -= 1;\n\t        }\n\t\n\t        if (h * 6 < 1) {\n\t            return m1 + (m2 - m1) * h * 6;\n\t        }\n\t        if (h * 2 < 1) {\n\t            return m2;\n\t        }\n\t        if (h * 3 < 2) {\n\t            return m1 + (m2 - m1) * (2/3 - h) * 6;\n\t        }\n\t        return m1;\n\t    }\n\t\n\t    function lerp(a, b, p) {\n\t        return a + (b - a) * p;\n\t    }\n\t\n\t    /**\n\t     * @param {string} colorStr\n\t     * @return {Array.<number>}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function parse(colorStr) {\n\t        if (!colorStr) {\n\t            return;\n\t        }\n\t        // colorStr may be not string\n\t        colorStr = colorStr + '';\n\t        // Remove all whitespace, not compliant, but should just be more accepting.\n\t        var str = colorStr.replace(/ /g, '').toLowerCase();\n\t\n\t        // Color keywords (and transparent) lookup.\n\t        if (str in kCSSColorTable) {\n\t            return kCSSColorTable[str].slice();  // dup.\n\t        }\n\t\n\t        // #abc and #abc123 syntax.\n\t        if (str.charAt(0) === '#') {\n\t            if (str.length === 4) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xfff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n\t                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n\t                    (iv & 0xf) | ((iv & 0xf) << 4),\n\t                    1\n\t                ];\n\t            }\n\t            else if (str.length === 7) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xffffff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 0xff0000) >> 16,\n\t                    (iv & 0xff00) >> 8,\n\t                    iv & 0xff,\n\t                    1\n\t                ];\n\t            }\n\t\n\t            return;\n\t        }\n\t        var op = str.indexOf('('), ep = str.indexOf(')');\n\t        if (op !== -1 && ep + 1 === str.length) {\n\t            var fname = str.substr(0, op);\n\t            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t            var alpha = 1;  // To allow case fallthrough.\n\t            switch (fname) {\n\t                case 'rgba':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n\t                // Fall through.\n\t                case 'rgb':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return [\n\t                        parseCssInt(params[0]),\n\t                        parseCssInt(params[1]),\n\t                        parseCssInt(params[2]),\n\t                        alpha\n\t                    ];\n\t                case 'hsla':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    params[3] = parseCssFloat(params[3]);\n\t                    return hsla2rgba(params);\n\t                case 'hsl':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return hsla2rgba(params);\n\t                default:\n\t                    return;\n\t            }\n\t        }\n\t\n\t        return;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} hsla\n\t     * @return {Array.<number>} rgba\n\t     */\n\t    function hsla2rgba(hsla) {\n\t        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n\t        // NOTE(deanm): According to the CSS spec s/l should only be\n\t        // percentages, but we don't bother and let float or percentage.\n\t        var s = parseCssFloat(hsla[1]);\n\t        var l = parseCssFloat(hsla[2]);\n\t        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t        var m1 = l * 2 - m2;\n\t\n\t        var rgba = [\n\t            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n\t        ];\n\t\n\t        if (hsla.length === 4) {\n\t            rgba[3] = hsla[3];\n\t        }\n\t\n\t        return rgba;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} hsla\n\t     */\n\t    function rgba2hsla(rgba) {\n\t        if (!rgba) {\n\t            return;\n\t        }\n\t\n\t        // RGB from 0 to 255\n\t        var R = rgba[0] / 255;\n\t        var G = rgba[1] / 255;\n\t        var B = rgba[2] / 255;\n\t\n\t        var vMin = Math.min(R, G, B); // Min. value of RGB\n\t        var vMax = Math.max(R, G, B); // Max. value of RGB\n\t        var delta = vMax - vMin; // Delta RGB value\n\t\n\t        var L = (vMax + vMin) / 2;\n\t        var H;\n\t        var S;\n\t        // HSL results from 0 to 1\n\t        if (delta === 0) {\n\t            H = 0;\n\t            S = 0;\n\t        }\n\t        else {\n\t            if (L < 0.5) {\n\t                S = delta / (vMax + vMin);\n\t            }\n\t            else {\n\t                S = delta / (2 - vMax - vMin);\n\t            }\n\t\n\t            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n\t            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n\t            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\t\n\t            if (R === vMax) {\n\t                H = deltaB - deltaG;\n\t            }\n\t            else if (G === vMax) {\n\t                H = (1 / 3) + deltaR - deltaB;\n\t            }\n\t            else if (B === vMax) {\n\t                H = (2 / 3) + deltaG - deltaR;\n\t            }\n\t\n\t            if (H < 0) {\n\t                H += 1;\n\t            }\n\t\n\t            if (H > 1) {\n\t                H -= 1;\n\t            }\n\t        }\n\t\n\t        var hsla = [H * 360, S, L];\n\t\n\t        if (rgba[3] != null) {\n\t            hsla.push(rgba[3]);\n\t        }\n\t\n\t        return hsla;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number} level\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lift(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            for (var i = 0; i < 3; i++) {\n\t                if (level < 0) {\n\t                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t                }\n\t                else {\n\t                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n\t                }\n\t            }\n\t            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function toHex(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<Array.<number>>} colors List of rgba color array\n\t     * @param {Array.<number>} [out] Mapped gba color array\n\t     * @return {Array.<number>}\n\t     */\n\t    function fastMapToColor(normalizedValue, colors, out) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t        out = out || [0, 0, 0, 0];\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = colors[leftIndex];\n\t        var rightColor = colors[rightIndex];\n\t        var dv = value - leftIndex;\n\t        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n\t        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n\t        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n\t        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n\t        return out;\n\t    }\n\t    /**\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {boolean=} fullOutput Default false.\n\t     * @return {(string|Object)} Result color. If fullOutput,\n\t     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function mapToColor(normalizedValue, colors, fullOutput) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = parse(colors[leftIndex]);\n\t        var rightColor = parse(colors[rightIndex]);\n\t        var dv = value - leftIndex;\n\t\n\t        var color = stringify(\n\t            [\n\t                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n\t                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n\t                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n\t                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n\t            ],\n\t            'rgba'\n\t        );\n\t\n\t        return fullOutput\n\t            ? {\n\t                color: color,\n\t                leftIndex: leftIndex,\n\t                rightIndex: rightIndex,\n\t                value: value\n\t            }\n\t            : color;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} h 0 ~ 360, ignore when null.\n\t     * @param {number=} s 0 ~ 1, ignore when null.\n\t     * @param {number=} l 0 ~ 1, ignore when null.\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyHSL(color, h, s, l) {\n\t        color = parse(color);\n\t\n\t        if (color) {\n\t            color = rgba2hsla(color);\n\t            h != null && (color[0] = clampCssAngle(h));\n\t            s != null && (color[1] = parseCssFloat(s));\n\t            l != null && (color[2] = parseCssFloat(l));\n\t\n\t            return stringify(hsla2rgba(color), 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} alpha 0 ~ 1\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyAlpha(color, alpha) {\n\t        color = parse(color);\n\t\n\t        if (color && alpha != null) {\n\t            color[3] = clampCssFloat(alpha);\n\t            return stringify(color, 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {string} type 'rgba', 'hsva', ...\n\t     * @return {string} Result color.\n\t     */\n\t    function stringify(arrColor, type) {\n\t        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t            colorStr += ',' + arrColor[3];\n\t        }\n\t        return type + '(' + colorStr + ')';\n\t    }\n\t\n\t    module.exports = {\n\t        parse: parse,\n\t        lift: lift,\n\t        toHex: toHex,\n\t        fastMapToColor: fastMapToColor,\n\t        mapToColor: mapToColor,\n\t        modifyHSL: modifyHSL,\n\t        modifyAlpha: modifyAlpha,\n\t        stringify: stringify\n\t    };\n\t\n\t\n\n\n/***/ },\n/* 30 */,\n/* 31 */,\n/* 32 */,\n/* 33 */,\n/* 34 */,\n/* 35 */,\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(3)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".el-loading-mask{position:absolute;z-index:10000;background-color:hsla(0,0%,100%,.9);margin:0;top:0;right:0;bottom:0;left:0}.el-loading-mask.is-fullscreen{position:fixed}.el-loading-mask.is-fullscreen .el-loading-spinner{margin-top:-25px}.el-loading-mask.is-fullscreen .el-loading-spinner .circular{width:50px}.el-loading-spinner{top:50%;margin-top:-21px;width:100%;text-align:center;position:absolute}.el-loading-spinner .el-loading-text{color:#20a0ff;margin:3px 0;font-size:14px}.el-loading-spinner .circular{width:42px;-webkit-animation:rotate 2s linear infinite;animation:rotate 2s linear infinite}.el-loading-spinner .path{-webkit-animation:dash 1.5s ease-in-out infinite;animation:dash 1.5s ease-in-out infinite;stroke-dasharray:1,100;stroke-dashoffset:0;stroke-width:2;stroke:#20a0ff;stroke-linecap:round}@-webkit-keyframes rotate{to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes rotate{to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@-webkit-keyframes dash{0%{stroke-dasharray:1,100;stroke-dashoffset:0}50%{stroke-dasharray:45,100;stroke-dashoffset:-35px}to{stroke-dasharray:45,100;stroke-dashoffset:-124px}}@keyframes dash{0%{stroke-dasharray:1,100;stroke-dashoffset:0}50%{stroke-dasharray:45,100;stroke-dashoffset:-35px}to{stroke-dasharray:45,100;stroke-dashoffset:-124px}}\", \"\", {\"version\":3,\"sources\":[\"/./node_modules/element-ui/lib/theme-default/loading.css\"],\"names\":[],\"mappings\":\"AAAiB,iBAAiB,kBAAkB,cAAc,oCAAsC,SAAS,MAAM,QAAQ,SAAS,MAAM,CAAC,+BAA+B,cAAc,CAAC,mDAAmD,gBAAgB,CAAC,6DAA6D,UAAU,CAAC,oBAAoB,QAAQ,iBAAiB,WAAW,kBAAkB,iBAAiB,CAAC,qCAAqC,cAAc,aAAa,cAAc,CAAC,8BAA8B,WAAW,4CAAA,mCAAmC,CAAC,0BAA0B,iDAAA,yCAAyC,uBAAuB,oBAAoB,eAAe,eAAe,oBAAoB,CAAC,0BAAkB,GAAK,gCAAA,uBAAwB,CAAC,CAAhD,kBAAkB,GAAK,gCAAA,uBAAwB,CAAC,CAAC,wBAAgB,GAAG,uBAAuB,mBAAmB,CAAC,IAAI,wBAAwB,uBAAuB,CAAC,GAAK,wBAAwB,wBAAwB,CAAC,CAAxK,gBAAgB,GAAG,uBAAuB,mBAAmB,CAAC,IAAI,wBAAwB,uBAAuB,CAAC,GAAK,wBAAwB,wBAAwB,CAAC,CAAC\",\"file\":\"loading.css\",\"sourcesContent\":[\"@charset \\\"UTF-8\\\";.el-loading-mask{position:absolute;z-index:10000;background-color:rgba(255,255,255,.9);margin:0;top:0;right:0;bottom:0;left:0}.el-loading-mask.is-fullscreen{position:fixed}.el-loading-mask.is-fullscreen .el-loading-spinner{margin-top:-25px}.el-loading-mask.is-fullscreen .el-loading-spinner .circular{width:50px}.el-loading-spinner{top:50%;margin-top:-21px;width:100%;text-align:center;position:absolute}.el-loading-spinner .el-loading-text{color:#20a0ff;margin:3px 0;font-size:14px}.el-loading-spinner .circular{width:42px;animation:rotate 2s linear infinite}.el-loading-spinner .path{animation:dash 1.5s ease-in-out infinite;stroke-dasharray:1,100;stroke-dashoffset:0;stroke-width:2;stroke:#20a0ff;stroke-linecap:round}@keyframes rotate{100%{transform:rotate(360deg)}}@keyframes dash{0%{stroke-dasharray:1,100;stroke-dashoffset:0}50%{stroke-dasharray:45,100;stroke-dashoffset:-35px}100%{stroke-dasharray:45,100;stroke-dashoffset:-124px}}\"],\"sourceRoot\":\"webpack://\"}]);\n\t\n\t// exports\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports =\n\t/******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"/dist/\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ({\n\t\n\t/***/ 0:\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\tmodule.exports = __webpack_require__(117);\n\t\n\t\n\t/***/ },\n\t\n\t/***/ 50:\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __webpack_require__(16);\n\t\n\t/***/ },\n\t\n\t/***/ 66:\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __webpack_require__(44);\n\t\n\t/***/ },\n\t\n\t/***/ 117:\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\texports.__esModule = true;\n\t\n\t\tvar _directive = __webpack_require__(118);\n\t\n\t\tvar _directive2 = _interopRequireDefault(_directive);\n\t\n\t\tvar _index = __webpack_require__(122);\n\t\n\t\tvar _index2 = _interopRequireDefault(_index);\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t\texports.default = {\n\t\t  install: function install(Vue) {\n\t\t    Vue.use(_directive2.default);\n\t\t    Vue.prototype.$loading = _index2.default;\n\t\t  },\n\t\n\t\t  directive: _directive2.default,\n\t\t  service: _index2.default\n\t\t};\n\t\n\t/***/ },\n\t\n\t/***/ 118:\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tvar _vue = __webpack_require__(50);\n\t\n\t\tvar _vue2 = _interopRequireDefault(_vue);\n\t\n\t\tvar _class = __webpack_require__(66);\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t\tvar Mask = _vue2.default.extend(__webpack_require__(119));\n\t\n\t\texports.install = function (Vue) {\n\t\t  var toggleLoading = function toggleLoading(el, binding) {\n\t\t    if (binding.value) {\n\t\t      Vue.nextTick(function () {\n\t\t        if (binding.modifiers.fullscreen) {\n\t\t          el.originalPosition = document.body.style.position;\n\t\t          el.originalOverflow = document.body.style.overflow;\n\t\n\t\t          (0, _class.addClass)(el.mask, 'is-fullscreen');\n\t\t          insertDom(document.body, el, binding);\n\t\t        } else {\n\t\t          (0, _class.removeClass)(el.mask, 'is-fullscreen');\n\t\n\t\t          if (binding.modifiers.body) {\n\t\t            el.originalPosition = document.body.style.position;\n\t\n\t\t            ['top', 'left'].forEach(function (property) {\n\t\t              var scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';\n\t\t              el.maskStyle[property] = el.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] + 'px';\n\t\t            });\n\t\t            ['height', 'width'].forEach(function (property) {\n\t\t              el.maskStyle[property] = el.getBoundingClientRect()[property] + 'px';\n\t\t            });\n\t\n\t\t            insertDom(document.body, el, binding);\n\t\t          } else {\n\t\t            el.originalPosition = el.style.position;\n\t\t            insertDom(el, el, binding);\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    } else {\n\t\t      if (el.domVisible) {\n\t\t        el.mask.style.display = 'none';\n\t\t        el.domVisible = false;\n\t\n\t\t        if (binding.modifiers.fullscreen && el.originalOverflow !== 'hidden') {\n\t\t          document.body.style.overflow = el.originalOverflow;\n\t\t        }\n\t\t        if (binding.modifiers.fullscreen || binding.modifiers.body) {\n\t\t          document.body.style.position = el.originalPosition;\n\t\t        } else {\n\t\t          el.style.position = el.originalPosition;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t  var insertDom = function insertDom(parent, directive, binding) {\n\t\t    if (!directive.domVisible) {\n\t\t      Object.keys(directive.maskStyle).forEach(function (property) {\n\t\t        directive.mask.style[property] = directive.maskStyle[property];\n\t\t      });\n\t\n\t\t      if (directive.originalPosition !== 'absolute') {\n\t\t        parent.style.position = 'relative';\n\t\t      }\n\t\t      if (binding.modifiers.fullscreen && binding.modifiers.lock) {\n\t\t        parent.style.overflow = 'hidden';\n\t\t      }\n\t\t      directive.mask.style.display = 'block';\n\t\t      directive.domVisible = true;\n\t\n\t\t      parent.appendChild(directive.mask);\n\t\t      directive.domInserted = true;\n\t\t    }\n\t\t  };\n\t\n\t\t  Vue.directive('loading', {\n\t\t    bind: function bind(el, binding) {\n\t\t      var mask = new Mask({\n\t\t        el: document.createElement('div'),\n\t\t        data: {\n\t\t          text: el.getAttribute('element-loading-text'),\n\t\t          fullscreen: !!binding.modifiers.fullscreen\n\t\t        }\n\t\t      });\n\t\t      el.mask = mask.$el;\n\t\t      el.maskStyle = {};\n\t\n\t\t      toggleLoading(el, binding);\n\t\t    },\n\t\n\t\t    update: function update(el, binding) {\n\t\t      if (binding.oldValue !== binding.value) {\n\t\t        toggleLoading(el, binding);\n\t\t      }\n\t\t    },\n\t\n\t\t    unbind: function unbind(el, binding) {\n\t\t      if (el.domInserted) {\n\t\t        if (binding.modifiers.fullscreen || binding.modifiers.body) {\n\t\t          document.body.removeChild(el.mask);\n\t\t        } else {\n\t\t          el.mask && el.mask.parentNode && el.mask.parentNode.removeChild(el.mask);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  });\n\t\t};\n\t\n\t/***/ },\n\t\n\t/***/ 119:\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\tvar __vue_exports__, __vue_options__\n\t\tvar __vue_styles__ = {}\n\t\n\t\t/* script */\n\t\t__vue_exports__ = __webpack_require__(120)\n\t\n\t\t/* template */\n\t\tvar __vue_template__ = __webpack_require__(121)\n\t\t__vue_options__ = __vue_exports__ = __vue_exports__ || {}\n\t\tif (\n\t\t  typeof __vue_exports__.default === \"object\" ||\n\t\t  typeof __vue_exports__.default === \"function\"\n\t\t) {\n\t\t__vue_options__ = __vue_exports__ = __vue_exports__.default\n\t\t}\n\t\tif (typeof __vue_options__ === \"function\") {\n\t\t  __vue_options__ = __vue_options__.options\n\t\t}\n\t\n\t\t__vue_options__.render = __vue_template__.render\n\t\t__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\t\n\t\tmodule.exports = __vue_exports__\n\t\n\t\n\t/***/ },\n\t\n\t/***/ 120:\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\texports.__esModule = true;\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\n\t\texports.default = {\n\t\t  data: function data() {\n\t\t    return {\n\t\t      text: null,\n\t\t      fullscreen: true,\n\t\t      customClass: ''\n\t\t    };\n\t\t  }\n\t\t};\n\t\n\t/***/ },\n\t\n\t/***/ 121:\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._c;\n\t\t  return _h('div', {\n\t\t    staticClass: \"el-loading-mask\",\n\t\t    class: [_vm.customClass, {\n\t\t      'is-fullscreen': _vm.fullscreen\n\t\t    }]\n\t\t  }, [_h('div', {\n\t\t    staticClass: \"el-loading-spinner\"\n\t\t  }, [_h('svg', {\n\t\t    staticClass: \"circular\",\n\t\t    attrs: {\n\t\t      \"viewBox\": \"25 25 50 50\"\n\t\t    }\n\t\t  }, [_h('circle', {\n\t\t    staticClass: \"path\",\n\t\t    attrs: {\n\t\t      \"cx\": \"50\",\n\t\t      \"cy\": \"50\",\n\t\t      \"r\": \"20\",\n\t\t      \"fill\": \"none\"\n\t\t    }\n\t\t  })]), (_vm.text) ? _h('p', {\n\t\t    staticClass: \"el-loading-text\"\n\t\t  }, [_vm._s(_vm.text)]) : _vm._e()])])\n\t\t},staticRenderFns: []}\n\t\n\t/***/ },\n\t\n\t/***/ 122:\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\texports.__esModule = true;\n\t\n\t\tvar _vue = __webpack_require__(50);\n\t\n\t\tvar _vue2 = _interopRequireDefault(_vue);\n\t\n\t\tvar _loading = __webpack_require__(119);\n\t\n\t\tvar _loading2 = _interopRequireDefault(_loading);\n\t\n\t\tvar _merge = __webpack_require__(123);\n\t\n\t\tvar _merge2 = _interopRequireDefault(_merge);\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t\tvar LoadingConstructor = _vue2.default.extend(_loading2.default);\n\t\n\t\tvar defaults = {\n\t\t  text: null,\n\t\t  fullscreen: true,\n\t\t  body: false,\n\t\t  lock: false,\n\t\t  customClass: ''\n\t\t};\n\t\n\t\tvar fullscreenLoading = void 0;\n\t\n\t\tLoadingConstructor.prototype.originalPosition = '';\n\t\tLoadingConstructor.prototype.originalOverflow = '';\n\t\n\t\tLoadingConstructor.prototype.close = function () {\n\t\t  if (this.fullscreen && this.originalOverflow !== 'hidden') {\n\t\t    document.body.style.overflow = this.originalOverflow;\n\t\t  }\n\t\t  if (this.fullscreen || this.body) {\n\t\t    document.body.style.position = this.originalPosition;\n\t\t  } else {\n\t\t    this.target.style.position = this.originalPosition;\n\t\t  }\n\t\t  if (this.fullscreen) {\n\t\t    fullscreenLoading = undefined;\n\t\t  }\n\t\t  this.$el && this.$el.parentNode && this.$el.parentNode.removeChild(this.$el);\n\t\t  this.$destroy();\n\t\t};\n\t\n\t\tvar addStyle = function addStyle(options, parent, instance) {\n\t\t  var maskStyle = {};\n\t\t  if (options.fullscreen) {\n\t\t    instance.originalPosition = document.body.style.position;\n\t\t    instance.originalOverflow = document.body.style.overflow;\n\t\t  } else if (options.body) {\n\t\t    instance.originalPosition = document.body.style.position;\n\t\t    ['top', 'left'].forEach(function (property) {\n\t\t      var scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';\n\t\t      maskStyle[property] = options.target.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] + 'px';\n\t\t    });\n\t\t    ['height', 'width'].forEach(function (property) {\n\t\t      maskStyle[property] = options.target.getBoundingClientRect()[property] + 'px';\n\t\t    });\n\t\t  } else {\n\t\t    instance.originalPosition = parent.style.position;\n\t\t  }\n\t\t  Object.keys(maskStyle).forEach(function (property) {\n\t\t    instance.$el.style[property] = maskStyle[property];\n\t\t  });\n\t\t};\n\t\n\t\tvar Loading = function Loading() {\n\t\t  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t\t  options = (0, _merge2.default)({}, defaults, options);\n\t\t  if (typeof options.target === 'string') {\n\t\t    options.target = document.querySelector(options.target);\n\t\t  }\n\t\t  options.target = options.target || document.body;\n\t\t  if (options.target !== document.body) {\n\t\t    options.fullscreen = false;\n\t\t  } else {\n\t\t    options.body = true;\n\t\t  }\n\t\t  if (options.fullscreen && fullscreenLoading) {\n\t\t    return fullscreenLoading;\n\t\t  }\n\t\n\t\t  var parent = options.body ? document.body : options.target;\n\t\t  var instance = new LoadingConstructor({\n\t\t    el: document.createElement('div'),\n\t\t    data: options\n\t\t  });\n\t\n\t\t  addStyle(options, parent, instance);\n\t\t  if (instance.originalPosition !== 'absolute') {\n\t\t    parent.style.position = 'relative';\n\t\t  }\n\t\t  if (options.fullscreen && options.lock) {\n\t\t    parent.style.overflow = 'hidden';\n\t\t  }\n\t\t  parent.appendChild(instance.$el);\n\t\t  if (options.fullscreen) {\n\t\t    fullscreenLoading = instance;\n\t\t  }\n\t\t  return instance;\n\t\t};\n\t\n\t\texports.default = Loading;\n\t\n\t/***/ },\n\t\n\t/***/ 123:\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __webpack_require__(62);\n\t\n\t/***/ }\n\t\n\t/******/ });\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(36);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(4)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../css-loader/index.js?-autoprefixer&sourceMap!./../../../postcss-loader/index.js!./loading.css\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../css-loader/index.js?-autoprefixer&sourceMap!./../../../postcss-loader/index.js!./loading.css\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\n\t\n\t    var dpr = 1;\n\t    // If in browser environment\n\t    if (typeof window !== 'undefined') {\n\t        dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t    }\n\t    /**\n\t     * config默认配置项\n\t     * @exports zrender/config\n\t     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t     */\n\t    var config = {\n\t        /**\n\t         * debug日志选项：catchBrushException为true下有效\n\t         * 0 : 不生成debug数据，发布用\n\t         * 1 : 异常抛出，调试用\n\t         * 2 : 控制台输出，调试用\n\t         */\n\t        debugMode: 0,\n\t\n\t        // retina 屏幕优化\n\t        devicePixelRatio: dpr\n\t    };\n\t    module.exports = config;\n\t\n\t\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n\t * @module zrender/graphic/Group\n\t * @example\n\t *     var Group = require('zrender/lib/container/Group');\n\t *     var Circle = require('zrender/lib/graphic/shape/Circle');\n\t *     var g = new Group();\n\t *     g.position[0] = 100;\n\t *     g.position[1] = 100;\n\t *     g.add(new Circle({\n\t *         style: {\n\t *             x: 100,\n\t *             y: 100,\n\t *             r: 20,\n\t *         }\n\t *     }));\n\t *     zr.add(g);\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var Element = __webpack_require__(73);\n\t    var BoundingRect = __webpack_require__(13);\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Group\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @extends module:zrender/mixin/Eventful\n\t     */\n\t    var Group = function (opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        for (var key in opts) {\n\t            if (opts.hasOwnProperty(key)) {\n\t                this[key] = opts[key];\n\t            }\n\t        }\n\t\n\t        this._children = [];\n\t\n\t        this.__storage = null;\n\t\n\t        this.__dirty = true;\n\t    };\n\t\n\t    Group.prototype = {\n\t\n\t        constructor: Group,\n\t\n\t        isGroup: true,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        type: 'group',\n\t\n\t        /**\n\t         * 所有子孙元素是否响应鼠标事件\n\t         * @name module:/zrender/container/Group#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/Element>}\n\t         */\n\t        children: function () {\n\t            return this._children.slice();\n\t        },\n\t\n\t        /**\n\t         * 获取指定 index 的儿子节点\n\t         * @param  {number} idx\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childAt: function (idx) {\n\t            return this._children[idx];\n\t        },\n\t\n\t        /**\n\t         * 获取指定名字的儿子节点\n\t         * @param  {string} name\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childOfName: function (name) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (children[i].name === name) {\n\t                    return children[i];\n\t                }\n\t             }\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        childCount: function () {\n\t            return this._children.length;\n\t        },\n\t\n\t        /**\n\t         * 添加子节点到最后\n\t         * @param {module:zrender/Element} child\n\t         */\n\t        add: function (child) {\n\t            if (child && child !== this && child.parent !== this) {\n\t\n\t                this._children.push(child);\n\t\n\t                this._doAdd(child);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 添加子节点在 nextSibling 之前\n\t         * @param {module:zrender/Element} child\n\t         * @param {module:zrender/Element} nextSibling\n\t         */\n\t        addBefore: function (child, nextSibling) {\n\t            if (child && child !== this && child.parent !== this\n\t                && nextSibling && nextSibling.parent === this) {\n\t\n\t                var children = this._children;\n\t                var idx = children.indexOf(nextSibling);\n\t\n\t                if (idx >= 0) {\n\t                    children.splice(idx, 0, child);\n\t                    this._doAdd(child);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        _doAdd: function (child) {\n\t            if (child.parent) {\n\t                child.parent.remove(child);\n\t            }\n\t\n\t            child.parent = this;\n\t\n\t            var storage = this.__storage;\n\t            var zr = this.__zr;\n\t            if (storage && storage !== child.__storage) {\n\t\n\t                storage.addToMap(child);\n\t\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * 移除子节点\n\t         * @param {module:zrender/Element} child\n\t         */\n\t        remove: function (child) {\n\t            var zr = this.__zr;\n\t            var storage = this.__storage;\n\t            var children = this._children;\n\t\n\t            var idx = zrUtil.indexOf(children, child);\n\t            if (idx < 0) {\n\t                return this;\n\t            }\n\t            children.splice(idx, 1);\n\t\n\t            child.parent = null;\n\t\n\t            if (storage) {\n\t\n\t                storage.delFromMap(child.id);\n\t\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 移除所有子节点\n\t         */\n\t        removeAll: function () {\n\t            var children = this._children;\n\t            var storage = this.__storage;\n\t            var child;\n\t            var i;\n\t            for (i = 0; i < children.length; i++) {\n\t                child = children[i];\n\t                if (storage) {\n\t                    storage.delFromMap(child.id);\n\t                    if (child instanceof Group) {\n\t                        child.delChildrenFromStorage(storage);\n\t                    }\n\t                }\n\t                child.parent = null;\n\t            }\n\t            children.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 遍历所有子节点\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        eachChild: function (cb, context) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                cb.call(context, child, i);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 深度优先遍历所有子孙节点\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                cb.call(context, child);\n\t\n\t                if (child.type === 'group') {\n\t                    child.traverse(cb, context);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        addChildrenToStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        delChildrenFromStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function (includeChildren) {\n\t            // TODO Caching\n\t            var rect = null;\n\t            var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t            var children = includeChildren || this._children;\n\t            var tmpMat = [];\n\t\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                if (child.ignore || child.invisible) {\n\t                    continue;\n\t                }\n\t\n\t                var childRect = child.getBoundingRect();\n\t                var transform = child.getLocalTransform(tmpMat);\n\t                // TODO\n\t                // The boundingRect cacluated by transforming original\n\t                // rect may be bigger than the actual bundingRect when rotation\n\t                // is used. (Consider a circle rotated aginst its center, where\n\t                // the actual boundingRect should be the same as that not be\n\t                // rotated.) But we can not find better approach to calculate\n\t                // actual boundingRect yet, considering performance.\n\t                if (transform) {\n\t                    tmpRect.copy(childRect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = rect || tmpRect.clone();\n\t                    rect.union(tmpRect);\n\t                }\n\t                else {\n\t                    rect = rect || childRect.clone();\n\t                    rect.union(childRect);\n\t                }\n\t            }\n\t            return rect || tmpRect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Group, Element);\n\t\n\t    module.exports = Group;\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n\t * 可以用于 isInsidePath 判断以及获取boundingRect\n\t *\n\t * @module zrender/core/PathProxy\n\t * @author Yi Shen (http://www.github.com/pissang)\n\t */\n\t\n\t // TODO getTotalLength, getPointAtLength\n\t\n\t\n\t    var curve = __webpack_require__(20);\n\t    var vec2 = __webpack_require__(7);\n\t    var bbox = __webpack_require__(171);\n\t    var BoundingRect = __webpack_require__(13);\n\t    var dpr = __webpack_require__(39).devicePixelRatio;\n\t\n\t    var CMD = {\n\t        M: 1,\n\t        L: 2,\n\t        C: 3,\n\t        Q: 4,\n\t        A: 5,\n\t        Z: 6,\n\t        // Rect\n\t        R: 7\n\t    };\n\t\n\t    var min = [];\n\t    var max = [];\n\t    var min2 = [];\n\t    var max2 = [];\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathCos = Math.cos;\n\t    var mathSin = Math.sin;\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAbs = Math.abs;\n\t\n\t    var hasTypedArray = typeof Float32Array != 'undefined';\n\t\n\t    /**\n\t     * @alias module:zrender/core/PathProxy\n\t     * @constructor\n\t     */\n\t    var PathProxy = function () {\n\t\n\t        /**\n\t         * Path data. Stored as flat array\n\t         * @type {Array.<Object>}\n\t         */\n\t        this.data = [];\n\t\n\t        this._len = 0;\n\t\n\t        this._ctx = null;\n\t\n\t        this._xi = 0;\n\t        this._yi = 0;\n\t\n\t        this._x0 = 0;\n\t        this._y0 = 0;\n\t\n\t        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t        this._ux = 0;\n\t        this._uy = 0;\n\t    };\n\t\n\t    /**\n\t     * 快速计算Path包围盒（并不是最小包围盒）\n\t     * @return {Object}\n\t     */\n\t    PathProxy.prototype = {\n\t\n\t        constructor: PathProxy,\n\t\n\t        _lineDash: null,\n\t\n\t        _dashOffset: 0,\n\t\n\t        _dashIdx: 0,\n\t\n\t        _dashSum: 0,\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        setScale: function (sx, sy) {\n\t            this._ux = mathAbs(1 / dpr / sx) || 0;\n\t            this._uy = mathAbs(1 / dpr / sy) || 0;\n\t        },\n\t\n\t        getContext: function () {\n\t            return this._ctx;\n\t        },\n\t\n\t        /**\n\t         * @param  {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        beginPath: function (ctx) {\n\t\n\t            this._ctx = ctx;\n\t\n\t            ctx && ctx.beginPath();\n\t\n\t            ctx && (this.dpr = ctx.dpr);\n\t\n\t            // Reset\n\t            this._len = 0;\n\t\n\t            if (this._lineDash) {\n\t                this._lineDash = null;\n\t\n\t                this._dashOffset = 0;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        moveTo: function (x, y) {\n\t            this.addData(CMD.M, x, y);\n\t            this._ctx && this._ctx.moveTo(x, y);\n\t\n\t            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n\t            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n\t            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n\t            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\t            this._x0 = x;\n\t            this._y0 = y;\n\t\n\t            this._xi = x;\n\t            this._yi = y;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        lineTo: function (x, y) {\n\t            var exceedUnit = mathAbs(x - this._xi) > this._ux\n\t                || mathAbs(y - this._yi) > this._uy\n\t                // Force draw the first segment\n\t                || this._len < 5;\n\t\n\t            this.addData(CMD.L, x, y);\n\t\n\t            if (this._ctx && exceedUnit) {\n\t                this._needsDash() ? this._dashedLineTo(x, y)\n\t                    : this._ctx.lineTo(x, y);\n\t            }\n\t            if (exceedUnit) {\n\t                this._xi = x;\n\t                this._yi = y;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @param  {number} x3\n\t         * @param  {number} y3\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n\t                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t            }\n\t            this._xi = x3;\n\t            this._yi = y3;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        quadraticCurveTo: function (x1, y1, x2, y2) {\n\t            this.addData(CMD.Q, x1, y1, x2, y2);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n\t                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t            }\n\t            this._xi = x2;\n\t            this._yi = y2;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} cx\n\t         * @param  {number} cy\n\t         * @param  {number} r\n\t         * @param  {number} startAngle\n\t         * @param  {number} endAngle\n\t         * @param  {boolean} anticlockwise\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t            this.addData(\n\t                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n\t            );\n\t            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t\n\t            this._xi = mathCos(endAngle) * r + cx;\n\t            this._xi = mathSin(endAngle) * r + cx;\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        arcTo: function (x1, y1, x2, y2, radius) {\n\t            if (this._ctx) {\n\t                this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        rect: function (x, y, w, h) {\n\t            this._ctx && this._ctx.rect(x, y, w, h);\n\t            this.addData(CMD.R, x, y, w, h);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        closePath: function () {\n\t            this.addData(CMD.Z);\n\t\n\t            var ctx = this._ctx;\n\t            var x0 = this._x0;\n\t            var y0 = this._y0;\n\t            if (ctx) {\n\t                this._needsDash() && this._dashedLineTo(x0, y0);\n\t                ctx.closePath();\n\t            }\n\t\n\t            this._xi = x0;\n\t            this._yi = y0;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n\t         * stroke 同样\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        fill: function (ctx) {\n\t            ctx && ctx.fill();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        stroke: function (ctx) {\n\t            ctx && ctx.stroke();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * 必须在其它绘制命令前调用\n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDash: function (lineDash) {\n\t            if (lineDash instanceof Array) {\n\t                this._lineDash = lineDash;\n\t\n\t                this._dashIdx = 0;\n\t\n\t                var lineDashSum = 0;\n\t                for (var i = 0; i < lineDash.length; i++) {\n\t                    lineDashSum += lineDash[i];\n\t                }\n\t                this._dashSum = lineDashSum;\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 必须在其它绘制命令前调用\n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDashOffset: function (offset) {\n\t            this._dashOffset = offset;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *\n\t         * @return {boolean}\n\t         */\n\t        len: function () {\n\t            return this._len;\n\t        },\n\t\n\t        /**\n\t         * 直接设置 Path 数据\n\t         */\n\t        setData: function (data) {\n\t\n\t            var len = data.length;\n\t\n\t            if (! (this.data && this.data.length == len) && hasTypedArray) {\n\t                this.data = new Float32Array(len);\n\t            }\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                this.data[i] = data[i];\n\t            }\n\t\n\t            this._len = len;\n\t        },\n\t\n\t        /**\n\t         * 添加子路径\n\t         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n\t         */\n\t        appendPath: function (path) {\n\t            if (!(path instanceof Array)) {\n\t                path = [path];\n\t            }\n\t            var len = path.length;\n\t            var appendSize = 0;\n\t            var offset = this._len;\n\t            for (var i = 0; i < len; i++) {\n\t                appendSize += path[i].len();\n\t            }\n\t            if (hasTypedArray && (this.data instanceof Float32Array)) {\n\t                this.data = new Float32Array(offset + appendSize);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                var appendPathData = path[i].data;\n\t                for (var k = 0; k < appendPathData.length; k++) {\n\t                    this.data[offset++] = appendPathData[k];\n\t                }\n\t            }\n\t            this._len = offset;\n\t        },\n\t\n\t        /**\n\t         * 填充 Path 数据。\n\t         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n\t         */\n\t        addData: function (cmd) {\n\t            var data = this.data;\n\t            if (this._len + arguments.length > data.length) {\n\t                // 因为之前的数组已经转换成静态的 Float32Array\n\t                // 所以不够用时需要扩展一个新的动态数组\n\t                this._expandData();\n\t                data = this.data;\n\t            }\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                data[this._len++] = arguments[i];\n\t            }\n\t\n\t            this._prevCmd = cmd;\n\t        },\n\t\n\t        _expandData: function () {\n\t            // Only if data is Float32Array\n\t            if (!(this.data instanceof Array)) {\n\t                var newData = [];\n\t                for (var i = 0; i < this._len; i++) {\n\t                    newData[i] = this.data[i];\n\t                }\n\t                this.data = newData;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * If needs js implemented dashed line\n\t         * @return {boolean}\n\t         * @private\n\t         */\n\t        _needsDash: function () {\n\t            return this._lineDash;\n\t        },\n\t\n\t        _dashedLineTo: function (x1, y1) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var dx = x1 - x0;\n\t            var dy = y1 - y0;\n\t            var dist = mathSqrt(dx * dx + dy * dy);\n\t            var x = x0;\n\t            var y = y0;\n\t            var dash;\n\t            var nDash = lineDash.length;\n\t            var idx;\n\t            dx /= dist;\n\t            dy /= dist;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            x -= offset * dx;\n\t            y -= offset * dy;\n\t\n\t            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n\t            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n\t                idx = this._dashIdx;\n\t                dash = lineDash[idx];\n\t                x += dx * dash;\n\t                y += dy * dash;\n\t                this._dashIdx = (idx + 1) % nDash;\n\t                // Skip positive offset\n\t                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n\t                    continue;\n\t                }\n\t                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n\t                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n\t                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n\t                );\n\t            }\n\t            // Offset for next lineTo\n\t            dx = x - x1;\n\t            dy = y - y1;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        // Not accurate dashed line to\n\t        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var t;\n\t            var dx;\n\t            var dy;\n\t            var cubicAt = curve.cubicAt;\n\t            var bezierLen = 0;\n\t            var idx = this._dashIdx;\n\t            var nDash = lineDash.length;\n\t\n\t            var x;\n\t            var y;\n\t\n\t            var tmpLen = 0;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            // Bezier approx length\n\t            for (t = 0; t < 1; t += 0.1) {\n\t                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n\t                    - cubicAt(x0, x1, x2, x3, t);\n\t                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n\t                    - cubicAt(y0, y1, y2, y3, t);\n\t                bezierLen += mathSqrt(dx * dx + dy * dy);\n\t            }\n\t\n\t            // Find idx after add offset\n\t            for (; idx < nDash; idx++) {\n\t                tmpLen += lineDash[idx];\n\t                if (tmpLen > offset) {\n\t                    break;\n\t                }\n\t            }\n\t            t = (tmpLen - offset) / bezierLen;\n\t\n\t            while (t <= 1) {\n\t\n\t                x = cubicAt(x0, x1, x2, x3, t);\n\t                y = cubicAt(y0, y1, y2, y3, t);\n\t\n\t                // Use line to approximate dashed bezier\n\t                // Bad result if dash is long\n\t                idx % 2 ? ctx.moveTo(x, y)\n\t                    : ctx.lineTo(x, y);\n\t\n\t                t += lineDash[idx] / bezierLen;\n\t\n\t                idx = (idx + 1) % nDash;\n\t            }\n\t\n\t            // Finish the last segment and calculate the new offset\n\t            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n\t            dx = x3 - x;\n\t            dy = y3 - y;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            var x3 = x2;\n\t            var y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (this._xi + 2 * x1) / 3;\n\t            y1 = (this._yi + 2 * y1) / 3;\n\t\n\t            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t        },\n\t\n\t        /**\n\t         * 转成静态的 Float32Array 减少堆内存占用\n\t         * Convert dynamic array to static Float32Array\n\t         */\n\t        toStatic: function () {\n\t            var data = this.data;\n\t            if (data instanceof Array) {\n\t                data.length = this._len;\n\t                if (hasTypedArray) {\n\t                    this.data = new Float32Array(data);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function () {\n\t            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t\n\t            var data = this.data;\n\t            var xi = 0;\n\t            var yi = 0;\n\t            var x0 = 0;\n\t            var y0 = 0;\n\t\n\t            for (var i = 0; i < data.length;) {\n\t                var cmd = data[i++];\n\t\n\t                if (i == 1) {\n\t                    // 如果第一个命令是 L, C, Q\n\t                    // 则 previous point 同绘制命令的第一个 point\n\t                    //\n\t                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                    xi = data[i];\n\t                    yi = data[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                        // 在 closePath 的时候使用\n\t                        x0 = data[i++];\n\t                        y0 = data[i++];\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        min2[0] = x0;\n\t                        min2[1] = y0;\n\t                        max2[0] = x0;\n\t                        max2[1] = y0;\n\t                        break;\n\t                    case CMD.L:\n\t                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.C:\n\t                        bbox.fromCubic(\n\t                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.Q:\n\t                        bbox.fromQuadratic(\n\t                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.A:\n\t                        // TODO Arc 判断的开销比较大\n\t                        var cx = data[i++];\n\t                        var cy = data[i++];\n\t                        var rx = data[i++];\n\t                        var ry = data[i++];\n\t                        var startAngle = data[i++];\n\t                        var endAngle = data[i++] + startAngle;\n\t                        // TODO Arc 旋转\n\t                        var psi = data[i++];\n\t                        var anticlockwise = 1 - data[i++];\n\t\n\t                        if (i == 1) {\n\t                            // 直接使用 arc 命令\n\t                            // 第一个命令起点还未定义\n\t                            x0 = mathCos(startAngle) * rx + cx;\n\t                            y0 = mathSin(startAngle) * ry + cy;\n\t                        }\n\t\n\t                        bbox.fromArc(\n\t                            cx, cy, rx, ry, startAngle, endAngle,\n\t                            anticlockwise, min2, max2\n\t                        );\n\t\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = data[i++];\n\t                        y0 = yi = data[i++];\n\t                        var width = data[i++];\n\t                        var height = data[i++];\n\t                        // Use fromLine\n\t                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t                        break;\n\t                    case CMD.Z:\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        break;\n\t                }\n\t\n\t                // Union\n\t                vec2.min(min, min, min2);\n\t                vec2.max(max, max, max2);\n\t            }\n\t\n\t            // No data\n\t            if (i === 0) {\n\t                min[0] = min[1] = max[0] = max[1] = 0;\n\t            }\n\t\n\t            return new BoundingRect(\n\t                min[0], min[1], max[0] - min[0], max[1] - min[1]\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Rebuild path from current data\n\t         * Rebuild path will not consider javascript implemented line dash.\n\t         * @param {CanvasRenderingContext} ctx\n\t         */\n\t        rebuildPath: function (ctx) {\n\t            var d = this.data;\n\t            var x0, y0;\n\t            var xi, yi;\n\t            var x, y;\n\t            var ux = this._ux;\n\t            var uy = this._uy;\n\t            var len = this._len;\n\t            for (var i = 0; i < len;) {\n\t                var cmd = d[i++];\n\t\n\t                if (i == 1) {\n\t                    // 如果第一个命令是 L, C, Q\n\t                    // 则 previous point 同绘制命令的第一个 point\n\t                    //\n\t                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                    xi = d[i];\n\t                    yi = d[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        x0 = xi = d[i++];\n\t                        y0 = yi = d[i++];\n\t                        ctx.moveTo(xi, yi);\n\t                        break;\n\t                    case CMD.L:\n\t                        x = d[i++];\n\t                        y = d[i++];\n\t                        // Not draw too small seg between\n\t                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t                            ctx.lineTo(x, y);\n\t                            xi = x;\n\t                            yi = y;\n\t                        }\n\t                        break;\n\t                    case CMD.C:\n\t                        ctx.bezierCurveTo(\n\t                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n\t                        );\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.Q:\n\t                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.A:\n\t                        var cx = d[i++];\n\t                        var cy = d[i++];\n\t                        var rx = d[i++];\n\t                        var ry = d[i++];\n\t                        var theta = d[i++];\n\t                        var dTheta = d[i++];\n\t                        var psi = d[i++];\n\t                        var fs = d[i++];\n\t                        var r = (rx > ry) ? rx : ry;\n\t                        var scaleX = (rx > ry) ? 1 : rx / ry;\n\t                        var scaleY = (rx > ry) ? ry / rx : 1;\n\t                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n\t                        var endAngle = theta + dTheta;\n\t                        if (isEllipse) {\n\t                            ctx.translate(cx, cy);\n\t                            ctx.rotate(psi);\n\t                            ctx.scale(scaleX, scaleY);\n\t                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t                            ctx.scale(1 / scaleX, 1 / scaleY);\n\t                            ctx.rotate(-psi);\n\t                            ctx.translate(-cx, -cy);\n\t                        }\n\t                        else {\n\t                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t                        }\n\t\n\t                        if (i == 1) {\n\t                            // 直接使用 arc 命令\n\t                            // 第一个命令起点还未定义\n\t                            x0 = mathCos(theta) * rx + cx;\n\t                            y0 = mathSin(theta) * ry + cy;\n\t                        }\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = d[i];\n\t                        y0 = yi = d[i + 1];\n\t                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t                        break;\n\t                    case CMD.Z:\n\t                        ctx.closePath();\n\t                        xi = x0;\n\t                        yi = y0;\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    PathProxy.CMD = CMD;\n\t\n\t    module.exports = PathProxy;\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 事件辅助类\n\t * @module zrender/core/event\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t */\n\t\n\t\n\t    var Eventful = __webpack_require__(28);\n\t    var env = __webpack_require__(14);\n\t\n\t    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\t\n\t    function getBoundingClientRect(el) {\n\t        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n\t    }\n\t\n\t    // `calculate` is optional, default false\n\t    function clientToLocal(el, e, out, calculate) {\n\t        out = out || {};\n\t\n\t        // According to the W3C Working Draft, offsetX and offsetY should be relative\n\t        // to the padding edge of the target element. The only browser using this convention\n\t        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n\t        // not support the properties.\n\t        // (see http://www.jacklmoore.com/notes/mouse-position/)\n\t        // In zr painter.dom, padding edge equals to border edge.\n\t\n\t        // FIXME\n\t        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n\t        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n\t        // is too complex. So css-transfrom dont support in this case temporarily.\n\t        if (calculate || !env.canvasSupported) {\n\t            defaultGetZrXY(el, e, out);\n\t        }\n\t        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n\t        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n\t        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n\t        // zoom-factor, overflow / opacity layers, transforms ...)\n\t        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n\t        // <https://bugs.jquery.com/ticket/8523#comment:14>\n\t        // BTW3, In ff, offsetX/offsetY is always 0.\n\t        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n\t            out.zrX = e.layerX;\n\t            out.zrY = e.layerY;\n\t        }\n\t        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n\t        else if (e.offsetX != null) {\n\t            out.zrX = e.offsetX;\n\t            out.zrY = e.offsetY;\n\t        }\n\t        // For some other device, e.g., IOS safari.\n\t        else {\n\t            defaultGetZrXY(el, e, out);\n\t        }\n\t\n\t        return out;\n\t    }\n\t\n\t    function defaultGetZrXY(el, e, out) {\n\t        // This well-known method below does not support css transform.\n\t        var box = getBoundingClientRect(el);\n\t        out.zrX = e.clientX - box.left;\n\t        out.zrY = e.clientY - box.top;\n\t    }\n\t\n\t    /**\n\t     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n\t     * `calculate` is optional, default false.\n\t     */\n\t    function normalizeEvent(el, e, calculate) {\n\t\n\t        e = e || window.event;\n\t\n\t        if (e.zrX != null) {\n\t            return e;\n\t        }\n\t\n\t        var eventType = e.type;\n\t        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t\n\t        if (!isTouch) {\n\t            clientToLocal(el, e, e, calculate);\n\t            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t        }\n\t        else {\n\t            var touch = eventType != 'touchend'\n\t                ? e.targetTouches[0]\n\t                : e.changedTouches[0];\n\t            touch && clientToLocal(el, touch, e, calculate);\n\t        }\n\t\n\t        return e;\n\t    }\n\t\n\t    function addEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.addEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.attachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    function removeEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.removeEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.detachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 停止冒泡和阻止默认行为\n\t     * @memberOf module:zrender/core/event\n\t     * @method\n\t     * @param {Event} e : event对象\n\t     */\n\t    var stop = isDomLevel2\n\t        ? function (e) {\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t            e.cancelBubble = true;\n\t        }\n\t        : function (e) {\n\t            e.returnValue = false;\n\t            e.cancelBubble = true;\n\t        };\n\t\n\t    module.exports = {\n\t        clientToLocal: clientToLocal,\n\t        normalizeEvent: normalizeEvent,\n\t        addEventListener: addEventListener,\n\t        removeEventListener: removeEventListener,\n\t\n\t        stop: stop,\n\t        // 做向上兼容\n\t        Dispatcher: Eventful\n\t    };\n\t\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// TODO Parse shadow style\n\t// TODO Only shallow path support\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    module.exports = function (properties) {\n\t        // Normalize\n\t        for (var i = 0; i < properties.length; i++) {\n\t            if (!properties[i][1]) {\n\t               properties[i][1] = properties[i][0];\n\t            }\n\t        }\n\t        return function (excludes) {\n\t            var style = {};\n\t            for (var i = 0; i < properties.length; i++) {\n\t                var propName = properties[i][1];\n\t                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n\t                    continue;\n\t                }\n\t                var val = this.getShallow(propName);\n\t                if (val != null) {\n\t                    style[properties[i][0]] = val;\n\t                }\n\t            }\n\t            return style;\n\t        };\n\t    };\n\n\n/***/ },\n/* 44 */,\n/* 45 */,\n/* 46 */,\n/* 47 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = {\n\t        clearColorPalette: function () {\n\t            this._colorIdx = 0;\n\t            this._colorNameMap = {};\n\t        },\n\t\n\t        getColorFromPalette: function (name, scope) {\n\t            scope = scope || this;\n\t            var colorIdx = scope._colorIdx || 0;\n\t            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});\n\t            if (colorNameMap[name]) {\n\t                return colorNameMap[name];\n\t            }\n\t            var colorPalette = this.get('color', true) || [];\n\t            if (!colorPalette.length) {\n\t                return;\n\t            }\n\t\n\t            var color = colorPalette[colorIdx];\n\t            if (name) {\n\t                colorNameMap[name] = color;\n\t            }\n\t            scope._colorIdx = (colorIdx + 1) % colorPalette.length;\n\t\n\t            return color;\n\t        }\n\t    };\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var clazz = __webpack_require__(21);\n\t\n\t    var parseClassType = clazz.parseClassType;\n\t\n\t    var base = 0;\n\t\n\t    var componentUtil = {};\n\t\n\t    var DELIMITER = '_';\n\t\n\t    /**\n\t     * @public\n\t     * @param {string} type\n\t     * @return {string}\n\t     */\n\t    componentUtil.getUID = function (type) {\n\t        // Considering the case of crossing js context,\n\t        // use Math.random to make id as unique as possible.\n\t        return [(type || ''), base++, Math.random()].join(DELIMITER);\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    componentUtil.enableSubTypeDefaulter = function (entity) {\n\t\n\t        var subTypeDefaulters = {};\n\t\n\t        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n\t            componentType = parseClassType(componentType);\n\t            subTypeDefaulters[componentType.main] = defaulter;\n\t        };\n\t\n\t        entity.determineSubType = function (componentType, option) {\n\t            var type = option.type;\n\t            if (!type) {\n\t                var componentTypeMain = parseClassType(componentType).main;\n\t                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n\t                    type = subTypeDefaulters[componentTypeMain](option);\n\t                }\n\t            }\n\t            return type;\n\t        };\n\t\n\t        return entity;\n\t    };\n\t\n\t    /**\n\t     * Topological travel on Activity Network (Activity On Vertices).\n\t     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n\t     *\n\t     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n\t     *\n\t     * If there is circle dependencey, Error will be thrown.\n\t     *\n\t     */\n\t    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\t\n\t        /**\n\t         * @public\n\t         * @param {Array.<string>} targetNameList Target Component type list.\n\t         *                                           Can be ['aa', 'bb', 'aa.xx']\n\t         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n\t         * @param {Function} callback Params: componentType, dependencies.\n\t         * @param {Object} context Scope of callback.\n\t         */\n\t        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n\t            if (!targetNameList.length) {\n\t                return;\n\t            }\n\t\n\t            var result = makeDepndencyGraph(fullNameList);\n\t            var graph = result.graph;\n\t            var stack = result.noEntryList;\n\t\n\t            var targetNameSet = {};\n\t            zrUtil.each(targetNameList, function (name) {\n\t                targetNameSet[name] = true;\n\t            });\n\t\n\t            while (stack.length) {\n\t                var currComponentType = stack.pop();\n\t                var currVertex = graph[currComponentType];\n\t                var isInTargetNameSet = !!targetNameSet[currComponentType];\n\t                if (isInTargetNameSet) {\n\t                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n\t                    delete targetNameSet[currComponentType];\n\t                }\n\t                zrUtil.each(\n\t                    currVertex.successor,\n\t                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n\t                );\n\t            }\n\t\n\t            zrUtil.each(targetNameSet, function () {\n\t                throw new Error('Circle dependency may exists');\n\t            });\n\t\n\t            function removeEdge(succComponentType) {\n\t                graph[succComponentType].entryCount--;\n\t                if (graph[succComponentType].entryCount === 0) {\n\t                    stack.push(succComponentType);\n\t                }\n\t            }\n\t\n\t            // Consider this case: legend depends on series, and we call\n\t            // chart.setOption({series: [...]}), where only series is in option.\n\t            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n\t            // not be called, but only sereis.mergeOption is called. Thus legend\n\t            // have no chance to update its local record about series (like which\n\t            // name of series is available in legend).\n\t            function removeEdgeAndAdd(succComponentType) {\n\t                targetNameSet[succComponentType] = true;\n\t                removeEdge(succComponentType);\n\t            }\n\t        };\n\t\n\t        /**\n\t         * DepndencyGraph: {Object}\n\t         * key: conponentType,\n\t         * value: {\n\t         *     successor: [conponentTypes...],\n\t         *     originalDeps: [conponentTypes...],\n\t         *     entryCount: {number}\n\t         * }\n\t         */\n\t        function makeDepndencyGraph(fullNameList) {\n\t            var graph = {};\n\t            var noEntryList = [];\n\t\n\t            zrUtil.each(fullNameList, function (name) {\n\t\n\t                var thisItem = createDependencyGraphItem(graph, name);\n\t                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\t\n\t                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n\t                thisItem.entryCount = availableDeps.length;\n\t                if (thisItem.entryCount === 0) {\n\t                    noEntryList.push(name);\n\t                }\n\t\n\t                zrUtil.each(availableDeps, function (dependentName) {\n\t                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n\t                        thisItem.predecessor.push(dependentName);\n\t                    }\n\t                    var thatItem = createDependencyGraphItem(graph, dependentName);\n\t                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n\t                        thatItem.successor.push(name);\n\t                    }\n\t                });\n\t            });\n\t\n\t            return {graph: graph, noEntryList: noEntryList};\n\t        }\n\t\n\t        function createDependencyGraphItem(graph, name) {\n\t            if (!graph[name]) {\n\t                graph[name] = {predecessor: [], successor: []};\n\t            }\n\t            return graph[name];\n\t        }\n\t\n\t        function getAvailableDependencies(originalDeps, fullNameList) {\n\t            var availableDeps = [];\n\t            zrUtil.each(originalDeps, function (dep) {\n\t                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n\t            });\n\t            return availableDeps;\n\t        }\n\t    };\n\t\n\t    module.exports = componentUtil;\n\n\n/***/ },\n/* 49 */,\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/**\n\t * @fileOverview Kickass library to create and place poppers near their reference elements.\n\t * @version {{version}}\n\t * @license\n\t * Copyright (c) 2016 Federico Zivolo and contributors\n\t *\n\t * Permission is hereby granted, free of charge, to any person obtaining a copy\n\t * of this software and associated documentation files (the \"Software\"), to deal\n\t * in the Software without restriction, including without limitation the rights\n\t * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t * copies of the Software, and to permit persons to whom the Software is\n\t * furnished to do so, subject to the following conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be included in all\n\t * copies or substantial portions of the Software.\n\t *\n\t * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\t * SOFTWARE.\n\t */\n\t\n\t//\n\t// Cross module loader\n\t// Supported: Node, AMD, Browser globals\n\t//\n\t;(function (root, factory) {\n\t    if (true) {\n\t        // AMD. Register as an anonymous module.\n\t        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n\t        // Node. Does not work with strict CommonJS, but\n\t        // only CommonJS-like environments that support module.exports,\n\t        // like Node.\n\t        module.exports = factory();\n\t    } else {\n\t        // Browser globals (root is window)\n\t        root.Popper = factory();\n\t    }\n\t})(undefined, function () {\n\t\n\t    'use strict';\n\t\n\t    var root = window;\n\t\n\t    // default options\n\t    var DEFAULTS = {\n\t        // placement of the popper\n\t        placement: 'bottom',\n\t\n\t        gpuAcceleration: true,\n\t\n\t        // shift popper from its origin by the given amount of pixels (can be negative)\n\t        offset: 0,\n\t\n\t        // the element which will act as boundary of the popper\n\t        boundariesElement: 'viewport',\n\t\n\t        // amount of pixel used to define a minimum distance between the boundaries and the popper\n\t        boundariesPadding: 5,\n\t\n\t        // popper will try to prevent overflow following this order,\n\t        // by default, then, it could overflow on the left and on top of the boundariesElement\n\t        preventOverflowOrder: ['left', 'right', 'top', 'bottom'],\n\t\n\t        // the behavior used by flip to change the placement of the popper\n\t        flipBehavior: 'flip',\n\t\n\t        arrowElement: '[x-arrow]',\n\t\n\t        // list of functions used to modify the offsets before they are applied to the popper\n\t        modifiers: ['shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle'],\n\t\n\t        modifiersIgnored: [],\n\t\n\t        forceAbsolute: false\n\t    };\n\t\n\t    /**\n\t     * Create a new Popper.js instance\n\t     * @constructor Popper\n\t     * @param {HTMLElement} reference - The reference element used to position the popper\n\t     * @param {HTMLElement|Object} popper\n\t     *      The HTML element used as popper, or a configuration used to generate the popper.\n\t     * @param {String} [popper.tagName='div'] The tag name of the generated popper.\n\t     * @param {Array} [popper.classNames=['popper']] Array of classes to apply to the generated popper.\n\t     * @param {Array} [popper.attributes] Array of attributes to apply, specify `attr:value` to assign a value to it.\n\t     * @param {HTMLElement|String} [popper.parent=window.document.body] The parent element, given as HTMLElement or as query string.\n\t     * @param {String} [popper.content=''] The content of the popper, it can be text, html, or node; if it is not text, set `contentType` to `html` or `node`.\n\t     * @param {String} [popper.contentType='text'] If `html`, the `content` will be parsed as HTML. If `node`, it will be appended as-is.\n\t     * @param {String} [popper.arrowTagName='div'] Same as `popper.tagName` but for the arrow element.\n\t     * @param {Array} [popper.arrowClassNames='popper__arrow'] Same as `popper.classNames` but for the arrow element.\n\t     * @param {String} [popper.arrowAttributes=['x-arrow']] Same as `popper.attributes` but for the arrow element.\n\t     * @param {Object} options\n\t     * @param {String} [options.placement=bottom]\n\t     *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -right),\n\t     *      left(-start, -end)`\n\t     *\n\t     * @param {HTMLElement|String} [options.arrowElement='[x-arrow]']\n\t     *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of\n\t     *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its\n\t     *      reference element.\n\t     *      By default, it will look for a child node of the popper with the `x-arrow` attribute.\n\t     *\n\t     * @param {Boolean} [options.gpuAcceleration=true]\n\t     *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the\n\t     *      browser to use the GPU to accelerate the rendering.\n\t     *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.\n\t     *\n\t     * @param {Number} [options.offset=0]\n\t     *      Amount of pixels the popper will be shifted (can be negative).\n\t     *\n\t     * @param {String|Element} [options.boundariesElement='viewport']\n\t     *      The element which will define the boundaries of the popper position, the popper will never be placed outside\n\t     *      of the defined boundaries (except if `keepTogether` is enabled)\n\t     *\n\t     * @param {Number} [options.boundariesPadding=5]\n\t     *      Additional padding for the boundaries\n\t     *\n\t     * @param {Array} [options.preventOverflowOrder=['left', 'right', 'top', 'bottom']]\n\t     *      Order used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,\n\t     *      this means that the last ones will never overflow\n\t     *\n\t     * @param {String|Array} [options.flipBehavior='flip']\n\t     *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to\n\t     *      overlap its reference element. Defining `flip` as value, the placement will be flipped on\n\t     *      its axis (`right - left`, `top - bottom`).\n\t     *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify\n\t     *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,\n\t     *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)\n\t     *\n\t     * @param {Array} [options.modifiers=[ 'shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle']]\n\t     *      List of functions used to modify the data before they are applied to the popper, add your custom functions\n\t     *      to this array to edit the offsets and placement.\n\t     *      The function should reflect the @params and @returns of preventOverflow\n\t     *\n\t     * @param {Array} [options.modifiersIgnored=[]]\n\t     *      Put here any built-in modifier name you want to exclude from the modifiers list\n\t     *      The function should reflect the @params and @returns of preventOverflow\n\t     *\n\t     * @param {Boolean} [options.removeOnDestroy=false]\n\t     *      Set to true if you want to automatically remove the popper when you call the `destroy` method.\n\t     */\n\t    function Popper(reference, popper, options) {\n\t        this._reference = reference.jquery ? reference[0] : reference;\n\t        this.state = {};\n\t\n\t        // if the popper variable is a configuration object, parse it to generate an HTMLElement\n\t        // generate a default popper if is not defined\n\t        var isNotDefined = typeof popper === 'undefined' || popper === null;\n\t        var isConfig = popper && Object.prototype.toString.call(popper) === '[object Object]';\n\t        if (isNotDefined || isConfig) {\n\t            this._popper = this.parse(isConfig ? popper : {});\n\t        }\n\t        // otherwise, use the given HTMLElement as popper\n\t        else {\n\t                this._popper = popper.jquery ? popper[0] : popper;\n\t            }\n\t\n\t        // with {} we create a new object with the options inside it\n\t        this._options = Object.assign({}, DEFAULTS, options);\n\t\n\t        // refactoring modifiers' list\n\t        this._options.modifiers = this._options.modifiers.map(function (modifier) {\n\t            // remove ignored modifiers\n\t            if (this._options.modifiersIgnored.indexOf(modifier) !== -1) return;\n\t\n\t            // set the x-placement attribute before everything else because it could be used to add margins to the popper\n\t            // margins needs to be calculated to get the correct popper offsets\n\t            if (modifier === 'applyStyle') {\n\t                this._popper.setAttribute('x-placement', this._options.placement);\n\t            }\n\t\n\t            // return predefined modifier identified by string or keep the custom one\n\t            return this.modifiers[modifier] || modifier;\n\t        }.bind(this));\n\t\n\t        // make sure to apply the popper position before any computation\n\t        this.state.position = this._getPosition(this._popper, this._reference);\n\t        setStyle(this._popper, { position: this.state.position });\n\t\n\t        // fire the first update to position the popper in the right place\n\t        this.update();\n\t\n\t        // setup event listeners, they will take care of update the position in specific situations\n\t        this._setupEventListeners();\n\t        return this;\n\t    }\n\t\n\t    //\n\t    // Methods\n\t    //\n\t    /**\n\t     * Destroy the popper\n\t     * @method\n\t     * @memberof Popper\n\t     */\n\t    Popper.prototype.destroy = function () {\n\t        this._popper.removeAttribute('x-placement');\n\t        this._popper.style.left = '';\n\t        this._popper.style.position = '';\n\t        this._popper.style.top = '';\n\t        this._popper.style[getSupportedPropertyName('transform')] = '';\n\t        this._removeEventListeners();\n\t\n\t        // remove the popper if user explicity asked for the deletion on destroy\n\t        if (this._options.removeOnDestroy) {\n\t            this._popper.remove();\n\t        }\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Updates the position of the popper, computing the new offsets and applying the new style\n\t     * @method\n\t     * @memberof Popper\n\t     */\n\t    Popper.prototype.update = function () {\n\t        var data = { instance: this, styles: {} };\n\t\n\t        // store placement inside the data object, modifiers will be able to edit `placement` if needed\n\t        // and refer to _originalPlacement to know the original value\n\t        data.placement = this._options.placement;\n\t        data._originalPlacement = this._options.placement;\n\t\n\t        // compute the popper and reference offsets and put them inside data.offsets\n\t        data.offsets = this._getOffsets(this._popper, this._reference, data.placement);\n\t\n\t        // get boundaries\n\t        data.boundaries = this._getBoundaries(data, this._options.boundariesPadding, this._options.boundariesElement);\n\t\n\t        data = this.runModifiers(data, this._options.modifiers);\n\t\n\t        if (typeof this.state.updateCallback === 'function') {\n\t            this.state.updateCallback(data);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * If a function is passed, it will be executed after the initialization of popper with as first argument the Popper instance.\n\t     * @method\n\t     * @memberof Popper\n\t     * @param {Function} callback\n\t     */\n\t    Popper.prototype.onCreate = function (callback) {\n\t        // the createCallbacks return as first argument the popper instance\n\t        callback(this);\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * If a function is passed, it will be executed after each update of popper with as first argument the set of coordinates and informations\n\t     * used to style popper and its arrow.\n\t     * NOTE: it doesn't get fired on the first call of the `Popper.update()` method inside the `Popper` constructor!\n\t     * @method\n\t     * @memberof Popper\n\t     * @param {Function} callback\n\t     */\n\t    Popper.prototype.onUpdate = function (callback) {\n\t        this.state.updateCallback = callback;\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Helper used to generate poppers from a configuration file\n\t     * @method\n\t     * @memberof Popper\n\t     * @param config {Object} configuration\n\t     * @returns {HTMLElement} popper\n\t     */\n\t    Popper.prototype.parse = function (config) {\n\t        var defaultConfig = {\n\t            tagName: 'div',\n\t            classNames: ['popper'],\n\t            attributes: [],\n\t            parent: root.document.body,\n\t            content: '',\n\t            contentType: 'text',\n\t            arrowTagName: 'div',\n\t            arrowClassNames: ['popper__arrow'],\n\t            arrowAttributes: ['x-arrow']\n\t        };\n\t        config = Object.assign({}, defaultConfig, config);\n\t\n\t        var d = root.document;\n\t\n\t        var popper = d.createElement(config.tagName);\n\t        addClassNames(popper, config.classNames);\n\t        addAttributes(popper, config.attributes);\n\t        if (config.contentType === 'node') {\n\t            popper.appendChild(config.content.jquery ? config.content[0] : config.content);\n\t        } else if (config.contentType === 'html') {\n\t            popper.innerHTML = config.content;\n\t        } else {\n\t            popper.textContent = config.content;\n\t        }\n\t\n\t        if (config.arrowTagName) {\n\t            var arrow = d.createElement(config.arrowTagName);\n\t            addClassNames(arrow, config.arrowClassNames);\n\t            addAttributes(arrow, config.arrowAttributes);\n\t            popper.appendChild(arrow);\n\t        }\n\t\n\t        var parent = config.parent.jquery ? config.parent[0] : config.parent;\n\t\n\t        // if the given parent is a string, use it to match an element\n\t        // if more than one element is matched, the first one will be used as parent\n\t        // if no elements are matched, the script will throw an error\n\t        if (typeof parent === 'string') {\n\t            parent = d.querySelectorAll(config.parent);\n\t            if (parent.length > 1) {\n\t                console.warn('WARNING: the given `parent` query(' + config.parent + ') matched more than one element, the first one will be used');\n\t            }\n\t            if (parent.length === 0) {\n\t                throw 'ERROR: the given `parent` doesn\\'t exists!';\n\t            }\n\t            parent = parent[0];\n\t        }\n\t        // if the given parent is a DOM nodes list or an array of nodes with more than one element,\n\t        // the first one will be used as parent\n\t        if (parent.length > 1 && parent instanceof Element === false) {\n\t            console.warn('WARNING: you have passed as parent a list of elements, the first one will be used');\n\t            parent = parent[0];\n\t        }\n\t\n\t        // append the generated popper to its parent\n\t        parent.appendChild(popper);\n\t\n\t        return popper;\n\t\n\t        /**\n\t         * Adds class names to the given element\n\t         * @function\n\t         * @ignore\n\t         * @param {HTMLElement} target\n\t         * @param {Array} classes\n\t         */\n\t        function addClassNames(element, classNames) {\n\t            classNames.forEach(function (className) {\n\t                element.classList.add(className);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Adds attributes to the given element\n\t         * @function\n\t         * @ignore\n\t         * @param {HTMLElement} target\n\t         * @param {Array} attributes\n\t         * @example\n\t         * addAttributes(element, [ 'data-info:foobar' ]);\n\t         */\n\t        function addAttributes(element, attributes) {\n\t            attributes.forEach(function (attribute) {\n\t                element.setAttribute(attribute.split(':')[0], attribute.split(':')[1] || '');\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Helper used to get the position which will be applied to the popper\n\t     * @method\n\t     * @memberof Popper\n\t     * @param config {HTMLElement} popper element\n\t     * @returns {HTMLElement} reference element\n\t     */\n\t    Popper.prototype._getPosition = function (popper, reference) {\n\t        var container = getOffsetParent(reference);\n\t\n\t        if (this._options.forceAbsolute) {\n\t            return 'absolute';\n\t        }\n\t\n\t        // Decide if the popper will be fixed\n\t        // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together\n\t        var isParentFixed = isFixed(reference, container);\n\t        return isParentFixed ? 'fixed' : 'absolute';\n\t    };\n\t\n\t    /**\n\t     * Get offsets to the popper\n\t     * @method\n\t     * @memberof Popper\n\t     * @access private\n\t     * @param {Element} popper - the popper element\n\t     * @param {Element} reference - the reference element (the popper will be relative to this)\n\t     * @returns {Object} An object containing the offsets which will be applied to the popper\n\t     */\n\t    Popper.prototype._getOffsets = function (popper, reference, placement) {\n\t        placement = placement.split('-')[0];\n\t        var popperOffsets = {};\n\t\n\t        popperOffsets.position = this.state.position;\n\t        var isParentFixed = popperOffsets.position === 'fixed';\n\t\n\t        //\n\t        // Get reference element position\n\t        //\n\t        var referenceOffsets = getOffsetRectRelativeToCustomParent(reference, getOffsetParent(popper), isParentFixed);\n\t\n\t        //\n\t        // Get popper sizes\n\t        //\n\t        var popperRect = getOuterSizes(popper);\n\t\n\t        //\n\t        // Compute offsets of popper\n\t        //\n\t\n\t        // depending by the popper placement we have to compute its offsets slightly differently\n\t        if (['right', 'left'].indexOf(placement) !== -1) {\n\t            popperOffsets.top = referenceOffsets.top + referenceOffsets.height / 2 - popperRect.height / 2;\n\t            if (placement === 'left') {\n\t                popperOffsets.left = referenceOffsets.left - popperRect.width;\n\t            } else {\n\t                popperOffsets.left = referenceOffsets.right;\n\t            }\n\t        } else {\n\t            popperOffsets.left = referenceOffsets.left + referenceOffsets.width / 2 - popperRect.width / 2;\n\t            if (placement === 'top') {\n\t                popperOffsets.top = referenceOffsets.top - popperRect.height;\n\t            } else {\n\t                popperOffsets.top = referenceOffsets.bottom;\n\t            }\n\t        }\n\t\n\t        // Add width and height to our offsets object\n\t        popperOffsets.width = popperRect.width;\n\t        popperOffsets.height = popperRect.height;\n\t\n\t        return {\n\t            popper: popperOffsets,\n\t            reference: referenceOffsets\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Setup needed event listeners used to update the popper position\n\t     * @method\n\t     * @memberof Popper\n\t     * @access private\n\t     */\n\t    Popper.prototype._setupEventListeners = function () {\n\t        // NOTE: 1 DOM access here\n\t        this.state.updateBound = this.update.bind(this);\n\t        root.addEventListener('resize', this.state.updateBound);\n\t        // if the boundariesElement is window we don't need to listen for the scroll event\n\t        if (this._options.boundariesElement !== 'window') {\n\t            var target = getScrollParent(this._reference);\n\t            // here it could be both `body` or `documentElement` thanks to Firefox, we then check both\n\t            if (target === root.document.body || target === root.document.documentElement) {\n\t                target = root;\n\t            }\n\t            target.addEventListener('scroll', this.state.updateBound);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Remove event listeners used to update the popper position\n\t     * @method\n\t     * @memberof Popper\n\t     * @access private\n\t     */\n\t    Popper.prototype._removeEventListeners = function () {\n\t        // NOTE: 1 DOM access here\n\t        root.removeEventListener('resize', this.state.updateBound);\n\t        if (this._options.boundariesElement !== 'window') {\n\t            var target = getScrollParent(this._reference);\n\t            // here it could be both `body` or `documentElement` thanks to Firefox, we then check both\n\t            if (target === root.document.body || target === root.document.documentElement) {\n\t                target = root;\n\t            }\n\t            target.removeEventListener('scroll', this.state.updateBound);\n\t        }\n\t        this.state.updateBound = null;\n\t    };\n\t\n\t    /**\n\t     * Computed the boundaries limits and return them\n\t     * @method\n\t     * @memberof Popper\n\t     * @access private\n\t     * @param {Object} data - Object containing the property \"offsets\" generated by `_getOffsets`\n\t     * @param {Number} padding - Boundaries padding\n\t     * @param {Element} boundariesElement - Element used to define the boundaries\n\t     * @returns {Object} Coordinates of the boundaries\n\t     */\n\t    Popper.prototype._getBoundaries = function (data, padding, boundariesElement) {\n\t        // NOTE: 1 DOM access here\n\t        var boundaries = {};\n\t        var width, height;\n\t        if (boundariesElement === 'window') {\n\t            var body = root.document.body,\n\t                html = root.document.documentElement;\n\t\n\t            height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n\t            width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);\n\t\n\t            boundaries = {\n\t                top: 0,\n\t                right: width,\n\t                bottom: height,\n\t                left: 0\n\t            };\n\t        } else if (boundariesElement === 'viewport') {\n\t            var offsetParent = getOffsetParent(this._popper);\n\t            var scrollParent = getScrollParent(this._popper);\n\t            var offsetParentRect = getOffsetRect(offsetParent);\n\t\n\t            // if the popper is fixed we don't have to substract scrolling from the boundaries\n\t            var scrollTop = data.offsets.popper.position === 'fixed' ? 0 : scrollParent.scrollTop;\n\t            var scrollLeft = data.offsets.popper.position === 'fixed' ? 0 : scrollParent.scrollLeft;\n\t\n\t            boundaries = {\n\t                top: 0 - (offsetParentRect.top - scrollTop),\n\t                right: root.document.documentElement.clientWidth - (offsetParentRect.left - scrollLeft),\n\t                bottom: root.document.documentElement.clientHeight - (offsetParentRect.top - scrollTop),\n\t                left: 0 - (offsetParentRect.left - scrollLeft)\n\t            };\n\t        } else {\n\t            if (getOffsetParent(this._popper) === boundariesElement) {\n\t                boundaries = {\n\t                    top: 0,\n\t                    left: 0,\n\t                    right: boundariesElement.clientWidth,\n\t                    bottom: boundariesElement.clientHeight\n\t                };\n\t            } else {\n\t                boundaries = getOffsetRect(boundariesElement);\n\t            }\n\t        }\n\t        boundaries.left += padding;\n\t        boundaries.right -= padding;\n\t        boundaries.top = boundaries.top + padding;\n\t        boundaries.bottom = boundaries.bottom - padding;\n\t        return boundaries;\n\t    };\n\t\n\t    /**\n\t     * Loop trough the list of modifiers and run them in order, each of them will then edit the data object\n\t     * @method\n\t     * @memberof Popper\n\t     * @access public\n\t     * @param {Object} data\n\t     * @param {Array} modifiers\n\t     * @param {Function} ends\n\t     */\n\t    Popper.prototype.runModifiers = function (data, modifiers, ends) {\n\t        var modifiersToRun = modifiers.slice();\n\t        if (ends !== undefined) {\n\t            modifiersToRun = this._options.modifiers.slice(0, getArrayKeyIndex(this._options.modifiers, ends));\n\t        }\n\t\n\t        modifiersToRun.forEach(function (modifier) {\n\t            if (isFunction(modifier)) {\n\t                data = modifier.call(this, data);\n\t            }\n\t        }.bind(this));\n\t\n\t        return data;\n\t    };\n\t\n\t    /**\n\t     * Helper used to know if the given modifier depends from another one.\n\t     * @method\n\t     * @memberof Popper\n\t     * @returns {Boolean}\n\t     */\n\t\n\t    Popper.prototype.isModifierRequired = function (requesting, requested) {\n\t        var index = getArrayKeyIndex(this._options.modifiers, requesting);\n\t        return !!this._options.modifiers.slice(0, index).filter(function (modifier) {\n\t            return modifier === requested;\n\t        }).length;\n\t    };\n\t\n\t    //\n\t    // Modifiers\n\t    //\n\t\n\t    /**\n\t     * Modifiers list\n\t     * @namespace Popper.modifiers\n\t     * @memberof Popper\n\t     * @type {Object}\n\t     */\n\t    Popper.prototype.modifiers = {};\n\t\n\t    /**\n\t     * Apply the computed styles to the popper element\n\t     * @method\n\t     * @memberof Popper.modifiers\n\t     * @argument {Object} data - The data object generated by `update` method\n\t     * @returns {Object} The same data object\n\t     */\n\t    Popper.prototype.modifiers.applyStyle = function (data) {\n\t        // apply the final offsets to the popper\n\t        // NOTE: 1 DOM access here\n\t        var styles = {\n\t            position: data.offsets.popper.position\n\t        };\n\t\n\t        // round top and left to avoid blurry text\n\t        var left = Math.round(data.offsets.popper.left);\n\t        var top = Math.round(data.offsets.popper.top);\n\t\n\t        // if gpuAcceleration is set to true and transform is supported, we use `translate3d` to apply the position to the popper\n\t        // we automatically use the supported prefixed version if needed\n\t        var prefixedProperty;\n\t        if (this._options.gpuAcceleration && (prefixedProperty = getSupportedPropertyName('transform'))) {\n\t            styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n\t            styles.top = 0;\n\t            styles.left = 0;\n\t        }\n\t        // othwerise, we use the standard `left` and `top` properties\n\t        else {\n\t                styles.left = left;\n\t                styles.top = top;\n\t            }\n\t\n\t        // any property present in `data.styles` will be applied to the popper,\n\t        // in this way we can make the 3rd party modifiers add custom styles to it\n\t        // Be aware, modifiers could override the properties defined in the previous\n\t        // lines of this modifier!\n\t        Object.assign(styles, data.styles);\n\t\n\t        setStyle(this._popper, styles);\n\t\n\t        // set an attribute which will be useful to style the tooltip (use it to properly position its arrow)\n\t        // NOTE: 1 DOM access here\n\t        this._popper.setAttribute('x-placement', data.placement);\n\t\n\t        // if the arrow modifier is required and the arrow style has been computed, apply the arrow style\n\t        if (this.isModifierRequired(this.modifiers.applyStyle, this.modifiers.arrow) && data.offsets.arrow) {\n\t            setStyle(data.arrowElement, data.offsets.arrow);\n\t        }\n\t\n\t        return data;\n\t    };\n\t\n\t    /**\n\t     * Modifier used to shift the popper on the start or end of its reference element side\n\t     * @method\n\t     * @memberof Popper.modifiers\n\t     * @argument {Object} data - The data object generated by `update` method\n\t     * @returns {Object} The data object, properly modified\n\t     */\n\t    Popper.prototype.modifiers.shift = function (data) {\n\t        var placement = data.placement;\n\t        var basePlacement = placement.split('-')[0];\n\t        var shiftVariation = placement.split('-')[1];\n\t\n\t        // if shift shiftVariation is specified, run the modifier\n\t        if (shiftVariation) {\n\t            var reference = data.offsets.reference;\n\t            var popper = getPopperClientRect(data.offsets.popper);\n\t\n\t            var shiftOffsets = {\n\t                y: {\n\t                    start: { top: reference.top },\n\t                    end: { top: reference.top + reference.height - popper.height }\n\t                },\n\t                x: {\n\t                    start: { left: reference.left },\n\t                    end: { left: reference.left + reference.width - popper.width }\n\t                }\n\t            };\n\t\n\t            var axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';\n\t\n\t            data.offsets.popper = Object.assign(popper, shiftOffsets[axis][shiftVariation]);\n\t        }\n\t\n\t        return data;\n\t    };\n\t\n\t    /**\n\t     * Modifier used to make sure the popper does not overflows from it's boundaries\n\t     * @method\n\t     * @memberof Popper.modifiers\n\t     * @argument {Object} data - The data object generated by `update` method\n\t     * @returns {Object} The data object, properly modified\n\t     */\n\t    Popper.prototype.modifiers.preventOverflow = function (data) {\n\t        var order = this._options.preventOverflowOrder;\n\t        var popper = getPopperClientRect(data.offsets.popper);\n\t\n\t        var check = {\n\t            left: function left() {\n\t                var left = popper.left;\n\t                if (popper.left < data.boundaries.left) {\n\t                    left = Math.max(popper.left, data.boundaries.left);\n\t                }\n\t                return { left: left };\n\t            },\n\t            right: function right() {\n\t                var left = popper.left;\n\t                if (popper.right > data.boundaries.right) {\n\t                    left = Math.min(popper.left, data.boundaries.right - popper.width);\n\t                }\n\t                return { left: left };\n\t            },\n\t            top: function top() {\n\t                var top = popper.top;\n\t                if (popper.top < data.boundaries.top) {\n\t                    top = Math.max(popper.top, data.boundaries.top);\n\t                }\n\t                return { top: top };\n\t            },\n\t            bottom: function bottom() {\n\t                var top = popper.top;\n\t                if (popper.bottom > data.boundaries.bottom) {\n\t                    top = Math.min(popper.top, data.boundaries.bottom - popper.height);\n\t                }\n\t                return { top: top };\n\t            }\n\t        };\n\t\n\t        order.forEach(function (direction) {\n\t            data.offsets.popper = Object.assign(popper, check[direction]());\n\t        });\n\t\n\t        return data;\n\t    };\n\t\n\t    /**\n\t     * Modifier used to make sure the popper is always near its reference\n\t     * @method\n\t     * @memberof Popper.modifiers\n\t     * @argument {Object} data - The data object generated by _update method\n\t     * @returns {Object} The data object, properly modified\n\t     */\n\t    Popper.prototype.modifiers.keepTogether = function (data) {\n\t        var popper = getPopperClientRect(data.offsets.popper);\n\t        var reference = data.offsets.reference;\n\t        var f = Math.floor;\n\t\n\t        if (popper.right < f(reference.left)) {\n\t            data.offsets.popper.left = f(reference.left) - popper.width;\n\t        }\n\t        if (popper.left > f(reference.right)) {\n\t            data.offsets.popper.left = f(reference.right);\n\t        }\n\t        if (popper.bottom < f(reference.top)) {\n\t            data.offsets.popper.top = f(reference.top) - popper.height;\n\t        }\n\t        if (popper.top > f(reference.bottom)) {\n\t            data.offsets.popper.top = f(reference.bottom);\n\t        }\n\t\n\t        return data;\n\t    };\n\t\n\t    /**\n\t     * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.\n\t     * Requires the `preventOverflow` modifier before it in order to work.\n\t     * **NOTE:** This modifier will run all its previous modifiers everytime it tries to flip the popper!\n\t     * @method\n\t     * @memberof Popper.modifiers\n\t     * @argument {Object} data - The data object generated by _update method\n\t     * @returns {Object} The data object, properly modified\n\t     */\n\t    Popper.prototype.modifiers.flip = function (data) {\n\t        // check if preventOverflow is in the list of modifiers before the flip modifier.\n\t        // otherwise flip would not work as expected.\n\t        if (!this.isModifierRequired(this.modifiers.flip, this.modifiers.preventOverflow)) {\n\t            console.warn('WARNING: preventOverflow modifier is required by flip modifier in order to work, be sure to include it before flip!');\n\t            return data;\n\t        }\n\t\n\t        if (data.flipped && data.placement === data._originalPlacement) {\n\t            // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n\t            return data;\n\t        }\n\t\n\t        var placement = data.placement.split('-')[0];\n\t        var placementOpposite = getOppositePlacement(placement);\n\t        var variation = data.placement.split('-')[1] || '';\n\t\n\t        var flipOrder = [];\n\t        if (this._options.flipBehavior === 'flip') {\n\t            flipOrder = [placement, placementOpposite];\n\t        } else {\n\t            flipOrder = this._options.flipBehavior;\n\t        }\n\t\n\t        flipOrder.forEach(function (step, index) {\n\t            if (placement !== step || flipOrder.length === index + 1) {\n\t                return;\n\t            }\n\t\n\t            placement = data.placement.split('-')[0];\n\t            placementOpposite = getOppositePlacement(placement);\n\t\n\t            var popperOffsets = getPopperClientRect(data.offsets.popper);\n\t\n\t            // this boolean is used to distinguish right and bottom from top and left\n\t            // they need different computations to get flipped\n\t            var a = ['right', 'bottom'].indexOf(placement) !== -1;\n\t\n\t            // using Math.floor because the reference offsets may contain decimals we are not going to consider here\n\t            if (a && Math.floor(data.offsets.reference[placement]) > Math.floor(popperOffsets[placementOpposite]) || !a && Math.floor(data.offsets.reference[placement]) < Math.floor(popperOffsets[placementOpposite])) {\n\t                // we'll use this boolean to detect any flip loop\n\t                data.flipped = true;\n\t                data.placement = flipOrder[index + 1];\n\t                if (variation) {\n\t                    data.placement += '-' + variation;\n\t                }\n\t                data.offsets.popper = this._getOffsets(this._popper, this._reference, data.placement).popper;\n\t\n\t                data = this.runModifiers(data, this._options.modifiers, this._flip);\n\t            }\n\t        }.bind(this));\n\t        return data;\n\t    };\n\t\n\t    /**\n\t     * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.\n\t     * The offsets will shift the popper on the side of its reference element.\n\t     * @method\n\t     * @memberof Popper.modifiers\n\t     * @argument {Object} data - The data object generated by _update method\n\t     * @returns {Object} The data object, properly modified\n\t     */\n\t    Popper.prototype.modifiers.offset = function (data) {\n\t        var offset = this._options.offset;\n\t        var popper = data.offsets.popper;\n\t\n\t        if (data.placement.indexOf('left') !== -1) {\n\t            popper.top -= offset;\n\t        } else if (data.placement.indexOf('right') !== -1) {\n\t            popper.top += offset;\n\t        } else if (data.placement.indexOf('top') !== -1) {\n\t            popper.left -= offset;\n\t        } else if (data.placement.indexOf('bottom') !== -1) {\n\t            popper.left += offset;\n\t        }\n\t        return data;\n\t    };\n\t\n\t    /**\n\t     * Modifier used to move the arrows on the edge of the popper to make sure them are always between the popper and the reference element\n\t     * It will use the CSS outer size of the arrow element to know how many pixels of conjuction are needed\n\t     * @method\n\t     * @memberof Popper.modifiers\n\t     * @argument {Object} data - The data object generated by _update method\n\t     * @returns {Object} The data object, properly modified\n\t     */\n\t    Popper.prototype.modifiers.arrow = function (data) {\n\t        var arrow = this._options.arrowElement;\n\t\n\t        // if the arrowElement is a string, suppose it's a CSS selector\n\t        if (typeof arrow === 'string') {\n\t            arrow = this._popper.querySelector(arrow);\n\t        }\n\t\n\t        // if arrow element is not found, don't run the modifier\n\t        if (!arrow) {\n\t            return data;\n\t        }\n\t\n\t        // the arrow element must be child of its popper\n\t        if (!this._popper.contains(arrow)) {\n\t            console.warn('WARNING: `arrowElement` must be child of its popper element!');\n\t            return data;\n\t        }\n\t\n\t        // arrow depends on keepTogether in order to work\n\t        if (!this.isModifierRequired(this.modifiers.arrow, this.modifiers.keepTogether)) {\n\t            console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');\n\t            return data;\n\t        }\n\t\n\t        var arrowStyle = {};\n\t        var placement = data.placement.split('-')[0];\n\t        var popper = getPopperClientRect(data.offsets.popper);\n\t        var reference = data.offsets.reference;\n\t        var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\t\n\t        var len = isVertical ? 'height' : 'width';\n\t        var side = isVertical ? 'top' : 'left';\n\t        var altSide = isVertical ? 'left' : 'top';\n\t        var opSide = isVertical ? 'bottom' : 'right';\n\t        var arrowSize = getOuterSizes(arrow)[len];\n\t\n\t        //\n\t        // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction\n\t        //\n\t\n\t        // top/left side\n\t        if (reference[opSide] - arrowSize < popper[side]) {\n\t            data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowSize);\n\t        }\n\t        // bottom/right side\n\t        if (reference[side] + arrowSize > popper[opSide]) {\n\t            data.offsets.popper[side] += reference[side] + arrowSize - popper[opSide];\n\t        }\n\t\n\t        // compute center of the popper\n\t        var center = reference[side] + reference[len] / 2 - arrowSize / 2;\n\t\n\t        var sideValue = center - popper[side];\n\t\n\t        // prevent arrow from being placed not contiguously to its popper\n\t        sideValue = Math.max(Math.min(popper[len] - arrowSize, sideValue), 0);\n\t        arrowStyle[side] = sideValue;\n\t        arrowStyle[altSide] = ''; // make sure to remove any old style from the arrow\n\t\n\t        data.offsets.arrow = arrowStyle;\n\t        data.arrowElement = arrow;\n\t\n\t        return data;\n\t    };\n\t\n\t    //\n\t    // Helpers\n\t    //\n\t\n\t    /**\n\t     * Get the outer sizes of the given element (offset size + margins)\n\t     * @function\n\t     * @ignore\n\t     * @argument {Element} element\n\t     * @returns {Object} object containing width and height properties\n\t     */\n\t    function getOuterSizes(element) {\n\t        // NOTE: 1 DOM access here\n\t        var _display = element.style.display,\n\t            _visibility = element.style.visibility;\n\t        element.style.display = 'block';element.style.visibility = 'hidden';\n\t        var calcWidthToForceRepaint = element.offsetWidth;\n\t\n\t        // original method\n\t        var styles = root.getComputedStyle(element);\n\t        var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n\t        var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n\t        var result = { width: element.offsetWidth + y, height: element.offsetHeight + x };\n\t\n\t        // reset element styles\n\t        element.style.display = _display;element.style.visibility = _visibility;\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * Get the opposite placement of the given one/\n\t     * @function\n\t     * @ignore\n\t     * @argument {String} placement\n\t     * @returns {String} flipped placement\n\t     */\n\t    function getOppositePlacement(placement) {\n\t        var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n\t        return placement.replace(/left|right|bottom|top/g, function (matched) {\n\t            return hash[matched];\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Given the popper offsets, generate an output similar to getBoundingClientRect\n\t     * @function\n\t     * @ignore\n\t     * @argument {Object} popperOffsets\n\t     * @returns {Object} ClientRect like output\n\t     */\n\t    function getPopperClientRect(popperOffsets) {\n\t        var offsets = Object.assign({}, popperOffsets);\n\t        offsets.right = offsets.left + offsets.width;\n\t        offsets.bottom = offsets.top + offsets.height;\n\t        return offsets;\n\t    }\n\t\n\t    /**\n\t     * Given an array and the key to find, returns its index\n\t     * @function\n\t     * @ignore\n\t     * @argument {Array} arr\n\t     * @argument keyToFind\n\t     * @returns index or null\n\t     */\n\t    function getArrayKeyIndex(arr, keyToFind) {\n\t        var i = 0,\n\t            key;\n\t        for (key in arr) {\n\t            if (arr[key] === keyToFind) {\n\t                return i;\n\t            }\n\t            i++;\n\t        }\n\t        return null;\n\t    }\n\t\n\t    /**\n\t     * Get CSS computed property of the given element\n\t     * @function\n\t     * @ignore\n\t     * @argument {Eement} element\n\t     * @argument {String} property\n\t     */\n\t    function getStyleComputedProperty(element, property) {\n\t        // NOTE: 1 DOM access here\n\t        var css = root.getComputedStyle(element, null);\n\t        return css[property];\n\t    }\n\t\n\t    /**\n\t     * Returns the offset parent of the given element\n\t     * @function\n\t     * @ignore\n\t     * @argument {Element} element\n\t     * @returns {Element} offset parent\n\t     */\n\t    function getOffsetParent(element) {\n\t        // NOTE: 1 DOM access here\n\t        var offsetParent = element.offsetParent;\n\t        return offsetParent === root.document.body || !offsetParent ? root.document.documentElement : offsetParent;\n\t    }\n\t\n\t    /**\n\t     * Returns the scrolling parent of the given element\n\t     * @function\n\t     * @ignore\n\t     * @argument {Element} element\n\t     * @returns {Element} offset parent\n\t     */\n\t    function getScrollParent(element) {\n\t        var parent = element.parentNode;\n\t\n\t        if (!parent) {\n\t            return element;\n\t        }\n\t\n\t        if (parent === root.document) {\n\t            // Firefox puts the scrollTOp value on `documentElement` instead of `body`, we then check which of them is\n\t            // greater than 0 and return the proper element\n\t            if (root.document.body.scrollTop) {\n\t                return root.document.body;\n\t            } else {\n\t                return root.document.documentElement;\n\t            }\n\t        }\n\t\n\t        // Firefox want us to check `-x` and `-y` variations as well\n\t        if (['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-x')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-y')) !== -1) {\n\t            // If the detected scrollParent is body, we perform an additional check on its parentNode\n\t            // in this way we'll get body if the browser is Chrome-ish, or documentElement otherwise\n\t            // fixes issue #65\n\t            return parent;\n\t        }\n\t        return getScrollParent(element.parentNode);\n\t    }\n\t\n\t    /**\n\t     * Check if the given element is fixed or is inside a fixed parent\n\t     * @function\n\t     * @ignore\n\t     * @argument {Element} element\n\t     * @argument {Element} customContainer\n\t     * @returns {Boolean} answer to \"isFixed?\"\n\t     */\n\t    function isFixed(element) {\n\t        if (element === root.document.body) {\n\t            return false;\n\t        }\n\t        if (getStyleComputedProperty(element, 'position') === 'fixed') {\n\t            return true;\n\t        }\n\t        return element.parentNode ? isFixed(element.parentNode) : element;\n\t    }\n\t\n\t    /**\n\t     * Set the style to the given popper\n\t     * @function\n\t     * @ignore\n\t     * @argument {Element} element - Element to apply the style to\n\t     * @argument {Object} styles - Object with a list of properties and values which will be applied to the element\n\t     */\n\t    function setStyle(element, styles) {\n\t        function is_numeric(n) {\n\t            return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n\t        }\n\t        Object.keys(styles).forEach(function (prop) {\n\t            var unit = '';\n\t            // add unit if the value is numeric and is one of the following\n\t            if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && is_numeric(styles[prop])) {\n\t                unit = 'px';\n\t            }\n\t            element.style[prop] = styles[prop] + unit;\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Check if the given variable is a function\n\t     * @function\n\t     * @ignore\n\t     * @argument {Element} element - Element to check\n\t     * @returns {Boolean} answer to: is a function?\n\t     */\n\t    function isFunction(functionToCheck) {\n\t        var getType = {};\n\t        return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n\t    }\n\t\n\t    /**\n\t     * Get the position of the given element, relative to its offset parent\n\t     * @function\n\t     * @ignore\n\t     * @param {Element} element\n\t     * @return {Object} position - Coordinates of the element and its `scrollTop`\n\t     */\n\t    function getOffsetRect(element) {\n\t        var elementRect = {\n\t            width: element.offsetWidth,\n\t            height: element.offsetHeight,\n\t            left: element.offsetLeft,\n\t            top: element.offsetTop\n\t        };\n\t\n\t        elementRect.right = elementRect.left + elementRect.width;\n\t        elementRect.bottom = elementRect.top + elementRect.height;\n\t\n\t        // position\n\t        return elementRect;\n\t    }\n\t\n\t    /**\n\t     * Get bounding client rect of given element\n\t     * @function\n\t     * @ignore\n\t     * @param {HTMLElement} element\n\t     * @return {Object} client rect\n\t     */\n\t    function getBoundingClientRect(element) {\n\t        var rect = element.getBoundingClientRect();\n\t\n\t        // whether the IE version is lower than 11\n\t        var isIE = navigator.userAgent.indexOf(\"MSIE\") != -1;\n\t\n\t        // fix ie document bouding top always 0 bug\n\t        var rectTop = isIE && element.tagName === 'HTML' ? -element.scrollTop : rect.top;\n\t\n\t        return {\n\t            left: rect.left,\n\t            top: rectTop,\n\t            right: rect.right,\n\t            bottom: rect.bottom,\n\t            width: rect.right - rect.left,\n\t            height: rect.bottom - rectTop\n\t        };\n\t    }\n\t\n\t    /**\n\t     * Given an element and one of its parents, return the offset\n\t     * @function\n\t     * @ignore\n\t     * @param {HTMLElement} element\n\t     * @param {HTMLElement} parent\n\t     * @return {Object} rect\n\t     */\n\t    function getOffsetRectRelativeToCustomParent(element, parent, fixed) {\n\t        var elementRect = getBoundingClientRect(element);\n\t        var parentRect = getBoundingClientRect(parent);\n\t\n\t        if (fixed) {\n\t            var scrollParent = getScrollParent(parent);\n\t            parentRect.top += scrollParent.scrollTop;\n\t            parentRect.bottom += scrollParent.scrollTop;\n\t            parentRect.left += scrollParent.scrollLeft;\n\t            parentRect.right += scrollParent.scrollLeft;\n\t        }\n\t\n\t        var rect = {\n\t            top: elementRect.top - parentRect.top,\n\t            left: elementRect.left - parentRect.left,\n\t            bottom: elementRect.top - parentRect.top + elementRect.height,\n\t            right: elementRect.left - parentRect.left + elementRect.width,\n\t            width: elementRect.width,\n\t            height: elementRect.height\n\t        };\n\t        return rect;\n\t    }\n\t\n\t    /**\n\t     * Get the prefixed supported property name\n\t     * @function\n\t     * @ignore\n\t     * @argument {String} property (camelCase)\n\t     * @returns {String} prefixed property (camelCase)\n\t     */\n\t    function getSupportedPropertyName(property) {\n\t        var prefixes = ['', 'ms', 'webkit', 'moz', 'o'];\n\t\n\t        for (var i = 0; i < prefixes.length; i++) {\n\t            var toCheck = prefixes[i] ? prefixes[i] + property.charAt(0).toUpperCase() + property.slice(1) : property;\n\t            if (typeof root.document.body.style[toCheck] !== 'undefined') {\n\t                return toCheck;\n\t            }\n\t        }\n\t        return null;\n\t    }\n\t\n\t    /**\n\t     * The Object.assign() method is used to copy the values of all enumerable own properties from one or more source\n\t     * objects to a target object. It will return the target object.\n\t     * This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway\n\t     * Source: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\t     * @function\n\t     * @ignore\n\t     */\n\t    if (!Object.assign) {\n\t        Object.defineProperty(Object, 'assign', {\n\t            enumerable: false,\n\t            configurable: true,\n\t            writable: true,\n\t            value: function value(target) {\n\t                if (target === undefined || target === null) {\n\t                    throw new TypeError('Cannot convert first argument to object');\n\t                }\n\t\n\t                var to = Object(target);\n\t                for (var i = 1; i < arguments.length; i++) {\n\t                    var nextSource = arguments[i];\n\t                    if (nextSource === undefined || nextSource === null) {\n\t                        continue;\n\t                    }\n\t                    nextSource = Object(nextSource);\n\t\n\t                    var keysArray = Object.keys(nextSource);\n\t                    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n\t                        var nextKey = keysArray[nextIndex];\n\t                        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n\t                        if (desc !== undefined && desc.enumerable) {\n\t                            to[nextKey] = nextSource[nextKey];\n\t                        }\n\t                    }\n\t                }\n\t                return to;\n\t            }\n\t        });\n\t    }\n\t\n\t    return Popper;\n\t});\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _popper = __webpack_require__(50);\n\t\n\tvar _popper2 = _interopRequireDefault(_popper);\n\t\n\tvar _vuePopup = __webpack_require__(63);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * @param {HTMLElement} [reference=$refs.reference] - The reference element used to position the popper.\n\t * @param {HTMLElement} [popper=$refs.popper] - The HTML element used as popper, or a configuration used to generate the popper.\n\t * @param {String} [placement=button] - Placement of the popper accepted values: top(-start, -end), right(-start, -end), bottom(-start, -right), left(-start, -end)\n\t * @param {Number} [offset=0] - Amount of pixels the popper will be shifted (can be negative).\n\t * @param {Boolean} [visible=false] Visibility of the popup element.\n\t * @param {Boolean} [visible-arrow=false] Visibility of the arrow, no style.\n\t */\n\texports.default = {\n\t  props: {\n\t    placement: {\n\t      type: String,\n\t      default: 'bottom'\n\t    },\n\t    boundariesPadding: {\n\t      type: Number,\n\t      default: 5\n\t    },\n\t    reference: {},\n\t    popper: {},\n\t    offset: {\n\t      default: 0\n\t    },\n\t    value: Boolean,\n\t    visibleArrow: Boolean,\n\t    transition: String,\n\t    appendToBody: {\n\t      type: Boolean,\n\t      default: true\n\t    },\n\t    options: {\n\t      type: Object,\n\t      default: function _default() {\n\t        return {\n\t          gpuAcceleration: false\n\t        };\n\t      }\n\t    }\n\t  },\n\t\n\t  data: function data() {\n\t    return {\n\t      showPopper: false\n\t    };\n\t  },\n\t\n\t\n\t  watch: {\n\t    value: {\n\t      immediate: true,\n\t      handler: function handler(val) {\n\t        this.showPopper = val;\n\t        this.$emit('input', val);\n\t      }\n\t    },\n\t\n\t    showPopper: function showPopper(val) {\n\t      val ? this.updatePopper() : this.destroyPopper();\n\t      this.$emit('input', val);\n\t    }\n\t  },\n\t\n\t  methods: {\n\t    createPopper: function createPopper() {\n\t      var _this = this;\n\t\n\t      if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(this.placement)) {\n\t        return;\n\t      }\n\t\n\t      var options = this.options;\n\t      var popper = this.popperElm = this.popperElm || this.popper || this.$refs.popper;\n\t      var reference = this.referenceElm = this.referenceElm || this.reference || this.$refs.reference;\n\t\n\t      if (!reference && this.$slots.reference && this.$slots.reference[0]) {\n\t        reference = this.referenceElm = this.$slots.reference[0].elm;\n\t      }\n\t      if (!popper || !reference) return;\n\t      if (this.visibleArrow) this.appendArrow(popper);\n\t      if (this.appendToBody) document.body.appendChild(this.popperElm);\n\t      if (this.popperJS && this.popperJS.destroy) {\n\t        this.popperJS.destroy();\n\t      }\n\t\n\t      options.placement = this.placement;\n\t      options.offset = this.offset;\n\t      this.popperJS = new _popper2.default(reference, popper, options);\n\t      this.popperJS.onCreate(function (_) {\n\t        _this.$emit('created', _this);\n\t        _this.resetTransformOrigin();\n\t        _this.$nextTick(_this.updatePopper);\n\t      });\n\t      this.popperJS._popper.style.zIndex = _vuePopup.PopupManager.nextZIndex();\n\t    },\n\t    updatePopper: function updatePopper() {\n\t      this.popperJS ? this.popperJS.update() : this.createPopper();\n\t    },\n\t    doDestroy: function doDestroy() {\n\t      /* istanbul ignore if */\n\t      if (this.showPopper || !this.popperJS) return;\n\t      this.popperJS.destroy();\n\t      this.popperJS = null;\n\t    },\n\t    destroyPopper: function destroyPopper() {\n\t      if (this.popperJS) {\n\t        this.resetTransformOrigin();\n\t      }\n\t    },\n\t    resetTransformOrigin: function resetTransformOrigin() {\n\t      var placementMap = { top: 'bottom', bottom: 'top', left: 'right', right: 'left' };\n\t      var placement = this.popperJS._popper.getAttribute('x-placement').split('-')[0];\n\t      var origin = placementMap[placement];\n\t      this.popperJS._popper.style.transformOrigin = ['top', 'bottom'].indexOf(placement) > -1 ? 'center ' + origin : origin + ' center';\n\t    },\n\t    appendArrow: function appendArrow(element) {\n\t      var hash = void 0;\n\t      if (this.appended) {\n\t        return;\n\t      }\n\t\n\t      this.appended = true;\n\t\n\t      for (var item in element.attributes) {\n\t        if (/^_v-/.test(element.attributes[item].name)) {\n\t          hash = element.attributes[item].name;\n\t          break;\n\t        }\n\t      }\n\t\n\t      var arrow = document.createElement('div');\n\t\n\t      if (hash) {\n\t        arrow.setAttribute(hash, '');\n\t      }\n\t      arrow.setAttribute('x-arrow', '');\n\t      arrow.className = 'popper__arrow';\n\t      element.appendChild(arrow);\n\t    }\n\t  },\n\t\n\t  beforeDestroy: function beforeDestroy() {\n\t    this.doDestroy();\n\t    this.popperElm && this.popperElm.parentNode === document.body && document.body.removeChild(this.popperElm);\n\t  },\n\t\n\t\n\t  // call destroy in keep-alive mode\n\t  deactivated: function deactivated() {\n\t    this.$options.beforeDestroy[0].call(this);\n\t  }\n\t};\n\n/***/ },\n/* 52 */,\n/* 53 */\n/***/ function(module, exports) {\n\n\t// https://github.com/mziccard/node-timsort\n\t\n\t    var DEFAULT_MIN_MERGE = 32;\n\t\n\t    var DEFAULT_MIN_GALLOPING = 7;\n\t\n\t    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t\n\t    function minRunLength(n) {\n\t        var r = 0;\n\t\n\t        while (n >= DEFAULT_MIN_MERGE) {\n\t            r |= n & 1;\n\t            n >>= 1;\n\t        }\n\t\n\t        return n + r;\n\t    }\n\t\n\t    function makeAscendingRun(array, lo, hi, compare) {\n\t        var runHi = lo + 1;\n\t\n\t        if (runHi === hi) {\n\t            return 1;\n\t        }\n\t\n\t        if (compare(array[runHi++], array[lo]) < 0) {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t                runHi++;\n\t            }\n\t\n\t            reverseRun(array, lo, runHi);\n\t        }\n\t        else {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t                runHi++;\n\t            }\n\t        }\n\t\n\t        return runHi - lo;\n\t    }\n\t\n\t    function reverseRun(array, lo, hi) {\n\t        hi--;\n\t\n\t        while (lo < hi) {\n\t            var t = array[lo];\n\t            array[lo++] = array[hi];\n\t            array[hi--] = t;\n\t        }\n\t    }\n\t\n\t    function binaryInsertionSort(array, lo, hi, start, compare) {\n\t        if (start === lo) {\n\t            start++;\n\t        }\n\t\n\t        for (; start < hi; start++) {\n\t            var pivot = array[start];\n\t\n\t            var left = lo;\n\t            var right = start;\n\t            var mid;\n\t\n\t            while (left < right) {\n\t                mid = left + right >>> 1;\n\t\n\t                if (compare(pivot, array[mid]) < 0) {\n\t                    right = mid;\n\t                }\n\t                else {\n\t                    left = mid + 1;\n\t                }\n\t            }\n\t\n\t            var n = start - left;\n\t\n\t            switch (n) {\n\t                case 3:\n\t                    array[left + 3] = array[left + 2];\n\t\n\t                case 2:\n\t                    array[left + 2] = array[left + 1];\n\t\n\t                case 1:\n\t                    array[left + 1] = array[left];\n\t                    break;\n\t                default:\n\t                    while (n > 0) {\n\t                        array[left + n] = array[left + n - 1];\n\t                        n--;\n\t                    }\n\t            }\n\t\n\t            array[left] = pivot;\n\t        }\n\t    }\n\t\n\t    function gallopLeft(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) > 0) {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t        else {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) > 0) {\n\t                lastOffset = m + 1;\n\t            }\n\t            else {\n\t                offset = m;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t\n\t    function gallopRight(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) < 0) {\n\t            maxOffset = hint + 1;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t        else {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t\n\t        lastOffset++;\n\t\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) < 0) {\n\t                offset = m;\n\t            }\n\t            else {\n\t                lastOffset = m + 1;\n\t            }\n\t        }\n\t\n\t        return offset;\n\t    }\n\t\n\t    function TimSort(array, compare) {\n\t        var minGallop = DEFAULT_MIN_GALLOPING;\n\t        var length = 0;\n\t        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t        var stackLength = 0;\n\t        var runStart;\n\t        var runLength;\n\t        var stackSize = 0;\n\t\n\t        length = array.length;\n\t\n\t        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t            tmpStorageLength = length >>> 1;\n\t        }\n\t\n\t        var tmp = [];\n\t\n\t        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t\n\t        runStart = [];\n\t        runLength = [];\n\t\n\t        function pushRun(_runStart, _runLength) {\n\t            runStart[stackSize] = _runStart;\n\t            runLength[stackSize] = _runLength;\n\t            stackSize += 1;\n\t        }\n\t\n\t        function mergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t                    if (runLength[n - 1] < runLength[n + 1]) {\n\t                        n--;\n\t                    }\n\t                }\n\t                else if (runLength[n] > runLength[n + 1]) {\n\t                    break;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function forceMergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t                    n--;\n\t                }\n\t\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function mergeAt(i) {\n\t            var start1 = runStart[i];\n\t            var length1 = runLength[i];\n\t            var start2 = runStart[i + 1];\n\t            var length2 = runLength[i + 1];\n\t\n\t            runLength[i] = length1 + length2;\n\t\n\t            if (i === stackSize - 3) {\n\t                runStart[i + 1] = runStart[i + 2];\n\t                runLength[i + 1] = runLength[i + 2];\n\t            }\n\t\n\t            stackSize--;\n\t\n\t            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t            start1 += k;\n\t            length1 -= k;\n\t\n\t            if (length1 === 0) {\n\t                return;\n\t            }\n\t\n\t            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t\n\t            if (length2 === 0) {\n\t                return;\n\t            }\n\t\n\t            if (length1 <= length2) {\n\t                mergeLow(start1, length1, start2, length2);\n\t            }\n\t            else {\n\t                mergeHigh(start1, length1, start2, length2);\n\t            }\n\t        }\n\t\n\t        function mergeLow(start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length1; i++) {\n\t                tmp[i] = array[start1 + i];\n\t            }\n\t\n\t            var cursor1 = 0;\n\t            var cursor2 = start2;\n\t            var dest = start1;\n\t\n\t            array[dest++] = array[cursor2++];\n\t\n\t            if (--length2 === 0) {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t                return;\n\t            }\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t            var count1, count2, exit;\n\t\n\t            while (1) {\n\t                count1 = 0;\n\t                count2 = 0;\n\t                exit = false;\n\t\n\t                do {\n\t                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t                        array[dest++] = array[cursor2++];\n\t                        count2++;\n\t                        count1 = 0;\n\t\n\t                        if (--length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest++] = tmp[cursor1++];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        for (i = 0; i < count1; i++) {\n\t                            array[dest + i] = tmp[cursor1 + i];\n\t                        }\n\t\n\t                        dest += count1;\n\t                        cursor1 += count1;\n\t                        length1 -= count1;\n\t                        if (length1 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest++] = array[cursor2++];\n\t\n\t                    if (--length2 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[dest + i] = array[cursor2 + i];\n\t                        }\n\t\n\t                        dest += count2;\n\t                        cursor2 += count2;\n\t                        length2 -= count2;\n\t\n\t                        if (length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = tmp[cursor1++];\n\t\n\t                    if (--length1 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            minGallop < 1 && (minGallop = 1);\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t            }\n\t            else if (length1 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeLow preconditions were not respected');\n\t            }\n\t            else {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t            }\n\t        }\n\t\n\t        function mergeHigh (start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length2; i++) {\n\t                tmp[i] = array[start2 + i];\n\t            }\n\t\n\t            var cursor1 = start1 + length1 - 1;\n\t            var cursor2 = length2 - 1;\n\t            var dest = start2 + length2 - 1;\n\t            var customCursor = 0;\n\t            var customDest = 0;\n\t\n\t            array[dest--] = array[cursor1--];\n\t\n\t            if (--length1 === 0) {\n\t                customCursor = dest - (length2 - 1);\n\t\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t\n\t            while (true) {\n\t                var count1 = 0;\n\t                var count2 = 0;\n\t                var exit = false;\n\t\n\t                do {\n\t                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t                        array[dest--] = array[cursor1--];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest--] = tmp[cursor2--];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        dest -= count1;\n\t                        cursor1 -= count1;\n\t                        length1 -= count1;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor1 + 1;\n\t\n\t                        for (i = count1 - 1; i >= 0; i--) {\n\t                            array[customDest + i] = array[customCursor + i];\n\t                        }\n\t\n\t                        if (length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = tmp[cursor2--];\n\t\n\t                    if (--length2 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        dest -= count2;\n\t                        cursor2 -= count2;\n\t                        length2 -= count2;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor2 + 1;\n\t\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[customDest + i] = tmp[customCursor + i];\n\t                        }\n\t\n\t                        if (length2 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = array[cursor1--];\n\t\n\t                    if (--length1 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            if (minGallop < 1) {\n\t                minGallop = 1;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t            }\n\t            else if (length2 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeHigh preconditions were not respected');\n\t            }\n\t            else {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t            }\n\t        }\n\t\n\t        this.mergeRuns = mergeRuns;\n\t        this.forceMergeRuns = forceMergeRuns;\n\t        this.pushRun = pushRun;\n\t    }\n\t\n\t    function sort(array, compare, lo, hi) {\n\t        if (!lo) {\n\t            lo = 0;\n\t        }\n\t        if (!hi) {\n\t            hi = array.length;\n\t        }\n\t\n\t        var remaining = hi - lo;\n\t\n\t        if (remaining < 2) {\n\t            return;\n\t        }\n\t\n\t        var runLength = 0;\n\t\n\t        if (remaining < DEFAULT_MIN_MERGE) {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t            return;\n\t        }\n\t\n\t        var ts = new TimSort(array, compare);\n\t\n\t        var minRun = minRunLength(remaining);\n\t\n\t        do {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            if (runLength < minRun) {\n\t                var force = remaining;\n\t                if (force > minRun) {\n\t                    force = minRun;\n\t                }\n\t\n\t                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t                runLength = force;\n\t            }\n\t\n\t            ts.pushRun(lo, runLength);\n\t            ts.mergeRuns();\n\t\n\t            remaining -= runLength;\n\t            lo += runLength;\n\t        } while (remaining !== 0);\n\t\n\t        ts.forceMergeRuns();\n\t    }\n\t\n\t    module.exports = sort;\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 可绘制的图形基类\n\t * Base class of all displayable graphic objects\n\t * @module zrender/graphic/Displayable\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var Style = __webpack_require__(81);\n\t\n\t    var Element = __webpack_require__(73);\n\t    var RectText = __webpack_require__(180);\n\t    // var Stateful = require('./mixin/Stateful');\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Displayable\n\t     * @extends module:zrender/Element\n\t     * @extends module:zrender/graphic/mixin/RectText\n\t     */\n\t    function Displayable(opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        // Extend properties\n\t        for (var name in opts) {\n\t            if (\n\t                opts.hasOwnProperty(name) &&\n\t                name !== 'style'\n\t            ) {\n\t                this[name] = opts[name];\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/graphic/Style}\n\t         */\n\t        this.style = new Style(opts.style);\n\t\n\t        this._rect = null;\n\t        // Shapes for cascade clipping.\n\t        this.__clipPaths = [];\n\t\n\t        // FIXME Stateful must be mixined after style is setted\n\t        // Stateful.call(this, opts);\n\t    }\n\t\n\t    Displayable.prototype = {\n\t\n\t        constructor: Displayable,\n\t\n\t        type: 'displayable',\n\t\n\t        /**\n\t         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n\t         * Dirty flag. From which painter will determine if this displayable object needs brush\n\t         * @name module:zrender/graphic/Displayable#__dirty\n\t         * @type {boolean}\n\t         */\n\t        __dirty: true,\n\t\n\t        /**\n\t         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n\t         * If ignore drawing of the displayable object. Mouse event will still be triggered\n\t         * @name module:/zrender/graphic/Displayable#invisible\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        invisible: false,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z: 0,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z2: 0,\n\t\n\t        /**\n\t         * z层level，决定绘画在哪层canvas中\n\t         * @name module:/zrender/graphic/Displayable#zlevel\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        zlevel: 0,\n\t\n\t        /**\n\t         * 是否可拖拽\n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        draggable: false,\n\t\n\t        /**\n\t         * 是否正在拖拽\n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        dragging: false,\n\t\n\t        /**\n\t         * 是否相应鼠标事件\n\t         * @name module:/zrender/graphic/Displayable#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * If enable culling\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        culling: false,\n\t\n\t        /**\n\t         * Mouse cursor when hovered\n\t         * @name module:/zrender/graphic/Displayable#cursor\n\t         * @type {string}\n\t         */\n\t        cursor: 'pointer',\n\t\n\t        /**\n\t         * If hover area is bounding rect\n\t         * @name module:/zrender/graphic/Displayable#rectHover\n\t         * @type {string}\n\t         */\n\t        rectHover: false,\n\t\n\t        /**\n\t         * Render the element progressively when the value >= 0,\n\t         * usefull for large data.\n\t         * @type {number}\n\t         */\n\t        progressive: -1,\n\t\n\t        beforeBrush: function (ctx) {},\n\t\n\t        afterBrush: function (ctx) {},\n\t\n\t        /**\n\t         * 图形绘制方法\n\t         * @param {Canvas2DRenderingContext} ctx\n\t         */\n\t        // Interface\n\t        brush: function (ctx, prevEl) {},\n\t\n\t        /**\n\t         * 获取最小包围盒\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        // Interface\n\t        getBoundingRect: function () {},\n\t\n\t        /**\n\t         * 判断坐标 x, y 是否在图形上\n\t         * If displayable element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        contain: function (x, y) {\n\t            return this.rectContain(x, y);\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            cb.call(context, this);\n\t        },\n\t\n\t        /**\n\t         * 判断坐标 x, y 是否在图形的包围盒上\n\t         * If bounding rect of element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        rectContain: function (x, y) {\n\t            var coord = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            return rect.contain(coord[0], coord[1]);\n\t        },\n\t\n\t        /**\n\t         * 标记图形元素为脏，并且在下一帧重绘\n\t         * Mark displayable element dirty and refresh next frame\n\t         */\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t\n\t            this._rect = null;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * 图形是否会触发事件\n\t         * If displayable object binded any event\n\t         * @return {boolean}\n\t         */\n\t        // TODO, 通过 bind 绑定的事件\n\t        // isSilent: function () {\n\t        //     return !(\n\t        //         this.hoverable || this.draggable\n\t        //         || this.onmousemove || this.onmouseover || this.onmouseout\n\t        //         || this.onmousedown || this.onmouseup || this.onclick\n\t        //         || this.ondragenter || this.ondragover || this.ondragleave\n\t        //         || this.ondrop\n\t        //     );\n\t        // },\n\t        /**\n\t         * Alias for animate('style')\n\t         * @param {boolean} loop\n\t         */\n\t        animateStyle: function (loop) {\n\t            return this.animate('style', loop);\n\t        },\n\t\n\t        attrKV: function (key, value) {\n\t            if (key !== 'style') {\n\t                Element.prototype.attrKV.call(this, key, value);\n\t            }\n\t            else {\n\t                this.style.set(value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setStyle: function (key, value) {\n\t            this.style.set(key, value);\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Use given style object\n\t         * @param  {Object} obj\n\t         */\n\t        useStyle: function (obj) {\n\t            this.style = new Style(obj);\n\t            this.dirty(false);\n\t            return this;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Displayable, Element);\n\t\n\t    zrUtil.mixin(Displayable, RectText);\n\t    // zrUtil.mixin(Displayable, Stateful);\n\t\n\t    module.exports = Displayable;\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    /**\n\t     * @param {Array.<Object>} colorStops\n\t     */\n\t    var Gradient = function (colorStops) {\n\t\n\t        this.colorStops = colorStops || [];\n\t    };\n\t\n\t    Gradient.prototype = {\n\t\n\t        constructor: Gradient,\n\t\n\t        addColorStop: function (offset, color) {\n\t            this.colorStops.push({\n\t\n\t                offset: offset,\n\t\n\t                color: color\n\t            });\n\t        }\n\t    };\n\t\n\t    module.exports = Gradient;\n\n\n/***/ },\n/* 56 */,\n/* 57 */,\n/* 58 */,\n/* 59 */,\n/* 60 */,\n/* 61 */,\n/* 62 */,\n/* 63 */,\n/* 64 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar updateStatusIconMap = {\n\t  '已更新': 'icon-success',\n\t  '更新中': 'icon-wait',\n\t  '待更新': 'icon-wait ignore-status',\n\t  '异常': 'icon-wait ignore-status'\n\t};\n\t\n\tvar excuteStatusIconMap = {\n\t  '已执行': 'icon-success',\n\t  '待执行': 'icon-wait',\n\t  '不可执行': 'icon-wait ignore-status',\n\t  '已过期': 'icon-wait ignore-status'\n\t};\n\t\n\texports.default = {\n\t  filters: {\n\t    updateStatusIcon: function updateStatusIcon(value) {\n\t      return updateStatusIconMap[value] || '';\n\t    },\n\t    excuteStatusIcon: function excuteStatusIcon(value) {\n\t      return excuteStatusIconMap[value] || '';\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 65 */,\n/* 66 */,\n/* 67 */,\n/* 68 */,\n/* 69 */,\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    /**\n\t     * Interface of Coordinate System Class\n\t     *\n\t     * create:\n\t     *     @param {module:echarts/model/Global} ecModel\n\t     *     @param {module:echarts/ExtensionAPI} api\n\t     *     @return {Object} coordinate system instance\n\t     *\n\t     * update:\n\t     *     @param {module:echarts/model/Global} ecModel\n\t     *     @param {module:echarts/ExtensionAPI} api\n\t     *\n\t     * convertToPixel:\n\t     * convertFromPixel:\n\t     *     These two methods is also responsible for determine whether this\n\t     *     coodinate system is applicable to the given `finder`.\n\t     *     Each coordinate system will be tried, util one returns none\n\t     *     null/undefined value.\n\t     *     @param {module:echarts/model/Global} ecModel\n\t     *     @param {Object} finder\n\t     *     @param {Array|number} value\n\t     *     @return {Array|number} convert result.\n\t     *\n\t     * containPoint:\n\t     *     @param {Array.<number>} point In pixel coordinate system.\n\t     *     @return {boolean}\n\t     */\n\t\n\t    var coordinateSystemCreators = {};\n\t\n\t    function CoordinateSystemManager() {\n\t\n\t        this._coordinateSystems = [];\n\t    }\n\t\n\t    CoordinateSystemManager.prototype = {\n\t\n\t        constructor: CoordinateSystemManager,\n\t\n\t        create: function (ecModel, api) {\n\t            var coordinateSystems = [];\n\t            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n\t                var list = creater.create(ecModel, api);\n\t                coordinateSystems = coordinateSystems.concat(list || []);\n\t            });\n\t\n\t            this._coordinateSystems = coordinateSystems;\n\t        },\n\t\n\t        update: function (ecModel, api) {\n\t            zrUtil.each(this._coordinateSystems, function (coordSys) {\n\t                // FIXME MUST have\n\t                coordSys.update && coordSys.update(ecModel, api);\n\t            });\n\t        },\n\t\n\t        getCoordinateSystems: function () {\n\t            return this._coordinateSystems.slice();\n\t        }\n\t    };\n\t\n\t    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n\t        coordinateSystemCreators[type] = coordinateSystemCreator;\n\t    };\n\t\n\t    CoordinateSystemManager.get = function (type) {\n\t        return coordinateSystemCreators[type];\n\t    };\n\t\n\t    module.exports = CoordinateSystemManager;\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * List for data storage\n\t * @module echarts/data/List\n\t */\n\t\n\t\n\t    var UNDEFINED = 'undefined';\n\t    var globalObj = typeof window === 'undefined' ? global : window;\n\t    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n\t        ? Array : globalObj.Float64Array;\n\t    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n\t        ? Array : globalObj.Int32Array;\n\t\n\t    var dataCtors = {\n\t        'float': Float64Array,\n\t        'int': Int32Array,\n\t        // Ordinal data type can be string or int\n\t        'ordinal': Array,\n\t        'number': Array,\n\t        'time': Array\n\t    };\n\t\n\t    var Model = __webpack_require__(15);\n\t    var DataDiffer = __webpack_require__(120);\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var modelUtil = __webpack_require__(11);\n\t    var isObject = zrUtil.isObject;\n\t\n\t    var TRANSFERABLE_PROPERTIES = [\n\t        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n\t    ];\n\t\n\t    var transferProperties = function (a, b) {\n\t        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n\t            if (b.hasOwnProperty(propName)) {\n\t                a[propName] = b[propName];\n\t            }\n\t        });\n\t\n\t        a.__wrappedMethods = b.__wrappedMethods;\n\t    };\n\t\n\t    /**\n\t     * @constructor\n\t     * @alias module:echarts/data/List\n\t     *\n\t     * @param {Array.<string>} dimensions\n\t     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n\t     * @param {module:echarts/model/Model} hostModel\n\t     */\n\t    var List = function (dimensions, hostModel) {\n\t\n\t        dimensions = dimensions || ['x', 'y'];\n\t\n\t        var dimensionInfos = {};\n\t        var dimensionNames = [];\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimensionName;\n\t            var dimensionInfo = {};\n\t            if (typeof dimensions[i] === 'string') {\n\t                dimensionName = dimensions[i];\n\t                dimensionInfo = {\n\t                    name: dimensionName,\n\t                    stackable: false,\n\t                    // Type can be 'float', 'int', 'number'\n\t                    // Default is number, Precision of float may not enough\n\t                    type: 'number'\n\t                };\n\t            }\n\t            else {\n\t                dimensionInfo = dimensions[i];\n\t                dimensionName = dimensionInfo.name;\n\t                dimensionInfo.type = dimensionInfo.type || 'number';\n\t            }\n\t            dimensionNames.push(dimensionName);\n\t            dimensionInfos[dimensionName] = dimensionInfo;\n\t        }\n\t        /**\n\t         * @readOnly\n\t         * @type {Array.<string>}\n\t         */\n\t        this.dimensions = dimensionNames;\n\t\n\t        /**\n\t         * Infomation of each data dimension, like data type.\n\t         * @type {Object}\n\t         */\n\t        this._dimensionInfos = dimensionInfos;\n\t\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.hostModel = hostModel;\n\t\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.dataType;\n\t\n\t        /**\n\t         * Indices stores the indices of data subset after filtered.\n\t         * This data subset will be used in chart.\n\t         * @type {Array.<number>}\n\t         * @readOnly\n\t         */\n\t        this.indices = [];\n\t\n\t        /**\n\t         * Data storage\n\t         * @type {Object.<key, TypedArray|Array>}\n\t         * @private\n\t         */\n\t        this._storage = {};\n\t\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._nameList = [];\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._idList = [];\n\t        /**\n\t         * Models of data option is stored sparse for optimizing memory cost\n\t         * @type {Array.<module:echarts/model/Model>}\n\t         * @private\n\t         */\n\t        this._optionModels = [];\n\t\n\t        /**\n\t         * @param {module:echarts/data/List}\n\t         */\n\t        this.stackedOn = null;\n\t\n\t        /**\n\t         * Global visual properties after visual coding\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._visual = {};\n\t\n\t        /**\n\t         * Globel layout properties.\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._layout = {};\n\t\n\t        /**\n\t         * Item visual properties after visual coding\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemVisuals = [];\n\t\n\t        /**\n\t         * Item layout properties after layout\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemLayouts = [];\n\t\n\t        /**\n\t         * Graphic elemnents\n\t         * @type {Array.<module:zrender/Element>}\n\t         * @private\n\t         */\n\t        this._graphicEls = [];\n\t\n\t        /**\n\t         * @type {Array.<Array|Object>}\n\t         * @private\n\t         */\n\t        this._rawData;\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._extent;\n\t    };\n\t\n\t    var listProto = List.prototype;\n\t\n\t    listProto.type = 'list';\n\t    /**\n\t     * If each data item has it's own option\n\t     * @type {boolean}\n\t     */\n\t    listProto.hasItemOption = true;\n\t\n\t    /**\n\t     * Get dimension name\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     * @return {string} Concrete dim name.\n\t     */\n\t    listProto.getDimension = function (dim) {\n\t        if (!isNaN(dim)) {\n\t            dim = this.dimensions[dim] || dim;\n\t        }\n\t        return dim;\n\t    };\n\t    /**\n\t     * Get type and stackable info of particular dimension\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     */\n\t    listProto.getDimensionInfo = function (dim) {\n\t        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n\t    };\n\t\n\t    /**\n\t     * Initialize from data\n\t     * @param {Array.<Object|number|Array>} data\n\t     * @param {Array.<string>} [nameList]\n\t     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n\t     */\n\t    listProto.initData = function (data, nameList, dimValueGetter) {\n\t        data = data || [];\n\t\n\t        if (__DEV__) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t\n\t        this._rawData = data;\n\t\n\t        // Clear\n\t        var storage = this._storage = {};\n\t        var indices = this.indices = [];\n\t\n\t        var dimensions = this.dimensions;\n\t        var size = data.length;\n\t        var dimensionInfoMap = this._dimensionInfos;\n\t\n\t        var idList = [];\n\t        var nameRepeatCount = {};\n\t\n\t        nameList = nameList || [];\n\t\n\t        // Init storage\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimInfo = dimensionInfoMap[dimensions[i]];\n\t            var DataCtor = dataCtors[dimInfo.type];\n\t            storage[dimensions[i]] = new DataCtor(size);\n\t        }\n\t\n\t        var self = this;\n\t        if (!dimValueGetter) {\n\t            self.hasItemOption = false;\n\t        }\n\t        // Default dim value getter\n\t        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n\t            var value = modelUtil.getDataItemValue(dataItem);\n\t            // If any dataItem is like { value: 10 }\n\t            if (modelUtil.isDataItemOption(dataItem)) {\n\t                self.hasItemOption = true;\n\t            }\n\t            return modelUtil.converDataValue(\n\t                (value instanceof Array)\n\t                    ? value[dimIndex]\n\t                    // If value is a single number or something else not array.\n\t                    : value,\n\t                dimensionInfoMap[dimName]\n\t            );\n\t        };\n\t\n\t        for (var idx = 0; idx < data.length; idx++) {\n\t            var dataItem = data[idx];\n\t            // Each data item is value\n\t            // [1, 2]\n\t            // 2\n\t            // Bar chart, line chart which uses category axis\n\t            // only gives the 'y' value. 'x' value is the indices of cateogry\n\t            // Use a tempValue to normalize the value to be a (x, y) value\n\t\n\t            // Store the data by dimensions\n\t            for (var k = 0; k < dimensions.length; k++) {\n\t                var dim = dimensions[k];\n\t                var dimStorage = storage[dim];\n\t                // PENDING NULL is empty or zero\n\t                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n\t            }\n\t\n\t            indices.push(idx);\n\t        }\n\t\n\t        // Use the name in option and create id\n\t        for (var i = 0; i < data.length; i++) {\n\t            if (!nameList[i]) {\n\t                if (data[i] && data[i].name != null) {\n\t                    nameList[i] = data[i].name;\n\t                }\n\t            }\n\t            var name = nameList[i] || '';\n\t            // Try using the id in option\n\t            var id = data[i] && data[i].id;\n\t\n\t            if (!id && name) {\n\t                // Use name as id and add counter to avoid same name\n\t                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n\t                id = name;\n\t                if (nameRepeatCount[name] > 0) {\n\t                    id += '__ec__' + nameRepeatCount[name];\n\t                }\n\t                nameRepeatCount[name]++;\n\t            }\n\t            id && (idList[i] = id);\n\t        }\n\t\n\t        this._nameList = nameList;\n\t        this._idList = idList;\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    listProto.count = function () {\n\t        return this.indices.length;\n\t    };\n\t\n\t    /**\n\t     * Get value. Return NaN if idx is out of range.\n\t     * @param {string} dim Dim must be concrete name.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.get = function (dim, idx, stack) {\n\t        var storage = this._storage;\n\t        var dataIndex = this.indices[idx];\n\t\n\t        // If value not exists\n\t        if (dataIndex == null) {\n\t            return NaN;\n\t        }\n\t\n\t        var value = storage[dim] && storage[dim][dataIndex];\n\t        // FIXME ordinal data type is not stackable\n\t        if (stack) {\n\t            var dimensionInfo = this._dimensionInfos[dim];\n\t            if (dimensionInfo && dimensionInfo.stackable) {\n\t                var stackedOn = this.stackedOn;\n\t                while (stackedOn) {\n\t                    // Get no stacked data of stacked on\n\t                    var stackedValue = stackedOn.get(dim, idx);\n\t                    // Considering positive stack, negative stack and empty data\n\t                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n\t                        || (value <= 0 && stackedValue < 0) // Negative stack\n\t                    ) {\n\t                        value += stackedValue;\n\t                    }\n\t                    stackedOn = stackedOn.stackedOn;\n\t                }\n\t            }\n\t        }\n\t        return value;\n\t    };\n\t\n\t    /**\n\t     * Get value for multi dimensions.\n\t     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.getValues = function (dimensions, idx, stack) {\n\t        var values = [];\n\t\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            stack = idx;\n\t            idx = dimensions;\n\t            dimensions = this.dimensions;\n\t        }\n\t\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            values.push(this.get(dimensions[i], idx, stack));\n\t        }\n\t\n\t        return values;\n\t    };\n\t\n\t    /**\n\t     * If value is NaN. Inlcuding '-'\n\t     * @param {string} dim\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.hasValue = function (idx) {\n\t        var dimensions = this.dimensions;\n\t        var dimensionInfos = this._dimensionInfos;\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            if (\n\t                // Ordinal type can be string or number\n\t                dimensionInfos[dimensions[i]].type !== 'ordinal'\n\t                && isNaN(this.get(dimensions[i], idx))\n\t            ) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t\n\t    /**\n\t     * Get extent of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     */\n\t    listProto.getDataExtent = function (dim, stack) {\n\t        dim = this.getDimension(dim);\n\t        var dimData = this._storage[dim];\n\t        var dimInfo = this.getDimensionInfo(dim);\n\t        stack = (dimInfo && dimInfo.stackable) && stack;\n\t        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n\t        var value;\n\t        if (dimExtent) {\n\t            return dimExtent;\n\t        }\n\t        // var dimInfo = this._dimensionInfos[dim];\n\t        if (dimData) {\n\t            var min = Infinity;\n\t            var max = -Infinity;\n\t            // var isOrdinal = dimInfo.type === 'ordinal';\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                value = this.get(dim, i, stack);\n\t                // FIXME\n\t                // if (isOrdinal && typeof value === 'string') {\n\t                //     value = zrUtil.indexOf(dimData, value);\n\t                // }\n\t                value < min && (min = value);\n\t                value > max && (max = value);\n\t            }\n\t            return (this._extent[dim + !!stack] = [min, max]);\n\t        }\n\t        else {\n\t            return [Infinity, -Infinity];\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Get sum of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     */\n\t    listProto.getSum = function (dim, stack) {\n\t        var dimData = this._storage[dim];\n\t        var sum = 0;\n\t        if (dimData) {\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var value = this.get(dim, i, stack);\n\t                if (!isNaN(value)) {\n\t                    sum += value;\n\t                }\n\t            }\n\t        }\n\t        return sum;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index with given value\n\t     * @param {number} idx\n\t     * @param {number} value\n\t     * @return {number}\n\t     */\n\t    // FIXME Precision of float value\n\t    listProto.indexOf = function (dim, value) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t        var indices = this.indices;\n\t\n\t        if (dimData) {\n\t            for (var i = 0, len = indices.length; i < len; i++) {\n\t                var rawIndex = indices[i];\n\t                if (dimData[rawIndex] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index with given name\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfName = function (name) {\n\t        var indices = this.indices;\n\t        var nameList = this._nameList;\n\t\n\t        for (var i = 0, len = indices.length; i < len; i++) {\n\t            var rawIndex = indices[i];\n\t            if (nameList[rawIndex] === name) {\n\t                return i;\n\t            }\n\t        }\n\t\n\t        return -1;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index with given raw data index\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfRawIndex = function (rawIndex) {\n\t        // Indices are ascending\n\t        var indices = this.indices;\n\t\n\t        // If rawIndex === dataIndex\n\t        var rawDataIndex = indices[rawIndex];\n\t        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n\t            return rawIndex;\n\t        }\n\t\n\t        var left = 0;\n\t        var right = indices.length - 1;\n\t        while (left <= right) {\n\t            var mid = (left + right) / 2 | 0;\n\t            if (indices[mid] < rawIndex) {\n\t                left = mid + 1;\n\t            }\n\t            else if (indices[mid] > rawIndex) {\n\t                right = mid - 1;\n\t            }\n\t            else {\n\t                return mid;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index of nearest value\n\t     * @param {string} dim\n\t     * @param {number} value\n\t     * @param {boolean} stack If given value is after stacked\n\t     * @param {number} [maxDistance=Infinity]\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t\n\t        if (maxDistance == null) {\n\t            maxDistance = Infinity;\n\t        }\n\t\n\t        var nearestIdx = -1;\n\t        if (dimData) {\n\t            var minDist = Number.MAX_VALUE;\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var diff = value - this.get(dim, i, stack);\n\t                var dist = Math.abs(diff);\n\t                if (\n\t                    diff <= maxDistance\n\t                    && (dist < minDist\n\t                        // For the case of two data are same on xAxis, which has sequence data.\n\t                        // Show the nearest index\n\t                        // https://github.com/ecomfe/echarts/issues/2869\n\t                        || (dist === minDist && diff > 0)\n\t                    )\n\t                ) {\n\t                    minDist = dist;\n\t                    nearestIdx = i;\n\t                }\n\t            }\n\t        }\n\t        return nearestIdx;\n\t    };\n\t\n\t    /**\n\t     * Get raw data index\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawIndex = function (idx) {\n\t        var rawIdx = this.indices[idx];\n\t        return rawIdx == null ? -1 : rawIdx;\n\t    };\n\t\n\t    /**\n\t     * Get raw data item\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawDataItem = function (idx) {\n\t        return this._rawData[this.getRawIndex(idx)];\n\t    };\n\t\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getName = function (idx) {\n\t        return this._nameList[this.indices[idx]] || '';\n\t    };\n\t\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getId = function (idx) {\n\t        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n\t    };\n\t\n\t\n\t    function normalizeDimensions(dimensions) {\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            dimensions = [dimensions];\n\t        }\n\t        return dimensions;\n\t    }\n\t\n\t    /**\n\t     * Data iteration\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     *\n\t     * @example\n\t     *  list.each('x', function (x, idx) {});\n\t     *  list.each(['x', 'y'], function (x, y, idx) {});\n\t     *  list.each(function (idx) {})\n\t     */\n\t    listProto.each = function (dims, cb, stack, context) {\n\t        if (typeof dims === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dims;\n\t            dims = [];\n\t        }\n\t\n\t        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\t\n\t        var value = [];\n\t        var dimSize = dims.length;\n\t        var indices = this.indices;\n\t\n\t        context = context || this;\n\t\n\t        for (var i = 0; i < indices.length; i++) {\n\t            // Simple optimization\n\t            switch (dimSize) {\n\t                case 0:\n\t                    cb.call(context, i);\n\t                    break;\n\t                case 1:\n\t                    cb.call(context, this.get(dims[0], i, stack), i);\n\t                    break;\n\t                case 2:\n\t                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n\t                    break;\n\t                default:\n\t                    for (var k = 0; k < dimSize; k++) {\n\t                        value[k] = this.get(dims[k], i, stack);\n\t                    }\n\t                    // Index\n\t                    value[k] = i;\n\t                    cb.apply(context, value);\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Data filter\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     */\n\t    listProto.filterSelf = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t\n\t        dimensions = zrUtil.map(\n\t            normalizeDimensions(dimensions), this.getDimension, this\n\t        );\n\t\n\t        var newIndices = [];\n\t        var value = [];\n\t        var dimSize = dimensions.length;\n\t        var indices = this.indices;\n\t\n\t        context = context || this;\n\t\n\t        for (var i = 0; i < indices.length; i++) {\n\t            var keep;\n\t            // Simple optimization\n\t            if (dimSize === 1) {\n\t                keep = cb.call(\n\t                    context, this.get(dimensions[0], i, stack), i\n\t                );\n\t            }\n\t            else {\n\t                for (var k = 0; k < dimSize; k++) {\n\t                    value[k] = this.get(dimensions[k], i, stack);\n\t                }\n\t                value[k] = i;\n\t                keep = cb.apply(context, value);\n\t            }\n\t            if (keep) {\n\t                newIndices.push(indices[i]);\n\t            }\n\t        }\n\t\n\t        this.indices = newIndices;\n\t\n\t        // Reset data extent\n\t        this._extent = {};\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Data mapping to a plain array\n\t     * @param {string|Array.<string>} [dimensions]\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.mapArray = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t\n\t        var result = [];\n\t        this.each(dimensions, function () {\n\t            result.push(cb && cb.apply(this, arguments));\n\t        }, stack, context);\n\t        return result;\n\t    };\n\t\n\t    function cloneListForMapAndSample(original, excludeDimensions) {\n\t        var allDimensions = original.dimensions;\n\t        var list = new List(\n\t            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n\t            original.hostModel\n\t        );\n\t        // FIXME If needs stackedOn, value may already been stacked\n\t        transferProperties(list, original);\n\t\n\t        var storage = list._storage = {};\n\t        var originalStorage = original._storage;\n\t        // Init storage\n\t        for (var i = 0; i < allDimensions.length; i++) {\n\t            var dim = allDimensions[i];\n\t            var dimStore = originalStorage[dim];\n\t            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n\t                storage[dim] = new dimStore.constructor(\n\t                    originalStorage[dim].length\n\t                );\n\t            }\n\t            else {\n\t                // Direct reference for other dimensions\n\t                storage[dim] = originalStorage[dim];\n\t            }\n\t        }\n\t        return list;\n\t    }\n\t\n\t    /**\n\t     * Data mapping to a new List with given dimensions\n\t     * @param {string|Array.<string>} dimensions\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.map = function (dimensions, cb, stack, context) {\n\t        dimensions = zrUtil.map(\n\t            normalizeDimensions(dimensions), this.getDimension, this\n\t        );\n\t\n\t        var list = cloneListForMapAndSample(this, dimensions);\n\t        // Following properties are all immutable.\n\t        // So we can reference to the same value\n\t        var indices = list.indices = this.indices;\n\t\n\t        var storage = list._storage;\n\t\n\t        var tmpRetValue = [];\n\t        this.each(dimensions, function () {\n\t            var idx = arguments[arguments.length - 1];\n\t            var retValue = cb && cb.apply(this, arguments);\n\t            if (retValue != null) {\n\t                // a number\n\t                if (typeof retValue === 'number') {\n\t                    tmpRetValue[0] = retValue;\n\t                    retValue = tmpRetValue;\n\t                }\n\t                for (var i = 0; i < retValue.length; i++) {\n\t                    var dim = dimensions[i];\n\t                    var dimStore = storage[dim];\n\t                    var rawIdx = indices[idx];\n\t                    if (dimStore) {\n\t                        dimStore[rawIdx] = retValue[i];\n\t                    }\n\t                }\n\t            }\n\t        }, stack, context);\n\t\n\t        return list;\n\t    };\n\t\n\t    /**\n\t     * Large data down sampling on given dimension\n\t     * @param {string} dimension\n\t     * @param {number} rate\n\t     * @param {Function} sampleValue\n\t     * @param {Function} sampleIndex Sample index for name and id\n\t     */\n\t    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n\t        var list = cloneListForMapAndSample(this, [dimension]);\n\t        var storage = this._storage;\n\t        var targetStorage = list._storage;\n\t\n\t        var originalIndices = this.indices;\n\t        var indices = list.indices = [];\n\t\n\t        var frameValues = [];\n\t        var frameIndices = [];\n\t        var frameSize = Math.floor(1 / rate);\n\t\n\t        var dimStore = targetStorage[dimension];\n\t        var len = this.count();\n\t        // Copy data from original data\n\t        for (var i = 0; i < storage[dimension].length; i++) {\n\t            targetStorage[dimension][i] = storage[dimension][i];\n\t        }\n\t        for (var i = 0; i < len; i += frameSize) {\n\t            // Last frame\n\t            if (frameSize > len - i) {\n\t                frameSize = len - i;\n\t                frameValues.length = frameSize;\n\t            }\n\t            for (var k = 0; k < frameSize; k++) {\n\t                var idx = originalIndices[i + k];\n\t                frameValues[k] = dimStore[idx];\n\t                frameIndices[k] = idx;\n\t            }\n\t            var value = sampleValue(frameValues);\n\t            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n\t            // Only write value on the filtered data\n\t            dimStore[idx] = value;\n\t            indices.push(idx);\n\t        }\n\t\n\t        return list;\n\t    };\n\t\n\t    /**\n\t     * Get model of one data item.\n\t     *\n\t     * @param {number} idx\n\t     */\n\t    // FIXME Model proxy ?\n\t    listProto.getItemModel = function (idx) {\n\t        var hostModel = this.hostModel;\n\t        idx = this.indices[idx];\n\t        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n\t    };\n\t\n\t    /**\n\t     * Create a data differ\n\t     * @param {module:echarts/data/List} otherList\n\t     * @return {module:echarts/data/DataDiffer}\n\t     */\n\t    listProto.diff = function (otherList) {\n\t        var idList = this._idList;\n\t        var otherIdList = otherList && otherList._idList;\n\t        var val;\n\t        // Use prefix to avoid index to be the same as otherIdList[idx],\n\t        // which will cause weird udpate animation.\n\t        var prefix = 'e\\0\\0';\n\t\n\t        return new DataDiffer(\n\t            otherList ? otherList.indices : [],\n\t            this.indices,\n\t            function (idx) {\n\t                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n\t            },\n\t            function (idx) {\n\t                return (val = idList[idx]) != null ? val : prefix + idx;\n\t            }\n\t        );\n\t    };\n\t    /**\n\t     * Get visual property.\n\t     * @param {string} key\n\t     */\n\t    listProto.getVisual = function (key) {\n\t        var visual = this._visual;\n\t        return visual && visual[key];\n\t    };\n\t\n\t    /**\n\t     * Set visual property\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setVisual('color', color);\n\t     *  setVisual({\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setVisual = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setVisual(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._visual = this._visual || {};\n\t        this._visual[key] = val;\n\t    };\n\t\n\t    /**\n\t     * Set layout property.\n\t     * @param {string} key\n\t     * @param {*} [val]\n\t     */\n\t    listProto.setLayout = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setLayout(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._layout[key] = val;\n\t    };\n\t\n\t    /**\n\t     * Get layout property.\n\t     * @param  {string} key.\n\t     * @return {*}\n\t     */\n\t    listProto.getLayout = function (key) {\n\t        return this._layout[key];\n\t    };\n\t\n\t    /**\n\t     * Get layout of single data item\n\t     * @param {number} idx\n\t     */\n\t    listProto.getItemLayout = function (idx) {\n\t        return this._itemLayouts[idx];\n\t    };\n\t\n\t    /**\n\t     * Set layout of single data item\n\t     * @param {number} idx\n\t     * @param {Object} layout\n\t     * @param {boolean=} [merge=false]\n\t     */\n\t    listProto.setItemLayout = function (idx, layout, merge) {\n\t        this._itemLayouts[idx] = merge\n\t            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n\t            : layout;\n\t    };\n\t\n\t    /**\n\t     * Clear all layout of single data item\n\t     */\n\t    listProto.clearItemLayouts = function () {\n\t        this._itemLayouts.length = 0;\n\t    };\n\t\n\t    /**\n\t     * Get visual property of single data item\n\t     * @param {number} idx\n\t     * @param {string} key\n\t     * @param {boolean} ignoreParent\n\t     */\n\t    listProto.getItemVisual = function (idx, key, ignoreParent) {\n\t        var itemVisual = this._itemVisuals[idx];\n\t        var val = itemVisual && itemVisual[key];\n\t        if (val == null && !ignoreParent) {\n\t            // Use global visual property\n\t            return this.getVisual(key);\n\t        }\n\t        return val;\n\t    };\n\t\n\t    /**\n\t     * Set visual property of single data item\n\t     *\n\t     * @param {number} idx\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setItemVisual(0, 'color', color);\n\t     *  setItemVisual(0, {\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setItemVisual = function (idx, key, value) {\n\t        var itemVisual = this._itemVisuals[idx] || {};\n\t        this._itemVisuals[idx] = itemVisual;\n\t\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    itemVisual[name] = key[name];\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        itemVisual[key] = value;\n\t    };\n\t\n\t    /**\n\t     * Clear itemVisuals and list visual.\n\t     */\n\t    listProto.clearAllVisual = function () {\n\t        this._visual = {};\n\t        this._itemVisuals = [];\n\t    };\n\t\n\t    var setItemDataAndSeriesIndex = function (child) {\n\t        child.seriesIndex = this.seriesIndex;\n\t        child.dataIndex = this.dataIndex;\n\t        child.dataType = this.dataType;\n\t    };\n\t    /**\n\t     * Set graphic element relative to data. It can be set as null\n\t     * @param {number} idx\n\t     * @param {module:zrender/Element} [el]\n\t     */\n\t    listProto.setItemGraphicEl = function (idx, el) {\n\t        var hostModel = this.hostModel;\n\t\n\t        if (el) {\n\t            // Add data index and series index for indexing the data by element\n\t            // Useful in tooltip\n\t            el.dataIndex = idx;\n\t            el.dataType = this.dataType;\n\t            el.seriesIndex = hostModel && hostModel.seriesIndex;\n\t            if (el.type === 'group') {\n\t                el.traverse(setItemDataAndSeriesIndex, el);\n\t            }\n\t        }\n\t\n\t        this._graphicEls[idx] = el;\n\t    };\n\t\n\t    /**\n\t     * @param {number} idx\n\t     * @return {module:zrender/Element}\n\t     */\n\t    listProto.getItemGraphicEl = function (idx) {\n\t        return this._graphicEls[idx];\n\t    };\n\t\n\t    /**\n\t     * @param {Function} cb\n\t     * @param {*} context\n\t     */\n\t    listProto.eachItemGraphicEl = function (cb, context) {\n\t        zrUtil.each(this._graphicEls, function (el, idx) {\n\t            if (el) {\n\t                cb && cb.call(context, el, idx);\n\t            }\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Shallow clone a new list except visual and layout properties, and graph elements.\n\t     * New list only change the indices.\n\t     */\n\t    listProto.cloneShallow = function () {\n\t        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n\t        var list = new List(dimensionInfoList, this.hostModel);\n\t\n\t        // FIXME\n\t        list._storage = this._storage;\n\t\n\t        transferProperties(list, this);\n\t\n\t\n\t        // Clone will not change the data extent and indices\n\t        list.indices = this.indices.slice();\n\t\n\t        if (this._extent) {\n\t            list._extent = zrUtil.extend({}, this._extent);\n\t        }\n\t\n\t        return list;\n\t    };\n\t\n\t    /**\n\t     * Wrap some method to add more feature\n\t     * @param {string} methodName\n\t     * @param {Function} injectFunction\n\t     */\n\t    listProto.wrapMethod = function (methodName, injectFunction) {\n\t        var originalMethod = this[methodName];\n\t        if (typeof originalMethod !== 'function') {\n\t            return;\n\t        }\n\t        this.__wrappedMethods = this.__wrappedMethods || [];\n\t        this.__wrappedMethods.push(methodName);\n\t        this[methodName] = function () {\n\t            var res = originalMethod.apply(this, arguments);\n\t            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n\t        };\n\t    };\n\t\n\t    // Methods that create a new list based on this list should be listed here.\n\t    // Notice that those method should `RETURN` the new list.\n\t    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n\t    // Methods that change indices of this list should be listed here.\n\t    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\t\n\t    module.exports = List;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 72 */,\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/Element\n\t */\n\t\n\t\n\t    var guid = __webpack_require__(77);\n\t    var Eventful = __webpack_require__(28);\n\t    var Transformable = __webpack_require__(192);\n\t    var Animatable = __webpack_require__(190);\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    /**\n\t     * @alias module:zrender/Element\n\t     * @constructor\n\t     * @extends {module:zrender/mixin/Animatable}\n\t     * @extends {module:zrender/mixin/Transformable}\n\t     * @extends {module:zrender/mixin/Eventful}\n\t     */\n\t    var Element = function (opts) {\n\t\n\t        Transformable.call(this, opts);\n\t        Eventful.call(this, opts);\n\t        Animatable.call(this, opts);\n\t\n\t        /**\n\t         * 画布元素ID\n\t         * @type {string}\n\t         */\n\t        this.id = opts.id || guid();\n\t    };\n\t\n\t    Element.prototype = {\n\t\n\t        /**\n\t         * 元素类型\n\t         * Element type\n\t         * @type {string}\n\t         */\n\t        type: 'element',\n\t\n\t        /**\n\t         * 元素名字\n\t         * Element name\n\t         * @type {string}\n\t         */\n\t        name: '',\n\t\n\t        /**\n\t         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n\t         * ZRender instance will be assigned when element is associated with zrender\n\t         * @name module:/zrender/Element#__zr\n\t         * @type {module:zrender/ZRender}\n\t         */\n\t        __zr: null,\n\t\n\t        /**\n\t         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n\t         * If ignore drawing and events of the element object\n\t         * @name module:/zrender/Element#ignore\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        ignore: false,\n\t\n\t        /**\n\t         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n\t         * 该路径会继承被裁减对象的变换\n\t         * @type {module:zrender/graphic/Path}\n\t         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n\t         * @readOnly\n\t         */\n\t        clipPath: null,\n\t\n\t        /**\n\t         * Drift element\n\t         * @param  {number} dx dx on the global space\n\t         * @param  {number} dy dy on the global space\n\t         */\n\t        drift: function (dx, dy) {\n\t            switch (this.draggable) {\n\t                case 'horizontal':\n\t                    dy = 0;\n\t                    break;\n\t                case 'vertical':\n\t                    dx = 0;\n\t                    break;\n\t            }\n\t\n\t            var m = this.transform;\n\t            if (!m) {\n\t                m = this.transform = [1, 0, 0, 1, 0, 0];\n\t            }\n\t            m[4] += dx;\n\t            m[5] += dy;\n\t\n\t            this.decomposeTransform();\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         * Hook before update\n\t         */\n\t        beforeUpdate: function () {},\n\t        /**\n\t         * Hook after update\n\t         */\n\t        afterUpdate: function () {},\n\t        /**\n\t         * Update each frame\n\t         */\n\t        update: function () {\n\t            this.updateTransform();\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {},\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        attrKV: function (key, value) {\n\t            if (key === 'position' || key === 'scale' || key === 'origin') {\n\t                // Copy the array\n\t                if (value) {\n\t                    var target = this[key];\n\t                    if (!target) {\n\t                        target = this[key] = [];\n\t                    }\n\t                    target[0] = value[0];\n\t                    target[1] = value[1];\n\t                }\n\t            }\n\t            else {\n\t                this[key] = value;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Hide the element\n\t         */\n\t        hide: function () {\n\t            this.ignore = true;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * Show the element\n\t         */\n\t        show: function () {\n\t            this.ignore = false;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * @param {string|Object} key\n\t         * @param {*} value\n\t         */\n\t        attr: function (key, value) {\n\t            if (typeof key === 'string') {\n\t                this.attrKV(key, value);\n\t            }\n\t            else if (zrUtil.isObject(key)) {\n\t                for (var name in key) {\n\t                    if (key.hasOwnProperty(name)) {\n\t                        this.attrKV(name, key[name]);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.dirty(false);\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/graphic/Path} clipPath\n\t         */\n\t        setClipPath: function (clipPath) {\n\t            var zr = this.__zr;\n\t            if (zr) {\n\t                clipPath.addSelfToZr(zr);\n\t            }\n\t\n\t            // Remove previous clip path\n\t            if (this.clipPath && this.clipPath !== clipPath) {\n\t                this.removeClipPath();\n\t            }\n\t\n\t            this.clipPath = clipPath;\n\t            clipPath.__zr = zr;\n\t            clipPath.__clipTarget = this;\n\t\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         */\n\t        removeClipPath: function () {\n\t            var clipPath = this.clipPath;\n\t            if (clipPath) {\n\t                if (clipPath.__zr) {\n\t                    clipPath.removeSelfFromZr(clipPath.__zr);\n\t                }\n\t\n\t                clipPath.__zr = null;\n\t                clipPath.__clipTarget = null;\n\t                this.clipPath = null;\n\t\n\t                this.dirty(false);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        addSelfToZr: function (zr) {\n\t            this.__zr = zr;\n\t            // 添加动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.addAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.addSelfToZr(zr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Remove self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        removeSelfFromZr: function (zr) {\n\t            this.__zr = null;\n\t            // 移除动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.removeAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.removeSelfFromZr(zr);\n\t            }\n\t        }\n\t    };\n\t\n\t    zrUtil.mixin(Element, Animatable);\n\t    zrUtil.mixin(Element, Transformable);\n\t    zrUtil.mixin(Element, Eventful);\n\t\n\t    module.exports = Element;\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/animation/Animator\n\t */\n\t\n\t\n\t    var Clip = __webpack_require__(161);\n\t    var color = __webpack_require__(29);\n\t    var util = __webpack_require__(1);\n\t    var isArrayLike = util.isArrayLike;\n\t\n\t    var arraySlice = Array.prototype.slice;\n\t\n\t    function defaultGetter(target, key) {\n\t        return target[key];\n\t    }\n\t\n\t    function defaultSetter(target, key, value) {\n\t        target[key] = value;\n\t    }\n\t\n\t    /**\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} percent\n\t     * @return {number}\n\t     */\n\t    function interpolateNumber(p0, p1, percent) {\n\t        return (p1 - p0) * percent + p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {string} p0\n\t     * @param  {string} p1\n\t     * @param  {number} percent\n\t     * @return {string}\n\t     */\n\t    function interpolateString(p0, p1, percent) {\n\t        return percent > 0.5 ? p1 : p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {number} percent\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function interpolateArray(p0, p1, percent, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = interpolateNumber(\n\t                        p0[i][j], p1[i][j], percent\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    // arr0 is source array, arr1 is target array.\n\t    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t    function fillArr(arr0, arr1, arrDim) {\n\t        var arr0Len = arr0.length;\n\t        var arr1Len = arr1.length;\n\t        if (arr0Len !== arr1Len) {\n\t            // FIXME Not work for TypedArray\n\t            var isPreviousLarger = arr0Len > arr1Len;\n\t            if (isPreviousLarger) {\n\t                // Cut the previous\n\t                arr0.length = arr1Len;\n\t            }\n\t            else {\n\t                // Fill the previous\n\t                for (var i = arr0Len; i < arr1Len; i++) {\n\t                    arr0.push(\n\t                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n\t                    );\n\t                }\n\t            }\n\t        }\n\t        // Handling NaN value\n\t        var len2 = arr0[0] && arr0[0].length;\n\t        for (var i = 0; i < arr0.length; i++) {\n\t            if (arrDim === 1) {\n\t                if (isNaN(arr0[i])) {\n\t                    arr0[i] = arr1[i];\n\t                }\n\t            }\n\t            else {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (isNaN(arr0[i][j])) {\n\t                        arr0[i][j] = arr1[i][j];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} arr0\n\t     * @param  {Array} arr1\n\t     * @param  {number} arrDim\n\t     * @return {boolean}\n\t     */\n\t    function isArraySame(arr0, arr1, arrDim) {\n\t        if (arr0 === arr1) {\n\t            return true;\n\t        }\n\t        var len = arr0.length;\n\t        if (len !== arr1.length) {\n\t            return false;\n\t        }\n\t        if (arrDim === 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                if (arr0[i] !== arr1[i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var len2 = arr0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (arr0[i][j] !== arr1[i][j]) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate array\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {Array} p2\n\t     * @param  {Array} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function catmullRomInterpolateArray(\n\t        p0, p1, p2, p3, t, t2, t3, out, arrDim\n\t    ) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = catmullRomInterpolate(\n\t                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n\t                );\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = catmullRomInterpolate(\n\t                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n\t                        t, t2, t3\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate number\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @return {number}\n\t     */\n\t    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    function cloneValue(value) {\n\t        if (isArrayLike(value)) {\n\t            var len = value.length;\n\t            if (isArrayLike(value[0])) {\n\t                var ret = [];\n\t                for (var i = 0; i < len; i++) {\n\t                    ret.push(arraySlice.call(value[i]));\n\t                }\n\t                return ret;\n\t            }\n\t\n\t            return arraySlice.call(value);\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    function rgba2String(rgba) {\n\t        rgba[0] = Math.floor(rgba[0]);\n\t        rgba[1] = Math.floor(rgba[1]);\n\t        rgba[2] = Math.floor(rgba[2]);\n\t\n\t        return 'rgba(' + rgba.join(',') + ')';\n\t    }\n\t\n\t    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n\t        var getter = animator._getter;\n\t        var setter = animator._setter;\n\t        var useSpline = easing === 'spline';\n\t\n\t        var trackLen = keyframes.length;\n\t        if (!trackLen) {\n\t            return;\n\t        }\n\t        // Guess data type\n\t        var firstVal = keyframes[0].value;\n\t        var isValueArray = isArrayLike(firstVal);\n\t        var isValueColor = false;\n\t        var isValueString = false;\n\t\n\t        // For vertices morphing\n\t        var arrDim = (\n\t                isValueArray\n\t                && isArrayLike(firstVal[0])\n\t            )\n\t            ? 2 : 1;\n\t        var trackMaxTime;\n\t        // Sort keyframe as ascending\n\t        keyframes.sort(function(a, b) {\n\t            return a.time - b.time;\n\t        });\n\t\n\t        trackMaxTime = keyframes[trackLen - 1].time;\n\t        // Percents of each keyframe\n\t        var kfPercents = [];\n\t        // Value of each keyframe\n\t        var kfValues = [];\n\t        var prevValue = keyframes[0].value;\n\t        var isAllValueEqual = true;\n\t        for (var i = 0; i < trackLen; i++) {\n\t            kfPercents.push(keyframes[i].time / trackMaxTime);\n\t            // Assume value is a color when it is a string\n\t            var value = keyframes[i].value;\n\t\n\t            // Check if value is equal, deep check if value is array\n\t            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n\t                || (!isValueArray && value === prevValue))) {\n\t                isAllValueEqual = false;\n\t            }\n\t            prevValue = value;\n\t\n\t            // Try converting a string to a color array\n\t            if (typeof value == 'string') {\n\t                var colorArray = color.parse(value);\n\t                if (colorArray) {\n\t                    value = colorArray;\n\t                    isValueColor = true;\n\t                }\n\t                else {\n\t                    isValueString = true;\n\t                }\n\t            }\n\t            kfValues.push(value);\n\t        }\n\t        if (isAllValueEqual) {\n\t            return;\n\t        }\n\t\n\t        var lastValue = kfValues[trackLen - 1];\n\t        // Polyfill array and NaN value\n\t        for (var i = 0; i < trackLen - 1; i++) {\n\t            if (isValueArray) {\n\t                fillArr(kfValues[i], lastValue, arrDim);\n\t            }\n\t            else {\n\t                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t                    kfValues[i] = lastValue;\n\t                }\n\t            }\n\t        }\n\t        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\t\n\t        // Cache the key of last frame to speed up when\n\t        // animation playback is sequency\n\t        var lastFrame = 0;\n\t        var lastFramePercent = 0;\n\t        var start;\n\t        var w;\n\t        var p0;\n\t        var p1;\n\t        var p2;\n\t        var p3;\n\t\n\t        if (isValueColor) {\n\t            var rgba = [0, 0, 0, 0];\n\t        }\n\t\n\t        var onframe = function (target, percent) {\n\t            // Find the range keyframes\n\t            // kf1-----kf2---------current--------kf3\n\t            // find kf2 and kf3 and do interpolation\n\t            var frame;\n\t            // In the easing function like elasticOut, percent may less than 0\n\t            if (percent < 0) {\n\t                frame = 0;\n\t            }\n\t            else if (percent < lastFramePercent) {\n\t                // Start from next key\n\t                // PENDING start from lastFrame ?\n\t                start = Math.min(lastFrame + 1, trackLen - 1);\n\t                for (frame = start; frame >= 0; frame--) {\n\t                    if (kfPercents[frame] <= percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                // PENDING really need to do this ?\n\t                frame = Math.min(frame, trackLen - 2);\n\t            }\n\t            else {\n\t                for (frame = lastFrame; frame < trackLen; frame++) {\n\t                    if (kfPercents[frame] > percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame - 1, trackLen - 2);\n\t            }\n\t            lastFrame = frame;\n\t            lastFramePercent = percent;\n\t\n\t            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n\t            if (range === 0) {\n\t                return;\n\t            }\n\t            else {\n\t                w = (percent - kfPercents[frame]) / range;\n\t            }\n\t            if (useSpline) {\n\t                p1 = kfValues[frame];\n\t                p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t                if (isValueArray) {\n\t                    catmullRomInterpolateArray(\n\t                        p0, p1, p2, p3, w, w * w, w * w * w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        value = catmullRomInterpolateArray(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(p1, p2, w);\n\t                    }\n\t                    else {\n\t                        value = catmullRomInterpolate(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w\n\t                        );\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t            else {\n\t                if (isValueArray) {\n\t                    interpolateArray(\n\t                        kfValues[frame], kfValues[frame + 1], w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        interpolateArray(\n\t                            kfValues[frame], kfValues[frame + 1], w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    else {\n\t                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t        };\n\t\n\t        var clip = new Clip({\n\t            target: animator._target,\n\t            life: trackMaxTime,\n\t            loop: animator._loop,\n\t            delay: animator._delay,\n\t            onframe: onframe,\n\t            ondestroy: oneTrackDone\n\t        });\n\t\n\t        if (easing && easing !== 'spline') {\n\t            clip.easing = easing;\n\t        }\n\t\n\t        return clip;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animator\n\t     * @constructor\n\t     * @param {Object} target\n\t     * @param {boolean} loop\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     */\n\t    var Animator = function(target, loop, getter, setter) {\n\t        this._tracks = {};\n\t        this._target = target;\n\t\n\t        this._loop = loop || false;\n\t\n\t        this._getter = getter || defaultGetter;\n\t        this._setter = setter || defaultSetter;\n\t\n\t        this._clipCount = 0;\n\t\n\t        this._delay = 0;\n\t\n\t        this._doneList = [];\n\t\n\t        this._onframeList = [];\n\t\n\t        this._clipList = [];\n\t    };\n\t\n\t    Animator.prototype = {\n\t        /**\n\t         * 设置动画关键帧\n\t         * @param  {number} time 关键帧时间，单位是ms\n\t         * @param  {Object} props 关键帧的属性值，key-value表示\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        when: function(time /* ms */, props) {\n\t            var tracks = this._tracks;\n\t            for (var propName in props) {\n\t                if (!props.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t\n\t                if (!tracks[propName]) {\n\t                    tracks[propName] = [];\n\t                    // Invalid value\n\t                    var value = this._getter(this._target, propName);\n\t                    if (value == null) {\n\t                        // zrLog('Invalid property ' + propName);\n\t                        continue;\n\t                    }\n\t                    // If time is 0\n\t                    //  Then props is given initialize value\n\t                    // Else\n\t                    //  Initialize value from current prop value\n\t                    if (time !== 0) {\n\t                        tracks[propName].push({\n\t                            time: 0,\n\t                            value: cloneValue(value)\n\t                        });\n\t                    }\n\t                }\n\t                tracks[propName].push({\n\t                    time: time,\n\t                    value: props[propName]\n\t                });\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * 添加动画每一帧的回调函数\n\t         * @param  {Function} callback\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        during: function (callback) {\n\t            this._onframeList.push(callback);\n\t            return this;\n\t        },\n\t\n\t        _doneCallback: function () {\n\t            // Clear all tracks\n\t            this._tracks = {};\n\t            // Clear all clips\n\t            this._clipList.length = 0;\n\t\n\t            var doneList = this._doneList;\n\t            var len = doneList.length;\n\t            for (var i = 0; i < len; i++) {\n\t                doneList[i].call(this);\n\t            }\n\t        },\n\t        /**\n\t         * 开始执行动画\n\t         * @param  {string|Function} easing\n\t         *         动画缓动函数，详见{@link module:zrender/animation/easing}\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        start: function (easing) {\n\t\n\t            var self = this;\n\t            var clipCount = 0;\n\t\n\t            var oneTrackDone = function() {\n\t                clipCount--;\n\t                if (!clipCount) {\n\t                    self._doneCallback();\n\t                }\n\t            };\n\t\n\t            var lastClip;\n\t            for (var propName in this._tracks) {\n\t                if (!this._tracks.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t                var clip = createTrackClip(\n\t                    this, easing, oneTrackDone,\n\t                    this._tracks[propName], propName\n\t                );\n\t                if (clip) {\n\t                    this._clipList.push(clip);\n\t                    clipCount++;\n\t\n\t                    // If start after added to animation\n\t                    if (this.animation) {\n\t                        this.animation.addClip(clip);\n\t                    }\n\t\n\t                    lastClip = clip;\n\t                }\n\t            }\n\t\n\t            // Add during callback on the last clip\n\t            if (lastClip) {\n\t                var oldOnFrame = lastClip.onframe;\n\t                lastClip.onframe = function (target, percent) {\n\t                    oldOnFrame(target, percent);\n\t\n\t                    for (var i = 0; i < self._onframeList.length; i++) {\n\t                        self._onframeList[i](target, percent);\n\t                    }\n\t                };\n\t            }\n\t\n\t            if (!clipCount) {\n\t                this._doneCallback();\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * 停止动画\n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stop: function (forwardToLast) {\n\t            var clipList = this._clipList;\n\t            var animation = this.animation;\n\t            for (var i = 0; i < clipList.length; i++) {\n\t                var clip = clipList[i];\n\t                if (forwardToLast) {\n\t                    // Move to last frame before stop\n\t                    clip.onframe(this._target, 1);\n\t                }\n\t                animation && animation.removeClip(clip);\n\t            }\n\t            clipList.length = 0;\n\t        },\n\t        /**\n\t         * 设置动画延迟开始的时间\n\t         * @param  {number} time 单位ms\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        delay: function (time) {\n\t            this._delay = time;\n\t            return this;\n\t        },\n\t        /**\n\t         * 添加动画结束的回调\n\t         * @param  {Function} cb\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        done: function(cb) {\n\t            if (cb) {\n\t                this._doneList.push(cb);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/animation/Clip>}\n\t         */\n\t        getClips: function () {\n\t            return this._clipList;\n\t        }\n\t    };\n\t\n\t    module.exports = Animator;\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = (typeof window !== 'undefined' &&\n\t                                    (window.requestAnimationFrame\n\t                                    || window.msRequestAnimationFrame\n\t                                    || window.mozRequestAnimationFrame\n\t                                    || window.webkitRequestAnimationFrame))\n\t                                || function (func) {\n\t                                    setTimeout(func, 16);\n\t                                };\n\t\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var PI2 = Math.PI * 2;\n\t    module.exports = {\n\t        normalizeRadian: function(angle) {\n\t            angle %= PI2;\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports) {\n\n\t/**\n\t * zrender: 生成唯一id\n\t *\n\t * @author errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var idStart = 0x0907;\n\t\n\t    module.exports = function () {\n\t        return idStart++;\n\t    };\n\t\n\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t        var config = __webpack_require__(39);\n\t\n\t        /**\n\t         * @exports zrender/tool/log\n\t         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t         */\n\t        module.exports = function() {\n\t            if (config.debugMode === 0) {\n\t                return;\n\t            }\n\t            else if (config.debugMode == 1) {\n\t                for (var k in arguments) {\n\t                    throw new Error(arguments[k]);\n\t                }\n\t            }\n\t            else if (config.debugMode > 1) {\n\t                for (var k in arguments) {\n\t                    console.log(arguments[k]);\n\t                }\n\t            }\n\t        };\n\t\n\t        /* for debug\n\t        return function(mes) {\n\t            document.getElementById('wrong-message').innerHTML =\n\t                mes + ' ' + (new Date() - 0)\n\t                + '<br/>'\n\t                + document.getElementById('wrong-message').innerHTML;\n\t        };\n\t        */\n\t    \n\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Image element\n\t * @module zrender/graphic/Image\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(54);\n\t    var BoundingRect = __webpack_require__(13);\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var LRU = __webpack_require__(170);\n\t    var globalImageCache = new LRU(50);\n\t    /**\n\t     * @alias zrender/graphic/Image\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function ZImage(opts) {\n\t        Displayable.call(this, opts);\n\t    }\n\t\n\t    ZImage.prototype = {\n\t\n\t        constructor: ZImage,\n\t\n\t        type: 'image',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var src = style.image;\n\t            var image;\n\t\n\t            // Must bind each time\n\t            style.bind(ctx, this, prevEl);\n\t            // style.image is a url string\n\t            if (typeof src === 'string') {\n\t                image = this._image;\n\t            }\n\t            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t            else {\n\t                image = src;\n\t            }\n\t            // FIXME Case create many images with src\n\t            if (!image && src) {\n\t                // Try get from global image cache\n\t                var cachedImgObj = globalImageCache.get(src);\n\t                if (!cachedImgObj) {\n\t                    // Create a new image\n\t                    image = new Image();\n\t                    image.onload = function () {\n\t                        image.onload = null;\n\t                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t                            cachedImgObj.pending[i].dirty();\n\t                        }\n\t                    };\n\t                    cachedImgObj = {\n\t                        image: image,\n\t                        pending: [this]\n\t                    };\n\t                    image.src = src;\n\t                    globalImageCache.put(src, cachedImgObj);\n\t                    this._image = image;\n\t                    return;\n\t                }\n\t                else {\n\t                    image = cachedImgObj.image;\n\t                    this._image = image;\n\t                    // Image is not complete finish, add to pending list\n\t                    if (!image.width || !image.height) {\n\t                        cachedImgObj.pending.push(this);\n\t                        return;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (image) {\n\t                // 图片已经加载完成\n\t                // if (image.nodeName.toUpperCase() == 'IMG') {\n\t                //     if (!image.complete) {\n\t                //         return;\n\t                //     }\n\t                // }\n\t                // Else is canvas\n\t\n\t                var width = style.width || image.width;\n\t                var height = style.height || image.height;\n\t                var x = style.x || 0;\n\t                var y = style.y || 0;\n\t                // 图片加载失败\n\t                if (!image.width || !image.height) {\n\t                    return;\n\t                }\n\t\n\t                // 设置transform\n\t                this.setTransform(ctx);\n\t\n\t\n\t                if (style.sWidth && style.sHeight) {\n\t                    var sx = style.sx || 0;\n\t                    var sy = style.sy || 0;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, style.sWidth, style.sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else if (style.sx && style.sy) {\n\t                    var sx = style.sx;\n\t                    var sy = style.sy;\n\t                    var sWidth = width - sx;\n\t                    var sHeight = height - sy;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, sWidth, sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else {\n\t                    ctx.drawImage(image, x, y, width, height);\n\t                }\n\t\n\t                // 如果没设置宽和高的话自动根据图片宽高设置\n\t                if (style.width == null) {\n\t                    style.width = width;\n\t                }\n\t                if (style.height == null) {\n\t                    style.height = height;\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t\n\t                // Draw rect text\n\t                if (style.text != null) {\n\t                    this.drawRectText(ctx, this.getBoundingRect());\n\t                }\n\t\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (! this._rect) {\n\t                this._rect = new BoundingRect(\n\t                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n\t                );\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(ZImage, Displayable);\n\t\n\t    module.exports = ZImage;\n\n\n/***/ },\n/* 80 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var Pattern = function (image, repeat) {\n\t        this.image = image;\n\t        this.repeat = repeat;\n\t\n\t        // Can be cloned\n\t        this.type = 'pattern';\n\t    };\n\t\n\t    Pattern.prototype.getCanvasPattern = function (ctx) {\n\t\n\t        return this._canvasPattern\n\t            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n\t    };\n\t\n\t    module.exports = Pattern;\n\n\n/***/ },\n/* 81 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/graphic/Style\n\t */\n\t\n\t\n\t    var STYLE_COMMON_PROPS = [\n\t        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n\t        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n\t    ];\n\t\n\t    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t\n\t    var Style = function (opts) {\n\t        this.extendFrom(opts);\n\t    };\n\t\n\t    function createLinearGradient(ctx, obj, rect) {\n\t        // var size =\n\t        var x = obj.x;\n\t        var x2 = obj.x2;\n\t        var y = obj.y;\n\t        var y2 = obj.y2;\n\t\n\t        if (!obj.global) {\n\t            x = x * rect.width + rect.x;\n\t            x2 = x2 * rect.width + rect.x;\n\t            y = y * rect.height + rect.y;\n\t            y2 = y2 * rect.height + rect.y;\n\t        }\n\t\n\t        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t    function createRadialGradient(ctx, obj, rect) {\n\t        var width = rect.width;\n\t        var height = rect.height;\n\t        var min = Math.min(width, height);\n\t\n\t        var x = obj.x;\n\t        var y = obj.y;\n\t        var r = obj.r;\n\t        if (!obj.global) {\n\t            x = x * width + rect.x;\n\t            y = y * height + rect.y;\n\t            r = r * min;\n\t        }\n\t\n\t        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t\n\t    Style.prototype = {\n\t\n\t        constructor: Style,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        fill: '#000000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        stroke: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        opacity: 1,\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         */\n\t        lineDash: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineDashOffset: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowBlur: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetX: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetY: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineWidth: 1,\n\t\n\t        /**\n\t         * If stroke ignore scale\n\t         * @type {Boolean}\n\t         */\n\t        strokeNoScale: false,\n\t\n\t        // Bounding rect text configuration\n\t        // Not affected by element transform\n\t        /**\n\t         * @type {string}\n\t         */\n\t        text: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textFill: '#000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textStroke: null,\n\t\n\t        /**\n\t         * 'inside', 'left', 'right', 'top', 'bottom'\n\t         * [x, y]\n\t         * @type {string|Array.<number>}\n\t         * @default 'inside'\n\t         */\n\t        textPosition: 'inside',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textBaseline: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textAlign: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textVerticalAlign: null,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textDistance: 5,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowBlur: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetX: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetY: 0,\n\t\n\t        /**\n\t         * If transform text\n\t         * Only useful in Path and Image element\n\t         * @type {boolean}\n\t         */\n\t        textTransform: false,\n\t\n\t        /**\n\t         * Text rotate around position of Path or Image\n\t         * Only useful in Path and Image element and textTransform is false.\n\t         */\n\t        textRotation: 0,\n\t\n\t        /**\n\t         * @type {string}\n\t         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t         */\n\t        blend: null,\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         */\n\t        bind: function (ctx, el, prevEl) {\n\t            var style = this;\n\t            var prevStyle = prevEl && prevEl.style;\n\t            var firstDraw = !prevStyle;\n\t\n\t            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t                var prop = STYLE_COMMON_PROPS[i];\n\t                var styleName = prop[0];\n\t\n\t                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t                    // FIXME Invalid property value will cause style leak from previous element.\n\t                    ctx[styleName] = style[styleName] || prop[1];\n\t                }\n\t            }\n\t\n\t            if ((firstDraw || style.fill !== prevStyle.fill)) {\n\t                ctx.fillStyle = style.fill;\n\t            }\n\t            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n\t                ctx.strokeStyle = style.stroke;\n\t            }\n\t            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n\t                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t            }\n\t\n\t            if ((firstDraw || style.blend !== prevStyle.blend)) {\n\t                ctx.globalCompositeOperation = style.blend || 'source-over';\n\t            }\n\t            if (this.hasStroke()) {\n\t                var lineWidth = style.lineWidth;\n\t                ctx.lineWidth = lineWidth / (\n\t                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n\t                );\n\t            }\n\t        },\n\t\n\t        hasFill: function () {\n\t            var fill = this.fill;\n\t            return fill != null && fill !== 'none';\n\t        },\n\t\n\t        hasStroke: function () {\n\t            var stroke = this.stroke;\n\t            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t        },\n\t\n\t        /**\n\t         * Extend from other style\n\t         * @param {zrender/graphic/Style} otherStyle\n\t         * @param {boolean} overwrite\n\t         */\n\t        extendFrom: function (otherStyle, overwrite) {\n\t            if (otherStyle) {\n\t                var target = this;\n\t                for (var name in otherStyle) {\n\t                    if (otherStyle.hasOwnProperty(name)\n\t                        && (overwrite || ! target.hasOwnProperty(name))\n\t                    ) {\n\t                        target[name] = otherStyle[name];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Batch setting style with a given object\n\t         * @param {Object|string} obj\n\t         * @param {*} [obj]\n\t         */\n\t        set: function (obj, value) {\n\t            if (typeof obj === 'string') {\n\t                this[obj] = value;\n\t            }\n\t            else {\n\t                this.extendFrom(obj, true);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clone\n\t         * @return {zrender/graphic/Style} [description]\n\t         */\n\t        clone: function () {\n\t            var newStyle = new this.constructor();\n\t            newStyle.extendFrom(this, true);\n\t            return newStyle;\n\t        },\n\t\n\t        getGradient: function (ctx, obj, rect) {\n\t            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t            var canvasGradient = method(ctx, obj, rect);\n\t            var colorStops = obj.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(\n\t                    colorStops[i].offset, colorStops[i].color\n\t                );\n\t            }\n\t            return canvasGradient;\n\t        }\n\t    };\n\t\n\t    var styleProto = Style.prototype;\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t        var prop = STYLE_COMMON_PROPS[i];\n\t        if (!(prop[0] in styleProto)) {\n\t            styleProto[prop[0]] = prop[1];\n\t        }\n\t    }\n\t\n\t    // Provide for others\n\t    Style.getGradient = styleProto.getGradient;\n\t\n\t    module.exports = Style;\n\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var smoothSpline = __webpack_require__(179);\n\t    var smoothBezier = __webpack_require__(178);\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape, closePath) {\n\t            var points = shape.points;\n\t            var smooth = shape.smooth;\n\t            if (points && points.length >= 2) {\n\t                if (smooth && smooth !== 'spline') {\n\t                    var controlPoints = smoothBezier(\n\t                        points, smooth, closePath, shape.smoothConstraint\n\t                    );\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    var len = points.length;\n\t                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t                        var cp1 = controlPoints[i * 2];\n\t                        var cp2 = controlPoints[i * 2 + 1];\n\t                        var p = points[(i + 1) % len];\n\t                        ctx.bezierCurveTo(\n\t                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n\t                        );\n\t                    }\n\t                }\n\t                else {\n\t                    if (smooth === 'spline') {\n\t                        points = smoothSpline(points, closePath);\n\t                    }\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    for (var i = 1, l = points.length; i < l; i++) {\n\t                        ctx.lineTo(points[i][0], points[i][1]);\n\t                    }\n\t                }\n\t\n\t                closePath && ctx.closePath();\n\t            }\n\t        }\n\t    };\n\n\n/***/ },\n/* 83 */,\n/* 84 */,\n/* 85 */,\n/* 86 */,\n/* 87 */,\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var formatUtil = __webpack_require__(9);\n\t    var modelUtil = __webpack_require__(11);\n\t    var ComponentModel = __webpack_require__(18);\n\t    var colorPaletteMixin = __webpack_require__(47);\n\t    var env = __webpack_require__(14);\n\t    var layout = __webpack_require__(25);\n\t\n\t    var encodeHTML = formatUtil.encodeHTML;\n\t    var addCommas = formatUtil.addCommas;\n\t\n\t    var SeriesModel = ComponentModel.extend({\n\t\n\t        type: 'series.__base__',\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        seriesIndex: 0,\n\t\n\t        // coodinateSystem will be injected in the echarts/CoordinateSystem\n\t        coordinateSystem: null,\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        defaultOption: null,\n\t\n\t        /**\n\t         * Data provided for legend\n\t         * @type {Function}\n\t         */\n\t        // PENDING\n\t        legendDataProvider: null,\n\t\n\t        /**\n\t         * Access path of color for visual\n\t         */\n\t        visualColorAccessPath: 'itemStyle.normal.color',\n\t\n\t        /**\n\t         * Support merge layout params.\n\t         * Only support 'box' now (left/right/top/bottom/width/height).\n\t         * @type {string|Object} Object can be {ignoreSize: true}\n\t         * @readOnly\n\t         */\n\t        layoutMode: null,\n\t\n\t        init: function (option, parentModel, ecModel, extraOpt) {\n\t\n\t            /**\n\t             * @type {number}\n\t             * @readOnly\n\t             */\n\t            this.seriesIndex = this.componentIndex;\n\t\n\t            this.mergeDefaultAndTheme(option, ecModel);\n\t\n\t            /**\n\t             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n\t             * @private\n\t             */\n\t            this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n\t\n\t            // If we reverse the order (make this._data firstly, and then make\n\t            // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n\t            // cause this._data.graph.data !== this._data when using\n\t            // module:echarts/data/Graph or module:echarts/data/Tree.\n\t            // See module:echarts/data/helper/linkList\n\t            this._data = this._dataBeforeProcessed.cloneShallow();\n\t        },\n\t\n\t        /**\n\t         * Util for merge default and theme to option\n\t         * @param  {Object} option\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         */\n\t        mergeDefaultAndTheme: function (option, ecModel) {\n\t            var layoutMode = this.layoutMode;\n\t            var inputPositionParams = layoutMode\n\t                ? layout.getLayoutParams(option) : {};\n\t\n\t            zrUtil.merge(\n\t                option,\n\t                ecModel.getTheme().get(this.subType)\n\t            );\n\t            zrUtil.merge(option, this.getDefaultOption());\n\t\n\t            // Default label emphasis `position` and `show`\n\t            // FIXME Set label in mergeOption\n\t            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\t\n\t            this.fillDataTextStyle(option.data);\n\t\n\t            if (layoutMode) {\n\t                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t            }\n\t        },\n\t\n\t        mergeOption: function (newSeriesOption, ecModel) {\n\t            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n\t            this.fillDataTextStyle(newSeriesOption.data);\n\t\n\t            var layoutMode = this.layoutMode;\n\t            if (layoutMode) {\n\t                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n\t            }\n\t\n\t            var data = this.getInitialData(newSeriesOption, ecModel);\n\t            // TODO Merge data?\n\t            if (data) {\n\t                this._data = data;\n\t                this._dataBeforeProcessed = data.cloneShallow();\n\t            }\n\t        },\n\t\n\t        fillDataTextStyle: function (data) {\n\t            // Default data label emphasis `position` and `show`\n\t            // FIXME Tree structure data ?\n\t            // FIXME Performance ?\n\t            if (data) {\n\t                for (var i = 0; i < data.length; i++) {\n\t                    if (data[i] && data[i].label) {\n\t                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Init a data structure from data related option in series\n\t         * Must be overwritten\n\t         */\n\t        getInitialData: function () {},\n\t\n\t        /**\n\t         * @param {string} [dataType]\n\t         * @return {module:echarts/data/List}\n\t         */\n\t        getData: function (dataType) {\n\t            return dataType == null ? this._data : this._data.getLinkedData(dataType);\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/data/List} data\n\t         */\n\t        setData: function (data) {\n\t            this._data = data;\n\t        },\n\t\n\t        /**\n\t         * Get data before processed\n\t         * @return {module:echarts/data/List}\n\t         */\n\t        getRawData: function () {\n\t            return this._dataBeforeProcessed;\n\t        },\n\t\n\t        /**\n\t         * Coord dimension to data dimension.\n\t         *\n\t         * By default the result is the same as dimensions of series data.\n\t         * But in some series data dimensions are different from coord dimensions (i.e.\n\t         * candlestick and boxplot). Override this method to handle those cases.\n\t         *\n\t         * Coord dimension to data dimension can be one-to-many\n\t         *\n\t         * @param {string} coordDim\n\t         * @return {Array.<string>} dimensions on the axis.\n\t         */\n\t        coordDimToDataDim: function (coordDim) {\n\t            return [coordDim];\n\t        },\n\t\n\t        /**\n\t         * Convert data dimension to coord dimension.\n\t         *\n\t         * @param {string|number} dataDim\n\t         * @return {string}\n\t         */\n\t        dataDimToCoordDim: function (dataDim) {\n\t            return dataDim;\n\t        },\n\t\n\t        /**\n\t         * Get base axis if has coordinate system and has axis.\n\t         * By default use coordSys.getBaseAxis();\n\t         * Can be overrided for some chart.\n\t         * @return {type} description\n\t         */\n\t        getBaseAxis: function () {\n\t            var coordSys = this.coordinateSystem;\n\t            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n\t        },\n\t\n\t        // FIXME\n\t        /**\n\t         * Default tooltip formatter\n\t         *\n\t         * @param {number} dataIndex\n\t         * @param {boolean} [multipleSeries=false]\n\t         * @param {number} [dataType]\n\t         */\n\t        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n\t            function formatArrayValue(value) {\n\t                var result = [];\n\t\n\t                zrUtil.each(value, function (val, idx) {\n\t                    var dimInfo = data.getDimensionInfo(idx);\n\t                    var dimType = dimInfo && dimInfo.type;\n\t                    var valStr;\n\t\n\t                    if (dimType === 'ordinal') {\n\t                        valStr = val + '';\n\t                    }\n\t                    else if (dimType === 'time') {\n\t                        valStr = multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val);\n\t                    }\n\t                    else {\n\t                        valStr = addCommas(val);\n\t                    }\n\t\n\t                    valStr && result.push(valStr);\n\t                });\n\t\n\t                return result.join(', ');\n\t            }\n\t\n\t            var data = this._data;\n\t\n\t            var value = this.getRawValue(dataIndex);\n\t            var formattedValue = zrUtil.isArray(value)\n\t                ? formatArrayValue(value) : addCommas(value);\n\t            var name = data.getName(dataIndex);\n\t\n\t            var color = data.getItemVisual(dataIndex, 'color');\n\t            if (zrUtil.isObject(color) && color.colorStops) {\n\t                color = (color.colorStops[0] || {}).color;\n\t            }\n\t            color = color || 'transparent';\n\t\n\t            var colorEl = '<span style=\"display:inline-block;margin-right:5px;'\n\t                + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n\t\n\t            var seriesName = this.name;\n\t            // FIXME\n\t            if (seriesName === '\\0-') {\n\t                // Not show '-'\n\t                seriesName = '';\n\t            }\n\t            return !multipleSeries\n\t                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl\n\t                    + (name\n\t                        ? encodeHTML(name) + ' : ' + formattedValue\n\t                        : formattedValue)\n\t                  )\n\t                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);\n\t        },\n\t\n\t        /**\n\t         * @return {boolean}\n\t         */\n\t        ifEnableAnimation: function () {\n\t            if (env.node) {\n\t                return false;\n\t            }\n\t\n\t            var animationEnabled = this.getShallow('animation');\n\t            if (animationEnabled) {\n\t                if (this.getData().count() > this.getShallow('animationThreshold')) {\n\t                    animationEnabled = false;\n\t                }\n\t            }\n\t            return animationEnabled;\n\t        },\n\t\n\t        restoreData: function () {\n\t            this._data = this._dataBeforeProcessed.cloneShallow();\n\t        },\n\t\n\t        getColorFromPalette: function (name, scope) {\n\t            var ecModel = this.ecModel;\n\t            // PENDING\n\t            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n\t            if (!color) {\n\t                color = ecModel.getColorFromPalette(name, scope);\n\t            }\n\t            return color;\n\t        },\n\t\n\t        /**\n\t         * Get data indices for show tooltip content. See tooltip.\n\t         * @abstract\n\t         * @param {Array.<string>|string} dim\n\t         * @param {Array.<number>} value\n\t         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n\t         * @return {Array.<number>} data indices.\n\t         */\n\t        getAxisTooltipDataIndex: null,\n\t\n\t        /**\n\t         * See tooltip.\n\t         * @abstract\n\t         * @param {number} dataIndex\n\t         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n\t         */\n\t        getTooltipPosition: null\n\t    });\n\t\n\t    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n\t    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\t\n\t    module.exports = SeriesModel;\n\n\n/***/ },\n/* 89 */,\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Group = __webpack_require__(40);\n\t    var componentUtil = __webpack_require__(48);\n\t    var clazzUtil = __webpack_require__(21);\n\t    var modelUtil = __webpack_require__(11);\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    function Chart() {\n\t\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewChart');\n\t    }\n\t\n\t    Chart.prototype = {\n\t\n\t        type: 'chart',\n\t\n\t        /**\n\t         * Init the chart\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         */\n\t        init: function (ecModel, api) {},\n\t\n\t        /**\n\t         * Render the chart\n\t         * @param  {module:echarts/model/Series} seriesModel\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         * @param  {Object} payload\n\t         */\n\t        render: function (seriesModel, ecModel, api, payload) {},\n\t\n\t        /**\n\t         * Highlight series or specified data item\n\t         * @param  {module:echarts/model/Series} seriesModel\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         * @param  {Object} payload\n\t         */\n\t        highlight: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n\t        },\n\t\n\t        /**\n\t         * Downplay series or specified data item\n\t         * @param  {module:echarts/model/Series} seriesModel\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         * @param  {Object} payload\n\t         */\n\t        downplay: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'normal');\n\t        },\n\t\n\t        /**\n\t         * Remove self\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         */\n\t        remove: function (ecModel, api) {\n\t            this.group.removeAll();\n\t        },\n\t\n\t        /**\n\t         * Dispose self\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         */\n\t        dispose: function () {}\n\t\n\t        /**\n\t         * The view contains the given point.\n\t         * @interface\n\t         * @param {Array.<number>} point\n\t         * @return {boolean}\n\t         */\n\t        // containPoint: function () {}\n\t\n\t    };\n\t\n\t    var chartProto = Chart.prototype;\n\t    chartProto.updateView\n\t        = chartProto.updateLayout\n\t        = chartProto.updateVisual\n\t        = function (seriesModel, ecModel, api, payload) {\n\t            this.render(seriesModel, ecModel, api, payload);\n\t        };\n\t\n\t    /**\n\t     * Set state of single element\n\t     * @param  {module:zrender/Element} el\n\t     * @param  {string} state\n\t     */\n\t    function elSetState(el, state) {\n\t        if (el) {\n\t            el.trigger(state);\n\t            if (el.type === 'group') {\n\t                for (var i = 0; i < el.childCount(); i++) {\n\t                    elSetState(el.childAt(i), state);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @param  {module:echarts/data/List} data\n\t     * @param  {Object} payload\n\t     * @param  {string} state 'normal'|'emphasis'\n\t     * @inner\n\t     */\n\t    function toggleHighlight(data, payload, state) {\n\t        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\t\n\t        if (dataIndex != null) {\n\t            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n\t                elSetState(data.getItemGraphicEl(dataIdx), state);\n\t            });\n\t        }\n\t        else {\n\t            data.eachItemGraphicEl(function (el) {\n\t                elSetState(el, state);\n\t            });\n\t        }\n\t    }\n\t\n\t    // Enable Chart.extend.\n\t    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\t\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\t\n\t    module.exports = Chart;\n\n\n/***/ },\n/* 91 */,\n/* 92 */,\n/* 93 */,\n/* 94 */,\n/* 95 */,\n/* 96 */,\n/* 97 */,\n/* 98 */,\n/* 99 */,\n/* 100 */,\n/* 101 */,\n/* 102 */,\n/* 103 */,\n/* 104 */,\n/* 105 */,\n/* 106 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(3)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".el-tooltip,.el-tooltip__rel{display:inline-block}.el-tooltip__rel{position:relative}.el-tooltip__popper{position:absolute;border-radius:4px;padding:10px;z-index:2000;font-size:12px;line-height:1.2}.el-tooltip__popper .popper__arrow,.el-tooltip__popper .popper__arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.el-tooltip__popper .popper__arrow{border-width:6px}.el-tooltip__popper .popper__arrow:after{content:\\\" \\\";border-width:5px}.el-tooltip__popper[x-placement^=top]{margin-bottom:12px}.el-tooltip__popper[x-placement^=top] .popper__arrow{bottom:-6px;border-top-color:#1f2d3d;border-bottom-width:0}.el-tooltip__popper[x-placement^=top] .popper__arrow:after{bottom:1px;margin-left:-5px;border-top-color:#1f2d3d;border-bottom-width:0}.el-tooltip__popper[x-placement^=bottom]{margin-top:12px}.el-tooltip__popper[x-placement^=bottom] .popper__arrow{top:-6px;border-top-width:0;border-bottom-color:#1f2d3d}.el-tooltip__popper[x-placement^=bottom] .popper__arrow:after{top:1px;margin-left:-5px;border-top-width:0;border-bottom-color:#1f2d3d}.el-tooltip__popper[x-placement^=right]{margin-left:12px}.el-tooltip__popper[x-placement^=right] .popper__arrow{left:-6px;border-right-color:#1f2d3d;border-left-width:0}.el-tooltip__popper[x-placement^=right] .popper__arrow:after{bottom:-5px;left:1px;border-right-color:#1f2d3d;border-left-width:0}.el-tooltip__popper[x-placement^=left]{margin-right:12px}.el-tooltip__popper[x-placement^=left] .popper__arrow{right:-6px;border-right-width:0;border-left-color:#1f2d3d}.el-tooltip__popper[x-placement^=left] .popper__arrow:after{right:1px;bottom:-5px;margin-left:-5px;border-right-width:0;border-left-color:#1f2d3d}.el-tooltip__popper.is-light{background:#fff;border:1px solid #1f2d3d}.el-tooltip__popper.is-light[x-placement^=top] .popper__arrow{border-top-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=top] .popper__arrow:after{border-top-color:#fff}.el-tooltip__popper.is-light[x-placement^=bottom] .popper__arrow{border-bottom-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=bottom] .popper__arrow:after{border-bottom-color:#fff}.el-tooltip__popper.is-light[x-placement^=left] .popper__arrow{border-left-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=left] .popper__arrow:after{border-left-color:#fff}.el-tooltip__popper.is-light[x-placement^=right] .popper__arrow{border-right-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=right] .popper__arrow:after{border-right-color:#fff}.el-tooltip__popper.is-dark{background:#1f2d3d;color:#fff}\", \"\", {\"version\":3,\"sources\":[\"/./node_modules/element-ui/lib/theme-default/tooltip.css\"],\"names\":[],\"mappings\":\"AAAiB,6BAA6B,oBAAoB,CAAC,iBAAiB,iBAAiB,CAAC,oBAAoB,kBAAkB,kBAAkB,aAAa,aAAa,eAAe,eAAe,CAAC,4EAA6E,kBAAkB,cAAc,QAAQ,SAAS,yBAAyB,kBAAkB,CAAC,mCAAmC,gBAAgB,CAAC,yCAA0C,YAAY,gBAAgB,CAAC,sCAAsC,kBAAkB,CAAC,qDAAqD,YAAY,yBAAyB,qBAAqB,CAAC,2DAA4D,WAAW,iBAAiB,yBAAyB,qBAAqB,CAAC,yCAAyC,eAAe,CAAC,wDAAwD,SAAS,mBAAmB,2BAA2B,CAAC,8DAA+D,QAAQ,iBAAiB,mBAAmB,2BAA2B,CAAC,wCAAwC,gBAAgB,CAAC,uDAAuD,UAAU,2BAA2B,mBAAmB,CAAC,6DAA8D,YAAY,SAAS,2BAA2B,mBAAmB,CAAC,uCAAuC,iBAAiB,CAAC,sDAAsD,WAAW,qBAAqB,yBAAyB,CAAC,4DAA6D,UAAU,YAAY,iBAAiB,qBAAqB,yBAAyB,CAAC,6BAA6B,gBAAgB,wBAAwB,CAAC,8DAA8D,wBAAwB,CAAC,oEAAqE,qBAAqB,CAAC,iEAAiE,2BAA2B,CAAC,uEAAwE,wBAAwB,CAAC,+DAA+D,yBAAyB,CAAC,qEAAsE,sBAAsB,CAAC,gEAAgE,0BAA0B,CAAC,sEAAuE,uBAAuB,CAAC,4BAA4B,mBAAmB,UAAU,CAAC\",\"file\":\"tooltip.css\",\"sourcesContent\":[\"@charset \\\"UTF-8\\\";.el-tooltip,.el-tooltip__rel{display:inline-block}.el-tooltip__rel{position:relative}.el-tooltip__popper{position:absolute;border-radius:4px;padding:10px;z-index:2000;font-size:12px;line-height:1.2}.el-tooltip__popper .popper__arrow,.el-tooltip__popper .popper__arrow::after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.el-tooltip__popper .popper__arrow{border-width:6px}.el-tooltip__popper .popper__arrow::after{content:\\\" \\\";border-width:5px}.el-tooltip__popper[x-placement^=top]{margin-bottom:12px}.el-tooltip__popper[x-placement^=top] .popper__arrow{bottom:-6px;border-top-color:#1f2d3d;border-bottom-width:0}.el-tooltip__popper[x-placement^=top] .popper__arrow::after{bottom:1px;margin-left:-5px;border-top-color:#1f2d3d;border-bottom-width:0}.el-tooltip__popper[x-placement^=bottom]{margin-top:12px}.el-tooltip__popper[x-placement^=bottom] .popper__arrow{top:-6px;border-top-width:0;border-bottom-color:#1f2d3d}.el-tooltip__popper[x-placement^=bottom] .popper__arrow::after{top:1px;margin-left:-5px;border-top-width:0;border-bottom-color:#1f2d3d}.el-tooltip__popper[x-placement^=right]{margin-left:12px}.el-tooltip__popper[x-placement^=right] .popper__arrow{left:-6px;border-right-color:#1f2d3d;border-left-width:0}.el-tooltip__popper[x-placement^=right] .popper__arrow::after{bottom:-5px;left:1px;border-right-color:#1f2d3d;border-left-width:0}.el-tooltip__popper[x-placement^=left]{margin-right:12px}.el-tooltip__popper[x-placement^=left] .popper__arrow{right:-6px;border-right-width:0;border-left-color:#1f2d3d}.el-tooltip__popper[x-placement^=left] .popper__arrow::after{right:1px;bottom:-5px;margin-left:-5px;border-right-width:0;border-left-color:#1f2d3d}.el-tooltip__popper.is-light{background:#fff;border:1px solid #1f2d3d}.el-tooltip__popper.is-light[x-placement^=top] .popper__arrow{border-top-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=top] .popper__arrow::after{border-top-color:#fff}.el-tooltip__popper.is-light[x-placement^=bottom] .popper__arrow{border-bottom-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=bottom] .popper__arrow::after{border-bottom-color:#fff}.el-tooltip__popper.is-light[x-placement^=left] .popper__arrow{border-left-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=left] .popper__arrow::after{border-left-color:#fff}.el-tooltip__popper.is-light[x-placement^=right] .popper__arrow{border-right-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=right] .popper__arrow::after{border-right-color:#fff}.el-tooltip__popper.is-dark{background:#1f2d3d;color:#fff}\"],\"sourceRoot\":\"webpack://\"}]);\n\t\n\t// exports\n\n\n/***/ },\n/* 107 */,\n/* 108 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var echartsAPIList = [\n\t        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction', 'isDisposed',\n\t        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'\n\t    ];\n\t\n\t    function ExtensionAPI(chartInstance) {\n\t        zrUtil.each(echartsAPIList, function (name) {\n\t            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n\t        }, this);\n\t    }\n\t\n\t    module.exports = ExtensionAPI;\n\n\n/***/ },\n/* 109 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    // List layout\n\t    var layout = __webpack_require__(25);\n\t    var formatUtil = __webpack_require__(9);\n\t    var graphic = __webpack_require__(10);\n\t\n\t    function positionGroup(group, model, api) {\n\t        layout.positionElement(\n\t            group, model.getBoxLayoutParams(),\n\t            {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            },\n\t            model.get('padding')\n\t        );\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Layout list like component.\n\t         * It will box layout each items in group of component and then position the whole group in the viewport\n\t         * @param {module:zrender/group/Group} group\n\t         * @param {module:echarts/model/Component} componentModel\n\t         * @param {module:echarts/ExtensionAPI}\n\t         */\n\t        layout: function (group, componentModel, api) {\n\t            var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            }, componentModel.get('padding'));\n\t            layout.box(\n\t                componentModel.get('orient'),\n\t                group,\n\t                componentModel.get('itemGap'),\n\t                rect.width,\n\t                rect.height\n\t            );\n\t\n\t            positionGroup(group, componentModel, api);\n\t        },\n\t\n\t        addBackground: function (group, componentModel) {\n\t            var padding = formatUtil.normalizeCssArray(\n\t                componentModel.get('padding')\n\t            );\n\t            var boundingRect = group.getBoundingRect();\n\t            var style = componentModel.getItemStyle(['color', 'opacity']);\n\t            style.fill = componentModel.get('backgroundColor');\n\t            var rect = new graphic.Rect({\n\t                shape: {\n\t                    x: boundingRect.x - padding[3],\n\t                    y: boundingRect.y - padding[0],\n\t                    width: boundingRect.width + padding[1] + padding[3],\n\t                    height: boundingRect.height + padding[0] + padding[2]\n\t                },\n\t                style: style,\n\t                silent: true,\n\t                z2: -1\n\t            });\n\t            graphic.subPixelOptimizeRect(rect);\n\t\n\t            group.add(rect);\n\t        }\n\t    };\n\n\n/***/ },\n/* 110 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Legend component entry file8\n\t */\n\t\n\t\n\t    __webpack_require__(111);\n\t    __webpack_require__(113);\n\t    __webpack_require__(112);\n\t\n\t    var echarts = __webpack_require__(5);\n\t    // Series Filter\n\t    echarts.registerProcessor(__webpack_require__(114));\n\n\n/***/ },\n/* 111 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var Model = __webpack_require__(15);\n\t\n\t    var LegendModel = __webpack_require__(5).extendComponentModel({\n\t\n\t        type: 'legend',\n\t\n\t        dependencies: ['series'],\n\t\n\t        layoutMode: {\n\t            type: 'box',\n\t            ignoreSize: true\n\t        },\n\t\n\t        init: function (option, parentModel, ecModel) {\n\t            this.mergeDefaultAndTheme(option, ecModel);\n\t\n\t            option.selected = option.selected || {};\n\t        },\n\t\n\t        mergeOption: function (option) {\n\t            LegendModel.superCall(this, 'mergeOption', option);\n\t        },\n\t\n\t        optionUpdated: function () {\n\t            this._updateData(this.ecModel);\n\t\n\t            var legendData = this._data;\n\t\n\t            // If selectedMode is single, try to select one\n\t            if (legendData[0] && this.get('selectedMode') === 'single') {\n\t                var hasSelected = false;\n\t                // If has any selected in option.selected\n\t                for (var i = 0; i < legendData.length; i++) {\n\t                    var name = legendData[i].get('name');\n\t                    if (this.isSelected(name)) {\n\t                        // Force to unselect others\n\t                        this.select(name);\n\t                        hasSelected = true;\n\t                        break;\n\t                    }\n\t                }\n\t                // Try select the first if selectedMode is single\n\t                !hasSelected && this.select(legendData[0].get('name'));\n\t            }\n\t        },\n\t\n\t        _updateData: function (ecModel) {\n\t            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n\t                // Can be string or number\n\t                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n\t                    dataItem = {\n\t                        name: dataItem\n\t                    };\n\t                }\n\t                return new Model(dataItem, this, this.ecModel);\n\t            }, this);\n\t            this._data = legendData;\n\t\n\t            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n\t                return series.name;\n\t            });\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                if (seriesModel.legendDataProvider) {\n\t                    var data = seriesModel.legendDataProvider();\n\t                    availableNames = availableNames.concat(data.mapArray(data.getName));\n\t                }\n\t            });\n\t            /**\n\t             * @type {Array.<string>}\n\t             * @private\n\t             */\n\t            this._availableNames = availableNames;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:echarts/model/Model>}\n\t         */\n\t        getData: function () {\n\t            return this._data;\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        select: function (name) {\n\t            var selected = this.option.selected;\n\t            var selectedMode = this.get('selectedMode');\n\t            if (selectedMode === 'single') {\n\t                var data = this._data;\n\t                zrUtil.each(data, function (dataItem) {\n\t                    selected[dataItem.get('name')] = false;\n\t                });\n\t            }\n\t            selected[name] = true;\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        unSelect: function (name) {\n\t            if (this.get('selectedMode') !== 'single') {\n\t                this.option.selected[name] = false;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        toggleSelected: function (name) {\n\t            var selected = this.option.selected;\n\t            // Default is true\n\t            if (!selected.hasOwnProperty(name)) {\n\t                selected[name] = true;\n\t            }\n\t            this[selected[name] ? 'unSelect' : 'select'](name);\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        isSelected: function (name) {\n\t            var selected = this.option.selected;\n\t            return !(selected.hasOwnProperty(name) && !selected[name])\n\t                && zrUtil.indexOf(this._availableNames, name) >= 0;\n\t        },\n\t\n\t        defaultOption: {\n\t            // 一级层叠\n\t            zlevel: 0,\n\t            // 二级层叠\n\t            z: 4,\n\t            show: true,\n\t\n\t            // 布局方式，默认为水平布局，可选为：\n\t            // 'horizontal' | 'vertical'\n\t            orient: 'horizontal',\n\t\n\t            left: 'center',\n\t            // right: 'center',\n\t\n\t            top: 'top',\n\t            // bottom: 'top',\n\t\n\t            // 水平对齐\n\t            // 'auto' | 'left' | 'right'\n\t            // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐\n\t            align: 'auto',\n\t\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            // 图例边框颜色\n\t            borderColor: '#ccc',\n\t            // 图例边框线宽，单位px，默认为0（无边框）\n\t            borderWidth: 0,\n\t            // 图例内边距，单位px，默认各方向内边距为5，\n\t            // 接受数组分别设定上右下左边距，同css\n\t            padding: 5,\n\t            // 各个item之间的间隔，单位px，默认为10，\n\t            // 横向布局时为水平间隔，纵向布局时为纵向间隔\n\t            itemGap: 10,\n\t            // 图例图形宽度\n\t            itemWidth: 25,\n\t            // 图例图形高度\n\t            itemHeight: 14,\n\t\n\t            // 图例关闭时候的颜色\n\t            inactiveColor: '#ccc',\n\t\n\t            textStyle: {\n\t                // 图例文字颜色\n\t                color: '#333'\n\t            },\n\t            // formatter: '',\n\t            // 选择模式，默认开启图例开关\n\t            selectedMode: true,\n\t            // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入\n\t            // selected: null,\n\t            // 图例内容（详见legend.data，数组中每一项代表一个item\n\t            // data: [],\n\t\n\t            // Tooltip 相关配置\n\t            tooltip: {\n\t                show: false\n\t            }\n\t        }\n\t    });\n\t\n\t    module.exports = LegendModel;\n\n\n/***/ },\n/* 112 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var symbolCreator = __webpack_require__(135);\n\t    var graphic = __webpack_require__(10);\n\t    var listComponentHelper = __webpack_require__(109);\n\t\n\t    var curry = zrUtil.curry;\n\t\n\t    function dispatchSelectAction(name, api) {\n\t        api.dispatchAction({\n\t            type: 'legendToggleSelect',\n\t            name: name\n\t        });\n\t    }\n\t\n\t    function dispatchHighlightAction(seriesModel, dataName, api) {\n\t        // If element hover will move to a hoverLayer.\n\t        var el = api.getZr().storage.getDisplayList()[0];\n\t        if (!(el && el.useHoverLayer)) {\n\t            seriesModel.get('legendHoverLink') && api.dispatchAction({\n\t                type: 'highlight',\n\t                seriesName: seriesModel.name,\n\t                name: dataName\n\t            });\n\t        }\n\t    }\n\t\n\t    function dispatchDownplayAction(seriesModel, dataName, api) {\n\t        // If element hover will move to a hoverLayer.\n\t        var el = api.getZr().storage.getDisplayList()[0];\n\t        if (!(el && el.useHoverLayer)) {\n\t            seriesModel.get('legendHoverLink') && api.dispatchAction({\n\t                type: 'downplay',\n\t                seriesName: seriesModel.name,\n\t                name: dataName\n\t            });\n\t        }\n\t    }\n\t\n\t    module.exports = __webpack_require__(5).extendComponentView({\n\t\n\t        type: 'legend',\n\t\n\t        init: function () {\n\t            this._symbolTypeStore = {};\n\t        },\n\t\n\t        render: function (legendModel, ecModel, api) {\n\t            var group = this.group;\n\t            group.removeAll();\n\t\n\t            if (!legendModel.get('show')) {\n\t                return;\n\t            }\n\t\n\t            var selectMode = legendModel.get('selectedMode');\n\t            var itemAlign = legendModel.get('align');\n\t\n\t            if (itemAlign === 'auto') {\n\t                itemAlign = (legendModel.get('left') === 'right'\n\t                    && legendModel.get('orient') === 'vertical')\n\t                    ? 'right' : 'left';\n\t            }\n\t\n\t            var legendDrawedMap = {};\n\t\n\t            zrUtil.each(legendModel.getData(), function (itemModel) {\n\t                var name = itemModel.get('name');\n\t\n\t                // Use empty string or \\n as a newline string\n\t                if (name === '' || name === '\\n') {\n\t                    group.add(new graphic.Group({\n\t                        newline: true\n\t                    }));\n\t                    return;\n\t                }\n\t\n\t                var seriesModel = ecModel.getSeriesByName(name)[0];\n\t\n\t                if (legendDrawedMap[name]) {\n\t                    // Have been drawed\n\t                    return;\n\t                }\n\t\n\t                // Series legend\n\t                if (seriesModel) {\n\t                    var data = seriesModel.getData();\n\t                    var color = data.getVisual('color');\n\t\n\t                    // If color is a callback function\n\t                    if (typeof color === 'function') {\n\t                        // Use the first data\n\t                        color = color(seriesModel.getDataParams(0));\n\t                    }\n\t\n\t                    // Using rect symbol defaultly\n\t                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n\t                    var symbolType = data.getVisual('symbol');\n\t\n\t                    var itemGroup = this._createItem(\n\t                        name, itemModel, legendModel,\n\t                        legendSymbolType, symbolType,\n\t                        itemAlign, color,\n\t                        selectMode\n\t                    );\n\t\n\t                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n\t                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n\t                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\t\n\t                    legendDrawedMap[name] = true;\n\t                }\n\t                else {\n\t                    // Data legend of pie, funnel\n\t                    ecModel.eachRawSeries(function (seriesModel) {\n\t                        // In case multiple series has same data name\n\t                        if (legendDrawedMap[name]) {\n\t                            return;\n\t                        }\n\t                        if (seriesModel.legendDataProvider) {\n\t                            var data = seriesModel.legendDataProvider();\n\t                            var idx = data.indexOfName(name);\n\t                            if (idx < 0) {\n\t                                return;\n\t                            }\n\t\n\t                            var color = data.getItemVisual(idx, 'color');\n\t\n\t                            var legendSymbolType = 'roundRect';\n\t\n\t                            var itemGroup = this._createItem(\n\t                                name, itemModel, legendModel,\n\t                                legendSymbolType, null,\n\t                                itemAlign, color,\n\t                                selectMode\n\t                            );\n\t\n\t                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n\t                                // FIXME Should not specify the series name\n\t                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n\t                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\t\n\t                            legendDrawedMap[name] = true;\n\t                        }\n\t                    }, this);\n\t                }\n\t\n\t                if (__DEV__) {\n\t                    if (!legendDrawedMap[name]) {\n\t                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n\t                    }\n\t                }\n\t            }, this);\n\t\n\t            listComponentHelper.layout(group, legendModel, api);\n\t            // Render background after group is layout\n\t            // FIXME\n\t            listComponentHelper.addBackground(group, legendModel);\n\t        },\n\t\n\t        _createItem: function (\n\t            name, itemModel, legendModel,\n\t            legendSymbolType, symbolType,\n\t            itemAlign, color, selectMode\n\t        ) {\n\t            var itemWidth = legendModel.get('itemWidth');\n\t            var itemHeight = legendModel.get('itemHeight');\n\t            var inactiveColor = legendModel.get('inactiveColor');\n\t\n\t            var isSelected = legendModel.isSelected(name);\n\t            var itemGroup = new graphic.Group();\n\t\n\t            var textStyleModel = itemModel.getModel('textStyle');\n\t\n\t            var itemIcon = itemModel.get('icon');\n\t\n\t            var tooltipModel = itemModel.getModel('tooltip');\n\t            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\t\n\t            // Use user given icon first\n\t            legendSymbolType = itemIcon || legendSymbolType;\n\t            itemGroup.add(symbolCreator.createSymbol(\n\t                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n\t            ));\n\t\n\t            // Compose symbols\n\t            // PENDING\n\t            if (!itemIcon && symbolType\n\t                // At least show one symbol, can't be all none\n\t                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n\t            ) {\n\t                var size = itemHeight * 0.8;\n\t                if (symbolType === 'none') {\n\t                    symbolType = 'circle';\n\t                }\n\t                // Put symbol in the center\n\t                itemGroup.add(symbolCreator.createSymbol(\n\t                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n\t                    isSelected ? color : inactiveColor\n\t                ));\n\t            }\n\t\n\t            // Text\n\t            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n\t            var textAlign = itemAlign;\n\t\n\t            var formatter = legendModel.get('formatter');\n\t            var content = name;\n\t            if (typeof formatter === 'string' && formatter) {\n\t                content = formatter.replace('{name}', name != null ? name : '');\n\t            }\n\t            else if (typeof formatter === 'function') {\n\t                content = formatter(name);\n\t            }\n\t\n\t            var text = new graphic.Text({\n\t                style: {\n\t                    text: content,\n\t                    x: textX,\n\t                    y: itemHeight / 2,\n\t                    fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n\t                    textFont: textStyleModel.getFont(),\n\t                    textAlign: textAlign,\n\t                    textVerticalAlign: 'middle'\n\t                }\n\t            });\n\t            itemGroup.add(text);\n\t\n\t            // Add a invisible rect to increase the area of mouse hover\n\t            var hitRect = new graphic.Rect({\n\t                shape: itemGroup.getBoundingRect(),\n\t                invisible: true,\n\t                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n\t                    content: name,\n\t                    // Defaul formatter\n\t                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n\t                        return name;\n\t                    },\n\t                    formatterParams: {\n\t                        componentType: 'legend',\n\t                        legendIndex: legendModel.componentIndex,\n\t                        name: name,\n\t                        $vars: ['name']\n\t                    }\n\t                }, tooltipModel.option) : null\n\t            });\n\t            itemGroup.add(hitRect);\n\t\n\t            itemGroup.eachChild(function (child) {\n\t                child.silent = true;\n\t            });\n\t\n\t            hitRect.silent = !selectMode;\n\t\n\t\n\t\n\t            this.group.add(itemGroup);\n\t\n\t            graphic.setHoverStyle(itemGroup);\n\t\n\t            return itemGroup;\n\t        }\n\t    });\n\n\n/***/ },\n/* 113 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file Legend action\n\t */\n\t\n\t\n\t    var echarts = __webpack_require__(5);\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    function legendSelectActionHandler(methodName, payload, ecModel) {\n\t        var selectedMap = {};\n\t        var isToggleSelect = methodName === 'toggleSelected';\n\t        var isSelected;\n\t        // Update all legend components\n\t        ecModel.eachComponent('legend', function (legendModel) {\n\t            if (isToggleSelect && isSelected != null) {\n\t                // Force other legend has same selected status\n\t                // Or the first is toggled to true and other are toggled to false\n\t                // In the case one legend has some item unSelected in option. And if other legend\n\t                // doesn't has the item, they will assume it is selected.\n\t                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n\t            }\n\t            else {\n\t                legendModel[methodName](payload.name);\n\t                isSelected = legendModel.isSelected(payload.name);\n\t            }\n\t            var legendData = legendModel.getData();\n\t            zrUtil.each(legendData, function (model) {\n\t                var name = model.get('name');\n\t                // Wrap element\n\t                if (name === '\\n' || name === '') {\n\t                    return;\n\t                }\n\t                var isItemSelected = legendModel.isSelected(name);\n\t                if (name in selectedMap) {\n\t                    // Unselected if any legend is unselected\n\t                    selectedMap[name] = selectedMap[name] && isItemSelected;\n\t                }\n\t                else {\n\t                    selectedMap[name] = isItemSelected;\n\t                }\n\t            });\n\t        });\n\t        // Return the event explicitly\n\t        return {\n\t            name: payload.name,\n\t            selected: selectedMap\n\t        };\n\t    }\n\t    /**\n\t     * @event legendToggleSelect\n\t     * @type {Object}\n\t     * @property {string} type 'legendToggleSelect'\n\t     * @property {string} [from]\n\t     * @property {string} name Series name or data item name\n\t     */\n\t    echarts.registerAction(\n\t        'legendToggleSelect', 'legendselectchanged',\n\t        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n\t    );\n\t\n\t    /**\n\t     * @event legendSelect\n\t     * @type {Object}\n\t     * @property {string} type 'legendSelect'\n\t     * @property {string} name Series name or data item name\n\t     */\n\t    echarts.registerAction(\n\t        'legendSelect', 'legendselected',\n\t        zrUtil.curry(legendSelectActionHandler, 'select')\n\t    );\n\t\n\t    /**\n\t     * @event legendUnSelect\n\t     * @type {Object}\n\t     * @property {string} type 'legendUnSelect'\n\t     * @property {string} name Series name or data item name\n\t     */\n\t    echarts.registerAction(\n\t        'legendUnSelect', 'legendunselected',\n\t        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n\t    );\n\n\n/***/ },\n/* 114 */\n/***/ function(module, exports) {\n\n\t\n\t   module.exports = function (ecModel) {\n\t        var legendModels = ecModel.findComponents({\n\t            mainType: 'legend'\n\t        });\n\t        if (legendModels && legendModels.length) {\n\t            ecModel.filterSeries(function (series) {\n\t                // If in any legend component the status is not selected.\n\t                // Because in legend series is assumed selected when it is not in the legend data.\n\t                for (var i = 0; i < legendModels.length; i++) {\n\t                    if (!legendModels[i].isSelected(series.name)) {\n\t                        return false;\n\t                    }\n\t                }\n\t                return true;\n\t            });\n\t        }\n\t    };\n\n\n/***/ },\n/* 115 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// FIXME Better way to pack data in graphic element\n\t\n\t\n\t    __webpack_require__(117);\n\t\n\t    __webpack_require__(118);\n\t\n\t    // Show tip action\n\t    /**\n\t     * @action\n\t     * @property {string} type\n\t     * @property {number} seriesIndex\n\t     * @property {number} dataIndex\n\t     * @property {number} [x]\n\t     * @property {number} [y]\n\t     */\n\t    __webpack_require__(5).registerAction(\n\t        {\n\t            type: 'showTip',\n\t            event: 'showTip',\n\t            update: 'none'\n\t        },\n\t        // noop\n\t        function () {}\n\t    );\n\t    // Hide tip action\n\t    __webpack_require__(5).registerAction(\n\t        {\n\t            type: 'hideTip',\n\t            event: 'hideTip',\n\t            update: 'none'\n\t        },\n\t        // noop\n\t        function () {}\n\t    );\n\n\n/***/ },\n/* 116 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/component/tooltip/TooltipContent\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var zrColor = __webpack_require__(29);\n\t    var eventUtil = __webpack_require__(42);\n\t    var formatUtil = __webpack_require__(9);\n\t    var each = zrUtil.each;\n\t    var toCamelCase = formatUtil.toCamelCase;\n\t    var env = __webpack_require__(14);\n\t\n\t    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\t\n\t    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\t\n\t    /**\n\t     * @param {number} duration\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    function assembleTransition(duration) {\n\t        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n\t        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n\t                            + 'top ' + duration + 's ' + transitionCurve;\n\t        return zrUtil.map(vendors, function (vendorPrefix) {\n\t            return vendorPrefix + 'transition:' + transitionText;\n\t        }).join(';');\n\t    }\n\t\n\t    /**\n\t     * @param {Object} textStyle\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    function assembleFont(textStyleModel) {\n\t        var cssText = [];\n\t\n\t        var fontSize = textStyleModel.get('fontSize');\n\t        var color = textStyleModel.getTextColor();\n\t\n\t        color && cssText.push('color:' + color);\n\t\n\t        cssText.push('font:' + textStyleModel.getFont());\n\t\n\t        fontSize &&\n\t            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\t\n\t        each(['decoration', 'align'], function (name) {\n\t            var val = textStyleModel.get(name);\n\t            val && cssText.push('text-' + name + ':' + val);\n\t        });\n\t\n\t        return cssText.join(';');\n\t    }\n\t\n\t    /**\n\t     * @param {Object} tooltipModel\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    function assembleCssText(tooltipModel) {\n\t\n\t        tooltipModel = tooltipModel;\n\t\n\t        var cssText = [];\n\t\n\t        var transitionDuration = tooltipModel.get('transitionDuration');\n\t        var backgroundColor = tooltipModel.get('backgroundColor');\n\t        var textStyleModel = tooltipModel.getModel('textStyle');\n\t        var padding = tooltipModel.get('padding');\n\t\n\t        // Animation transition\n\t        transitionDuration &&\n\t            cssText.push(assembleTransition(transitionDuration));\n\t\n\t        if (backgroundColor) {\n\t            if (env.canvasSupported) {\n\t                cssText.push('background-Color:' + backgroundColor);\n\t            }\n\t            else {\n\t                // for ie\n\t                cssText.push(\n\t                    'background-Color:#' + zrColor.toHex(backgroundColor)\n\t                );\n\t                cssText.push('filter:alpha(opacity=70)');\n\t            }\n\t        }\n\t\n\t        // Border style\n\t        each(['width', 'color', 'radius'], function (name) {\n\t            var borderName = 'border-' + name;\n\t            var camelCase = toCamelCase(borderName);\n\t            var val = tooltipModel.get(camelCase);\n\t            val != null &&\n\t                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n\t        });\n\t\n\t        // Text style\n\t        cssText.push(assembleFont(textStyleModel));\n\t\n\t        // Padding\n\t        if (padding != null) {\n\t            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n\t        }\n\t\n\t        return cssText.join(';') + ';';\n\t    }\n\t\n\t    /**\n\t     * @alias module:echarts/component/tooltip/TooltipContent\n\t     * @constructor\n\t     */\n\t    function TooltipContent(container, api) {\n\t        var el = document.createElement('div');\n\t        var zr = api.getZr();\n\t\n\t        this.el = el;\n\t\n\t        this._x = api.getWidth() / 2;\n\t        this._y = api.getHeight() / 2;\n\t\n\t        container.appendChild(el);\n\t\n\t        this._container = container;\n\t\n\t        this._show = false;\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        this._hideTimeout;\n\t\n\t        var self = this;\n\t        el.onmouseenter = function () {\n\t            // clear the timeout in hideLater and keep showing tooltip\n\t            if (self.enterable) {\n\t                clearTimeout(self._hideTimeout);\n\t                self._show = true;\n\t            }\n\t            self._inContent = true;\n\t        };\n\t        el.onmousemove = function (e) {\n\t            e = e || window.event;\n\t            if (!self.enterable) {\n\t                // Try trigger zrender event to avoid mouse\n\t                // in and out shape too frequently\n\t                var handler = zr.handler;\n\t                eventUtil.normalizeEvent(container, e, true);\n\t                handler.dispatch('mousemove', e);\n\t            }\n\t        };\n\t        el.onmouseleave = function () {\n\t            if (self.enterable) {\n\t                if (self._show) {\n\t                    self.hideLater(self._hideDelay);\n\t                }\n\t            }\n\t            self._inContent = false;\n\t        };\n\t    }\n\t\n\t    TooltipContent.prototype = {\n\t\n\t        constructor: TooltipContent,\n\t\n\t        enterable: true,\n\t\n\t        /**\n\t         * Update when tooltip is rendered\n\t         */\n\t        update: function () {\n\t            var container = this._container;\n\t            var stl = container.currentStyle\n\t                || document.defaultView.getComputedStyle(container);\n\t            var domStyle = container.style;\n\t            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n\t                domStyle.position = 'relative';\n\t            }\n\t            // Hide the tooltip\n\t            // PENDING\n\t            // this.hide();\n\t        },\n\t\n\t        show: function (tooltipModel) {\n\t            clearTimeout(this._hideTimeout);\n\t            var el = this.el;\n\t\n\t            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n\t                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n\t                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n\t                + (tooltipModel.get('extraCssText') || '');\n\t\n\t            el.style.display = el.innerHTML ?  'block' : 'none';\n\t\n\t            this._show = true;\n\t        },\n\t\n\t        setContent: function (content) {\n\t            var el = this.el;\n\t            el.innerHTML = content;\n\t            el.style.display = content ? 'block' : 'none';\n\t        },\n\t\n\t        moveTo: function (x, y) {\n\t            var style = this.el.style;\n\t            style.left = x + 'px';\n\t            style.top = y + 'px';\n\t\n\t            this._x = x;\n\t            this._y = y;\n\t        },\n\t\n\t        hide: function () {\n\t            this.el.style.display = 'none';\n\t            this._show = false;\n\t        },\n\t\n\t        // showLater: function ()\n\t\n\t        hideLater: function (time) {\n\t            if (this._show && !(this._inContent && this.enterable)) {\n\t                if (time) {\n\t                    this._hideDelay = time;\n\t                    // Set show false to avoid invoke hideLater mutiple times\n\t                    this._show = false;\n\t                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n\t                }\n\t                else {\n\t                    this.hide();\n\t                }\n\t            }\n\t        },\n\t\n\t        isShow: function () {\n\t            return this._show;\n\t        }\n\t    };\n\t\n\t    module.exports = TooltipContent;\n\n\n/***/ },\n/* 117 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    __webpack_require__(5).extendComponentModel({\n\t\n\t        type: 'tooltip',\n\t\n\t        defaultOption: {\n\t            zlevel: 0,\n\t\n\t            z: 8,\n\t\n\t            show: true,\n\t\n\t            // tooltip主体内容\n\t            showContent: true,\n\t\n\t            // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis'\n\t            trigger: 'item',\n\t\n\t            // 触发条件，支持 'click' | 'mousemove' | 'none'\n\t            triggerOn: 'mousemove',\n\t\n\t            // 是否永远显示 content\n\t            alwaysShowContent: false,\n\t\n\t            // 位置 {Array} | {Function}\n\t            // position: null\n\t\n\t            // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。\n\t            confine: false,\n\t\n\t            // 内容格式器：{string}（Template） ¦ {Function}\n\t            // formatter: null\n\t\n\t            showDelay: 0,\n\t\n\t            // 隐藏延迟，单位ms\n\t            hideDelay: 100,\n\t\n\t            // 动画变换时间，单位s\n\t            transitionDuration: 0.4,\n\t\n\t            enterable: false,\n\t\n\t            // 提示背景颜色，默认为透明度为0.7的黑色\n\t            backgroundColor: 'rgba(50,50,50,0.7)',\n\t\n\t            // 提示边框颜色\n\t            borderColor: '#333',\n\t\n\t            // 提示边框圆角，单位px，默认为4\n\t            borderRadius: 4,\n\t\n\t            // 提示边框线宽，单位px，默认为0（无边框）\n\t            borderWidth: 0,\n\t\n\t            // 提示内边距，单位px，默认各方向内边距为5，\n\t            // 接受数组分别设定上右下左边距，同css\n\t            padding: 5,\n\t\n\t            // Extra css text\n\t            extraCssText: '',\n\t\n\t            // 坐标轴指示器，坐标轴触发有效\n\t            axisPointer: {\n\t                // 默认为直线\n\t                // 可选为：'line' | 'shadow' | 'cross'\n\t                type: 'line',\n\t\n\t                // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选\n\t                // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'\n\t                // 默认 'auto'，会选择类型为 cateogry 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴\n\t                // 极坐标系会默认选择 angle 轴\n\t                axis: 'auto',\n\t\n\t                animation: true,\n\t                animationDurationUpdate: 200,\n\t                animationEasingUpdate: 'exponentialOut',\n\t\n\t                // 直线指示器样式设置\n\t                lineStyle: {\n\t                    color: '#555',\n\t                    width: 1,\n\t                    type: 'solid'\n\t                },\n\t\n\t                crossStyle: {\n\t                    color: '#555',\n\t                    width: 1,\n\t                    type: 'dashed',\n\t\n\t                    // TODO formatter\n\t                    textStyle: {}\n\t                },\n\t\n\t                // 阴影指示器样式设置\n\t                shadowStyle: {\n\t                    color: 'rgba(150,150,150,0.3)'\n\t                }\n\t            },\n\t            textStyle: {\n\t                color: '#fff',\n\t                fontSize: 14\n\t            }\n\t        }\n\t    });\n\n\n/***/ },\n/* 118 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var TooltipContent = __webpack_require__(116);\n\t    var graphic = __webpack_require__(10);\n\t    var zrUtil = __webpack_require__(1);\n\t    var formatUtil = __webpack_require__(9);\n\t    var numberUtil = __webpack_require__(12);\n\t    var modelUtil = __webpack_require__(11);\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var env = __webpack_require__(14);\n\t    var Model = __webpack_require__(15);\n\t\n\t    function dataEqual(a, b) {\n\t        if (!a || !b) {\n\t            return false;\n\t        }\n\t        var round = numberUtil.round;\n\t        return round(a[0]) === round(b[0])\n\t            && round(a[1]) === round(b[1]);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeLineShape(x1, y1, x2, y2) {\n\t        return {\n\t            x1: x1,\n\t            y1: y1,\n\t            x2: x2,\n\t            y2: y2\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeRectShape(x, y, width, height) {\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            width: width,\n\t            height: height\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n\t        return {\n\t            cx: cx,\n\t            cy: cy,\n\t            r0: r0,\n\t            r: r,\n\t            startAngle: startAngle,\n\t            endAngle: endAngle,\n\t            clockwise: true\n\t        };\n\t    }\n\t\n\t    function refixTooltipPosition(x, y, el, viewWidth, viewHeight) {\n\t        var width = el.clientWidth;\n\t        var height = el.clientHeight;\n\t        var gap = 20;\n\t\n\t        if (x + width + gap > viewWidth) {\n\t            x -= width + gap;\n\t        }\n\t        else {\n\t            x += gap;\n\t        }\n\t        if (y + height + gap > viewHeight) {\n\t            y -= height + gap;\n\t        }\n\t        else {\n\t            y += gap;\n\t        }\n\t        return [x, y];\n\t    }\n\t\n\t    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n\t        var width = el.clientWidth;\n\t        var height = el.clientHeight;\n\t\n\t        x = Math.min(x + width, viewWidth) - width;\n\t        y = Math.min(y + height, viewHeight) - height;\n\t        x = Math.max(x, 0);\n\t        y = Math.max(y, 0);\n\t\n\t        return [x, y];\n\t    }\n\t\n\t    function calcTooltipPosition(position, rect, dom) {\n\t        var domWidth = dom.clientWidth;\n\t        var domHeight = dom.clientHeight;\n\t        var gap = 5;\n\t        var x = 0;\n\t        var y = 0;\n\t        var rectWidth = rect.width;\n\t        var rectHeight = rect.height;\n\t        switch (position) {\n\t            case 'inside':\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\n\t                break;\n\t            case 'top':\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\n\t                y = rect.y - domHeight - gap;\n\t                break;\n\t            case 'bottom':\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\n\t                y = rect.y + rectHeight + gap;\n\t                break;\n\t            case 'left':\n\t                x = rect.x - domWidth - gap;\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\n\t                break;\n\t            case 'right':\n\t                x = rect.x + rectWidth + gap;\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\n\t        }\n\t        return [x, y];\n\t    }\n\t\n\t    /**\n\t     * @param  {string|Function|Array.<number>} positionExpr\n\t     * @param  {number} x Mouse x\n\t     * @param  {number} y Mouse y\n\t     * @param  {boolean} confine Whether confine tooltip content in view rect.\n\t     * @param  {module:echarts/component/tooltip/TooltipContent} content\n\t     * @param  {Object|<Array.<Object>} params\n\t     * @param  {module:zrender/Element} el target element\n\t     * @param  {module:echarts/ExtensionAPI} api\n\t     * @return {Array.<number>}\n\t     */\n\t    function updatePosition(positionExpr, x, y, confine, content, params, el, api) {\n\t        var viewWidth = api.getWidth();\n\t        var viewHeight = api.getHeight();\n\t\n\t        var rect = el && el.getBoundingRect().clone();\n\t        el && rect.applyTransform(el.transform);\n\t        if (typeof positionExpr === 'function') {\n\t            // Callback of position can be an array or a string specify the position\n\t            positionExpr = positionExpr([x, y], params, content.el, rect);\n\t        }\n\t\n\t        if (zrUtil.isArray(positionExpr)) {\n\t            x = parsePercent(positionExpr[0], viewWidth);\n\t            y = parsePercent(positionExpr[1], viewHeight);\n\t        }\n\t        // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n\t        else if (typeof positionExpr === 'string' && el) {\n\t            var pos = calcTooltipPosition(\n\t                positionExpr, rect, content.el\n\t            );\n\t            x = pos[0];\n\t            y = pos[1];\n\t        }\n\t        else {\n\t            var pos = refixTooltipPosition(\n\t                x, y, content.el, viewWidth, viewHeight\n\t            );\n\t            x = pos[0];\n\t            y = pos[1];\n\t        }\n\t\n\t        if (confine) {\n\t            var pos = confineTooltipPosition(\n\t                x, y, content.el, viewWidth, viewHeight\n\t            );\n\t            x = pos[0];\n\t            y = pos[1];\n\t        }\n\t\n\t        content.moveTo(x, y);\n\t    }\n\t\n\t    function ifSeriesSupportAxisTrigger(seriesModel) {\n\t        var coordSys = seriesModel.coordinateSystem;\n\t        var trigger = seriesModel.get('tooltip.trigger', true);\n\t        // Ignore series use item tooltip trigger and series coordinate system is not cartesian or\n\t        return !(!coordSys\n\t            || (coordSys.type !== 'cartesian2d' && coordSys.type !== 'polar' && coordSys.type !== 'singleAxis')\n\t            || trigger === 'item');\n\t    }\n\t\n\t    __webpack_require__(5).extendComponentView({\n\t\n\t        type: 'tooltip',\n\t\n\t        _axisPointers: {},\n\t\n\t        init: function (ecModel, api) {\n\t            if (env.node) {\n\t                return;\n\t            }\n\t            var tooltipContent = new TooltipContent(api.getDom(), api);\n\t            this._tooltipContent = tooltipContent;\n\t\n\t            api.on('showTip', this._manuallyShowTip, this);\n\t            api.on('hideTip', this._manuallyHideTip, this);\n\t        },\n\t\n\t        render: function (tooltipModel, ecModel, api) {\n\t            if (env.node) {\n\t                return;\n\t            }\n\t\n\t            // Reset\n\t            this.group.removeAll();\n\t\n\t            /**\n\t             * @type {Object}\n\t             * @private\n\t             */\n\t            this._axisPointers = {};\n\t\n\t            /**\n\t             * @private\n\t             * @type {module:echarts/component/tooltip/TooltipModel}\n\t             */\n\t            this._tooltipModel = tooltipModel;\n\t\n\t            /**\n\t             * @private\n\t             * @type {module:echarts/model/Global}\n\t             */\n\t            this._ecModel = ecModel;\n\t\n\t            /**\n\t             * @private\n\t             * @type {module:echarts/ExtensionAPI}\n\t             */\n\t            this._api = api;\n\t\n\t            /**\n\t             * @type {Object}\n\t             * @private\n\t             */\n\t            this._lastHover = {\n\t                // data\n\t                // payloadBatch\n\t            };\n\t\n\t            var tooltipContent = this._tooltipContent;\n\t            tooltipContent.update();\n\t            tooltipContent.enterable = tooltipModel.get('enterable');\n\t            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\t\n\t            /**\n\t             * @type {Object.<string, Array>}\n\t             */\n\t            this._seriesGroupByAxis = this._prepareAxisTriggerData(\n\t                tooltipModel, ecModel\n\t            );\n\t\n\t            var crossText = this._crossText;\n\t            if (crossText) {\n\t                this.group.add(crossText);\n\t            }\n\t\n\t            var triggerOn = tooltipModel.get('triggerOn');\n\t\n\t            // Try to keep the tooltip show when refreshing\n\t            if (this._lastX != null\n\t                && this._lastY != null\n\t                // When user is willing to control tooltip totally using API,\n\t                // self._manuallyShowTip({x, y}) might cause tooltip hide,\n\t                // which is not expected.\n\t                && triggerOn !== 'none'\n\t            ) {\n\t                var self = this;\n\t                clearTimeout(this._refreshUpdateTimeout);\n\t                this._refreshUpdateTimeout = setTimeout(function () {\n\t                    // Show tip next tick after other charts are rendered\n\t                    // In case highlight action has wrong result\n\t                    // FIXME\n\t                    self._manuallyShowTip({\n\t                        x: self._lastX,\n\t                        y: self._lastY\n\t                    });\n\t                });\n\t            }\n\t\n\t            var zr = this._api.getZr();\n\t            zr.off('click', this._tryShow);\n\t            zr.off('mousemove', this._mousemove);\n\t            zr.off('mouseout', this._hide);\n\t            zr.off('globalout', this._hide);\n\t\n\t            if (triggerOn === 'click') {\n\t                zr.on('click', this._tryShow, this);\n\t            }\n\t            else if (triggerOn === 'mousemove') {\n\t                zr.on('mousemove', this._mousemove, this);\n\t                zr.on('mouseout', this._hide, this);\n\t                zr.on('globalout', this._hide, this);\n\t            }\n\t            // else triggerOn is 'none', which enable user\n\t            // to control tooltip totally using API.\n\t        },\n\t\n\t        _mousemove: function (e) {\n\t            var showDelay = this._tooltipModel.get('showDelay');\n\t            var self = this;\n\t            clearTimeout(this._showTimeout);\n\t            if (showDelay > 0) {\n\t                this._showTimeout = setTimeout(function () {\n\t                    self._tryShow(e);\n\t                }, showDelay);\n\t            }\n\t            else {\n\t                this._tryShow(e);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tip manually by\n\t         * dispatchAction({\n\t         *     type: 'showTip',\n\t         *     x: 10,\n\t         *     y: 10\n\t         * });\n\t         * Or\n\t         * dispatchAction({\n\t         *      type: 'showTip',\n\t         *      seriesIndex: 0,\n\t         *      dataIndex or dataIndexInside or name\n\t         * });\n\t         *\n\t         *  TODO Batch\n\t         */\n\t        _manuallyShowTip: function (event) {\n\t            // From self\n\t            if (event.from === this.uid) {\n\t                return;\n\t            }\n\t\n\t            var ecModel = this._ecModel;\n\t            var seriesIndex = event.seriesIndex;\n\t            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\t            var api = this._api;\n\t\n\t            var isTriggerAxis = this._tooltipModel.get('trigger') === 'axis';\n\t            function seriesHaveDataOnIndex(_series) {\n\t                var data = _series.getData();\n\t                var dataIndex = modelUtil.queryDataIndex(data, event);\n\t                // Have single dataIndex\n\t                if (dataIndex != null && !zrUtil.isArray(dataIndex)\n\t                    && data.hasValue(dataIndex)\n\t                ) {\n\t                    return true;\n\t                }\n\t            }\n\t\n\t            if (event.x == null || event.y == null) {\n\t                if (isTriggerAxis) {\n\t                    // Find another series.\n\t                    if (seriesModel && !seriesHaveDataOnIndex(seriesModel)) {\n\t                        seriesModel = null;\n\t                    }\n\t                    if (!seriesModel) {\n\t                        // Find the first series can use axis trigger And data is not null\n\t                        ecModel.eachSeries(function (_series) {\n\t                            if (ifSeriesSupportAxisTrigger(_series) && !seriesModel) {\n\t                                if (seriesHaveDataOnIndex(_series)) {\n\t                                    seriesModel = _series;\n\t                                }\n\t                            }\n\t                        });\n\t                    }\n\t                }\n\t                else {\n\t                    // Use the first series by default.\n\t                    seriesModel = seriesModel || ecModel.getSeriesByIndex(0);\n\t                }\n\t                if (seriesModel) {\n\t                    var data = seriesModel.getData();\n\t                    var dataIndex = modelUtil.queryDataIndex(data, event);\n\t\n\t                    if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n\t                        return;\n\t                    }\n\t\n\t                    var el = data.getItemGraphicEl(dataIndex);\n\t                    var cx;\n\t                    var cy;\n\t                    // Try to get the point in coordinate system\n\t                    var coordSys = seriesModel.coordinateSystem;\n\t                    if (seriesModel.getTooltipPosition) {\n\t                        var point = seriesModel.getTooltipPosition(dataIndex) || [];\n\t                        cx = point[0];\n\t                        cy = point[1];\n\t                    }\n\t                    else if (coordSys && coordSys.dataToPoint) {\n\t                        var point = coordSys.dataToPoint(\n\t                            data.getValues(\n\t                                zrUtil.map(coordSys.dimensions, function (dim) {\n\t                                    return seriesModel.coordDimToDataDim(dim)[0];\n\t                                }), dataIndex, true\n\t                            )\n\t                        );\n\t                        cx = point && point[0];\n\t                        cy = point && point[1];\n\t                    }\n\t                    else if (el) {\n\t                        // Use graphic bounding rect\n\t                        var rect = el.getBoundingRect().clone();\n\t                        rect.applyTransform(el.transform);\n\t                        cx = rect.x + rect.width / 2;\n\t                        cy = rect.y + rect.height / 2;\n\t                    }\n\t\n\t                    if (cx != null && cy != null) {\n\t                        this._tryShow({\n\t                            offsetX: cx,\n\t                            offsetY: cy,\n\t                            position: event.position,\n\t                            target: el,\n\t                            event: {}\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                var el = api.getZr().handler.findHover(event.x, event.y);\n\t                this._tryShow({\n\t                    offsetX: event.x,\n\t                    offsetY: event.y,\n\t                    position: event.position,\n\t                    target: el,\n\t                    event: {}\n\t                });\n\t            }\n\t        },\n\t\n\t        _manuallyHideTip: function (e) {\n\t            if (e.from === this.uid) {\n\t                return;\n\t            }\n\t\n\t            this._hide();\n\t        },\n\t\n\t        _prepareAxisTriggerData: function (tooltipModel, ecModel) {\n\t            // Prepare data for axis trigger\n\t            var seriesGroupByAxis = {};\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                if (ifSeriesSupportAxisTrigger(seriesModel)) {\n\t                    var coordSys = seriesModel.coordinateSystem;\n\t                    var baseAxis;\n\t                    var key;\n\t\n\t                    // Only cartesian2d, polar and single support axis trigger\n\t                    if (coordSys.type === 'cartesian2d') {\n\t                        // FIXME `axisPointer.axis` is not baseAxis\n\t                        baseAxis = coordSys.getBaseAxis();\n\t                        key = baseAxis.dim + baseAxis.index;\n\t                    }\n\t                    else if (coordSys.type === 'singleAxis') {\n\t                        baseAxis = coordSys.getAxis();\n\t                        key = baseAxis.dim + baseAxis.type;\n\t                    }\n\t                    else {\n\t                        baseAxis = coordSys.getBaseAxis();\n\t                        key = baseAxis.dim + coordSys.name;\n\t                    }\n\t\n\t                    seriesGroupByAxis[key] = seriesGroupByAxis[key] || {\n\t                        coordSys: [],\n\t                        series: []\n\t                    };\n\t                    seriesGroupByAxis[key].coordSys.push(coordSys);\n\t                    seriesGroupByAxis[key].series.push(seriesModel);\n\t                }\n\t            }, this);\n\t\n\t            return seriesGroupByAxis;\n\t        },\n\t\n\t        /**\n\t         * mousemove handler\n\t         * @param {Object} e\n\t         * @private\n\t         */\n\t        _tryShow: function (e) {\n\t            var el = e.target;\n\t            var tooltipModel = this._tooltipModel;\n\t            var globalTrigger = tooltipModel.get('trigger');\n\t            var ecModel = this._ecModel;\n\t            var api = this._api;\n\t\n\t            if (!tooltipModel) {\n\t                return;\n\t            }\n\t\n\t            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n\t            this._lastX = e.offsetX;\n\t            this._lastY = e.offsetY;\n\t\n\t            // Always show item tooltip if mouse is on the element with dataIndex\n\t            if (el && el.dataIndex != null) {\n\t                // Use dataModel in element if possible\n\t                // Used when mouseover on a element like markPoint or edge\n\t                // In which case, the data is not main data in series.\n\t                var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n\t                var dataIndex = el.dataIndex;\n\t                var itemModel = dataModel.getData().getItemModel(dataIndex);\n\t                // Series or single data may use item trigger when global is axis trigger\n\t                if ((itemModel.get('tooltip.trigger') || globalTrigger) === 'axis') {\n\t                    this._showAxisTooltip(tooltipModel, ecModel, e);\n\t                }\n\t                else {\n\t                    // Reset ticket\n\t                    this._ticket = '';\n\t                    // If either single data or series use item trigger\n\t                    this._hideAxisPointer();\n\t                    // Reset last hover and dispatch downplay action\n\t                    this._resetLastHover();\n\t\n\t                    this._showItemTooltipContent(dataModel, dataIndex, el.dataType, e);\n\t                }\n\t\n\t                api.dispatchAction({\n\t                    type: 'showTip',\n\t                    from: this.uid,\n\t                    dataIndexInside: el.dataIndex,\n\t                    seriesIndex: el.seriesIndex\n\t                });\n\t            }\n\t            // Tooltip provided directly. Like legend\n\t            else if (el && el.tooltip) {\n\t                var tooltipOpt = el.tooltip;\n\t                if (typeof tooltipOpt === 'string') {\n\t                    var content = tooltipOpt;\n\t                    tooltipOpt = {\n\t                        content: content,\n\t                        // Fixed formatter\n\t                        formatter: content\n\t                    };\n\t                }\n\t                var subTooltipModel = new Model(tooltipOpt, tooltipModel);\n\t                var defaultHtml = subTooltipModel.get('content');\n\t                var asyncTicket = Math.random();\n\t                this._showTooltipContent(\n\t                    // TODO params\n\t                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n\t                    asyncTicket, e.offsetX, e.offsetY, e.position, el, api\n\t                );\n\t            }\n\t            else {\n\t                if (globalTrigger === 'item') {\n\t                    this._hide();\n\t                }\n\t                else {\n\t                    // Try show axis tooltip\n\t                    this._showAxisTooltip(tooltipModel, ecModel, e);\n\t                }\n\t\n\t                // Action of cross pointer\n\t                // other pointer types will trigger action in _dispatchAndShowSeriesTooltipContent method\n\t                if (tooltipModel.get('axisPointer.type') === 'cross') {\n\t                    api.dispatchAction({\n\t                        type: 'showTip',\n\t                        from: this.uid,\n\t                        x: e.offsetX,\n\t                        y: e.offsetY\n\t                    });\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on axis\n\t         * @param {module:echarts/component/tooltip/TooltipModel} tooltipModel\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @param {Object} e\n\t         * @private\n\t         */\n\t        _showAxisTooltip: function (tooltipModel, ecModel, e) {\n\t            var axisPointerModel = tooltipModel.getModel('axisPointer');\n\t            var axisPointerType = axisPointerModel.get('type');\n\t\n\t            if (axisPointerType === 'cross') {\n\t                var el = e.target;\n\t                if (el && el.dataIndex != null) {\n\t                    var seriesModel = ecModel.getSeriesByIndex(el.seriesIndex);\n\t                    var dataIndex = el.dataIndex;\n\t                    this._showItemTooltipContent(seriesModel, dataIndex, el.dataType, e);\n\t                }\n\t            }\n\t\n\t            this._showAxisPointer();\n\t            var allNotShow = true;\n\t            zrUtil.each(this._seriesGroupByAxis, function (seriesCoordSysSameAxis) {\n\t                // Try show the axis pointer\n\t                var allCoordSys = seriesCoordSysSameAxis.coordSys;\n\t                var coordSys = allCoordSys[0];\n\t\n\t                // If mouse position is not in the grid or polar\n\t                var point = [e.offsetX, e.offsetY];\n\t\n\t                if (!coordSys.containPoint(point)) {\n\t                    // Hide axis pointer\n\t                    this._hideAxisPointer(coordSys.name);\n\t                    return;\n\t                }\n\t\n\t                allNotShow = false;\n\t                // Make sure point is discrete on cateogry axis\n\t                var dimensions = coordSys.dimensions;\n\t                var value = coordSys.pointToData(point, true);\n\t                point = coordSys.dataToPoint(value);\n\t                var baseAxis = coordSys.getBaseAxis();\n\t                var axisType = axisPointerModel.get('axis');\n\t                if (axisType === 'auto') {\n\t                    axisType = baseAxis.dim;\n\t                }\n\t\n\t                var contentNotChange = false;\n\t                var lastHover = this._lastHover;\n\t                if (axisPointerType === 'cross') {\n\t                    // If hover data not changed\n\t                    // Possible when two axes are all category\n\t                    if (dataEqual(lastHover.data, value)) {\n\t                        contentNotChange = true;\n\t                    }\n\t                    lastHover.data = value;\n\t                }\n\t                else {\n\t                    var valIndex = zrUtil.indexOf(dimensions, axisType);\n\t\n\t                    // If hover data not changed on the axis dimension\n\t                    if (lastHover.data === value[valIndex]) {\n\t                        contentNotChange = true;\n\t                    }\n\t                    lastHover.data = value[valIndex];\n\t                }\n\t\n\t                var enableAnimation = tooltipModel.get('animation');\n\t\n\t                if (coordSys.type === 'cartesian2d' && !contentNotChange) {\n\t                    this._showCartesianPointer(\n\t                        axisPointerModel, coordSys, axisType, point, enableAnimation\n\t                    );\n\t                }\n\t                else if (coordSys.type === 'polar' && !contentNotChange) {\n\t                    this._showPolarPointer(\n\t                        axisPointerModel, coordSys, axisType, point, enableAnimation\n\t                    );\n\t                }\n\t                else if (coordSys.type === 'singleAxis' && !contentNotChange) {\n\t                    this._showSinglePointer(\n\t                        axisPointerModel, coordSys, axisType, point, enableAnimation\n\t                    );\n\t                }\n\t\n\t                if (axisPointerType !== 'cross') {\n\t                    this._dispatchAndShowSeriesTooltipContent(\n\t                        coordSys, seriesCoordSysSameAxis.series, point, value, contentNotChange, e.position\n\t                    );\n\t                }\n\t            }, this);\n\t\n\t            if (!this._tooltipModel.get('show')) {\n\t                this._hideAxisPointer();\n\t            }\n\t\n\t            if (allNotShow) {\n\t                this._hide();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on axis of cartesian coordinate\n\t         * @param {module:echarts/model/Model} axisPointerModel\n\t         * @param {module:echarts/coord/cartesian/Cartesian2D} cartesians\n\t         * @param {string} axisType\n\t         * @param {Array.<number>} point\n\t         * @private\n\t         */\n\t        _showCartesianPointer: function (axisPointerModel, cartesian, axisType, point, enableAnimation) {\n\t            var self = this;\n\t\n\t            var axisPointerType = axisPointerModel.get('type');\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var moveAnimation = enableAnimation\n\t                && axisPointerType !== 'cross'\n\t                && baseAxis.type === 'category'\n\t                && baseAxis.getBandWidth() > 20;\n\t\n\t            if (axisPointerType === 'cross') {\n\t                moveGridLine('x', point, cartesian.getAxis('y').getGlobalExtent());\n\t                moveGridLine('y', point, cartesian.getAxis('x').getGlobalExtent());\n\t\n\t                this._updateCrossText(cartesian, point, axisPointerModel);\n\t            }\n\t            else {\n\t                var otherAxis = cartesian.getAxis(axisType === 'x' ? 'y' : 'x');\n\t                var otherExtent = otherAxis.getGlobalExtent();\n\t\n\t                if (cartesian.type === 'cartesian2d') {\n\t                    (axisPointerType === 'line' ? moveGridLine : moveGridShadow)(\n\t                        axisType, point, otherExtent\n\t                    );\n\t                }\n\t            }\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function moveGridLine(axisType, point, otherExtent) {\n\t                var targetShape = axisType === 'x'\n\t                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n\t                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    cartesian, axisPointerModel, axisType, targetShape\n\t                );\n\t                graphic.subPixelOptimizeLine({\n\t                    shape: targetShape,\n\t                    style: pointerEl.style\n\t                });\n\t\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function moveGridShadow(axisType, point, otherExtent) {\n\t                var axis = cartesian.getAxis(axisType);\n\t                var bandWidth = axis.getBandWidth();\n\t                var span = otherExtent[1] - otherExtent[0];\n\t                var targetShape = axisType === 'x'\n\t                    ? makeRectShape(point[0] - bandWidth / 2, otherExtent[0], bandWidth, span)\n\t                    : makeRectShape(otherExtent[0], point[1] - bandWidth / 2, span, bandWidth);\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    cartesian, axisPointerModel, axisType, targetShape\n\t                );\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t        },\n\t\n\t        _showSinglePointer: function (axisPointerModel, single, axisType, point, enableAnimation) {\n\t            var self = this;\n\t            var axisPointerType = axisPointerModel.get('type');\n\t            var moveAnimation =\n\t                enableAnimation\n\t                && axisPointerType !== 'cross'\n\t                && single.getBaseAxis().type === 'category';\n\t            var rect = single.getRect();\n\t            var otherExtent = [rect.y, rect.y + rect.height];\n\t\n\t            moveSingleLine(axisType, point, otherExtent);\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function moveSingleLine(axisType, point, otherExtent) {\n\t                var axis = single.getAxis();\n\t                var orient = axis.orient;\n\t\n\t                var targetShape = orient === 'horizontal'\n\t                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n\t                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    single, axisPointerModel, axisType, targetShape\n\t                );\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on axis of polar coordinate\n\t         * @param {module:echarts/model/Model} axisPointerModel\n\t         * @param {Array.<module:echarts/coord/polar/Polar>} polar\n\t         * @param {string} axisType\n\t         * @param {Array.<number>} point\n\t         */\n\t        _showPolarPointer: function (axisPointerModel, polar, axisType, point, enableAnimation) {\n\t            var self = this;\n\t\n\t            var axisPointerType = axisPointerModel.get('type');\n\t\n\t            var angleAxis = polar.getAngleAxis();\n\t            var radiusAxis = polar.getRadiusAxis();\n\t\n\t            var moveAnimation = enableAnimation\n\t                && axisPointerType !== 'cross'\n\t                && polar.getBaseAxis().type === 'category';\n\t\n\t            if (axisPointerType === 'cross') {\n\t                movePolarLine('angle', point, radiusAxis.getExtent());\n\t                movePolarLine('radius', point, angleAxis.getExtent());\n\t\n\t                this._updateCrossText(polar, point, axisPointerModel);\n\t            }\n\t            else {\n\t                var otherAxis = polar.getAxis(axisType === 'radius' ? 'angle' : 'radius');\n\t                var otherExtent = otherAxis.getExtent();\n\t\n\t                (axisPointerType === 'line' ? movePolarLine : movePolarShadow)(\n\t                    axisType, point, otherExtent\n\t                );\n\t            }\n\t            /**\n\t             * @inner\n\t             */\n\t            function movePolarLine(axisType, point, otherExtent) {\n\t                var mouseCoord = polar.pointToCoord(point);\n\t\n\t                var targetShape;\n\t\n\t                if (axisType === 'angle') {\n\t                    var p1 = polar.coordToPoint([otherExtent[0], mouseCoord[1]]);\n\t                    var p2 = polar.coordToPoint([otherExtent[1], mouseCoord[1]]);\n\t                    targetShape = makeLineShape(p1[0], p1[1], p2[0], p2[1]);\n\t                }\n\t                else {\n\t                    targetShape = {\n\t                        cx: polar.cx,\n\t                        cy: polar.cy,\n\t                        r: mouseCoord[0]\n\t                    };\n\t                }\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    polar, axisPointerModel, axisType, targetShape\n\t                );\n\t\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function movePolarShadow(axisType, point, otherExtent) {\n\t                var axis = polar.getAxis(axisType);\n\t                var bandWidth = axis.getBandWidth();\n\t\n\t                var mouseCoord = polar.pointToCoord(point);\n\t\n\t                var targetShape;\n\t\n\t                var radian = Math.PI / 180;\n\t\n\t                if (axisType === 'angle') {\n\t                    targetShape = makeSectorShape(\n\t                        polar.cx, polar.cy,\n\t                        otherExtent[0], otherExtent[1],\n\t                        // In ECharts y is negative if angle is positive\n\t                        (-mouseCoord[1] - bandWidth / 2) * radian,\n\t                        (-mouseCoord[1] + bandWidth / 2) * radian\n\t                    );\n\t                }\n\t                else {\n\t                    targetShape = makeSectorShape(\n\t                        polar.cx, polar.cy,\n\t                        mouseCoord[0] - bandWidth / 2,\n\t                        mouseCoord[0] + bandWidth / 2,\n\t                        0, Math.PI * 2\n\t                    );\n\t                }\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    polar, axisPointerModel, axisType, targetShape\n\t                );\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t        },\n\t\n\t        _updateCrossText: function (coordSys, point, axisPointerModel) {\n\t            var crossStyleModel = axisPointerModel.getModel('crossStyle');\n\t            var textStyleModel = crossStyleModel.getModel('textStyle');\n\t\n\t            var tooltipModel = this._tooltipModel;\n\t\n\t            var text = this._crossText;\n\t            if (!text) {\n\t                text = this._crossText = new graphic.Text({\n\t                    style: {\n\t                        textAlign: 'left',\n\t                        textVerticalAlign: 'bottom'\n\t                    }\n\t                });\n\t                this.group.add(text);\n\t            }\n\t\n\t            var value = coordSys.pointToData(point);\n\t\n\t            var dims = coordSys.dimensions;\n\t            value = zrUtil.map(value, function (val, idx) {\n\t                var axis = coordSys.getAxis(dims[idx]);\n\t                if (axis.type === 'category' || axis.type === 'time') {\n\t                    val = axis.scale.getLabel(val);\n\t                }\n\t                else {\n\t                    val = formatUtil.addCommas(\n\t                        val.toFixed(axis.getPixelPrecision())\n\t                    );\n\t                }\n\t                return val;\n\t            });\n\t\n\t            text.setStyle({\n\t                fill: textStyleModel.getTextColor() || crossStyleModel.get('color'),\n\t                textFont: textStyleModel.getFont(),\n\t                text: value.join(', '),\n\t                x: point[0] + 5,\n\t                y: point[1] - 5\n\t            });\n\t            text.z = tooltipModel.get('z');\n\t            text.zlevel = tooltipModel.get('zlevel');\n\t        },\n\t\n\t        _getPointerElement: function (coordSys, pointerModel, axisType, initShape) {\n\t            var tooltipModel = this._tooltipModel;\n\t            var z = tooltipModel.get('z');\n\t            var zlevel = tooltipModel.get('zlevel');\n\t            var axisPointers = this._axisPointers;\n\t            var coordSysName = coordSys.name;\n\t            axisPointers[coordSysName] = axisPointers[coordSysName] || {};\n\t            if (axisPointers[coordSysName][axisType]) {\n\t                return axisPointers[coordSysName][axisType];\n\t            }\n\t\n\t            // Create if not exists\n\t            var pointerType = pointerModel.get('type');\n\t            var styleModel = pointerModel.getModel(pointerType + 'Style');\n\t            var isShadow = pointerType === 'shadow';\n\t            var style = styleModel[isShadow ? 'getAreaStyle' : 'getLineStyle']();\n\t\n\t            var elementType = coordSys.type === 'polar'\n\t                ? (isShadow ? 'Sector' : (axisType === 'radius' ? 'Circle' : 'Line'))\n\t                : (isShadow ? 'Rect' : 'Line');\n\t\n\t            isShadow ? (style.stroke = null) : (style.fill = null);\n\t\n\t            var el = axisPointers[coordSysName][axisType] = new graphic[elementType]({\n\t                style: style,\n\t                z: z,\n\t                zlevel: zlevel,\n\t                silent: true,\n\t                shape: initShape\n\t            });\n\t\n\t            this.group.add(el);\n\t            return el;\n\t        },\n\t\n\t        /**\n\t         * Dispatch actions and show tooltip on series\n\t         * @param {Array.<module:echarts/model/Series>} seriesList\n\t         * @param {Array.<number>} point\n\t         * @param {Array.<number>} value\n\t         * @param {boolean} contentNotChange\n\t         * @param {Array.<number>|string|Function} [positionExpr]\n\t         */\n\t        _dispatchAndShowSeriesTooltipContent: function (\n\t            coordSys, seriesList, point, value, contentNotChange, positionExpr\n\t        ) {\n\t\n\t            var rootTooltipModel = this._tooltipModel;\n\t\n\t            var baseAxis = coordSys.getBaseAxis();\n\t            var baseDimIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\t\n\t            var payloadBatch = zrUtil.map(seriesList, function (series) {\n\t                return {\n\t                    seriesIndex: series.seriesIndex,\n\t                    dataIndexInside: series.getAxisTooltipDataIndex\n\t                        ? series.getAxisTooltipDataIndex(series.coordDimToDataDim(baseAxis.dim), value, baseAxis)\n\t                        : series.getData().indexOfNearest(\n\t                            series.coordDimToDataDim(baseAxis.dim)[0],\n\t                            value[baseDimIndex],\n\t                            // Add a threshold to avoid find the wrong dataIndex when data length is not same\n\t                            false, baseAxis.type === 'category' ? 0.5 : null\n\t                        )\n\t                };\n\t            });\n\t            var sampleSeriesIndex;\n\t            zrUtil.each(payloadBatch, function (payload, idx) {\n\t                if (seriesList[idx].getData().hasValue(payload.dataIndexInside)) {\n\t                    sampleSeriesIndex = idx;\n\t                }\n\t            });\n\t            // Fallback to 0.\n\t            sampleSeriesIndex = sampleSeriesIndex || 0;\n\t\n\t            var lastHover = this._lastHover;\n\t            var api = this._api;\n\t            // Dispatch downplay action\n\t            if (lastHover.payloadBatch && !contentNotChange) {\n\t                api.dispatchAction({\n\t                    type: 'downplay',\n\t                    batch: lastHover.payloadBatch\n\t                });\n\t            }\n\t            // Dispatch highlight action\n\t            if (!contentNotChange) {\n\t                api.dispatchAction({\n\t                    type: 'highlight',\n\t                    batch: payloadBatch\n\t                });\n\t                lastHover.payloadBatch = payloadBatch;\n\t            }\n\t            // Dispatch showTip action\n\t            api.dispatchAction({\n\t                type: 'showTip',\n\t                dataIndexInside: payloadBatch[sampleSeriesIndex].dataIndexInside,\n\t                seriesIndex: payloadBatch[sampleSeriesIndex].seriesIndex,\n\t                from: this.uid\n\t            });\n\t\n\t            if (baseAxis && rootTooltipModel.get('showContent') && rootTooltipModel.get('show')) {\n\t                var paramsList = zrUtil.map(seriesList, function (series, index) {\n\t                    return series.getDataParams(payloadBatch[index].dataIndexInside);\n\t                });\n\t\n\t                if (!contentNotChange) {\n\t                    // Update html content\n\t                    var firstDataIndex = payloadBatch[sampleSeriesIndex].dataIndexInside;\n\t\n\t                    // Default tooltip content\n\t                    // FIXME\n\t                    // (1) shold be the first data which has name?\n\t                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n\t                    var firstLine = baseAxis.type === 'time'\n\t                        ? baseAxis.scale.getLabel(value[baseDimIndex])\n\t                        : seriesList[sampleSeriesIndex].getData().getName(firstDataIndex);\n\t                    var defaultHtml = (firstLine ? firstLine + '<br />' : '')\n\t                        + zrUtil.map(seriesList, function (series, index) {\n\t                            return series.formatTooltip(payloadBatch[index].dataIndexInside, true);\n\t                        }).join('<br />');\n\t\n\t                    var asyncTicket = 'axis_' + coordSys.name + '_' + firstDataIndex;\n\t\n\t                    this._showTooltipContent(\n\t                        rootTooltipModel, defaultHtml, paramsList, asyncTicket,\n\t                        point[0], point[1], positionExpr, null, api\n\t                    );\n\t                }\n\t                else {\n\t                    updatePosition(\n\t                        positionExpr || rootTooltipModel.get('position'),\n\t                        point[0], point[1],\n\t                        rootTooltipModel.get('confine'),\n\t                        this._tooltipContent, paramsList, null, api\n\t                    );\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on item\n\t         * @param {module:echarts/model/Series} seriesModel\n\t         * @param {number} dataIndex\n\t         * @param {string} dataType\n\t         * @param {Object} e\n\t         */\n\t        _showItemTooltipContent: function (seriesModel, dataIndex, dataType, e) {\n\t            // FIXME Graph data\n\t            var api = this._api;\n\t            var data = seriesModel.getData(dataType);\n\t            var itemModel = data.getItemModel(dataIndex);\n\t\n\t            var tooltipOpt = itemModel.get('tooltip', true);\n\t            if (typeof tooltipOpt === 'string') {\n\t                // In each data item tooltip can be simply write:\n\t                // {\n\t                //  value: 10,\n\t                //  tooltip: 'Something you need to know'\n\t                // }\n\t                var tooltipContent = tooltipOpt;\n\t                tooltipOpt = {\n\t                    formatter: tooltipContent\n\t                };\n\t            }\n\t            var rootTooltipModel = this._tooltipModel;\n\t            var seriesTooltipModel = seriesModel.getModel(\n\t                'tooltip', rootTooltipModel\n\t            );\n\t            var tooltipModel = new Model(tooltipOpt, seriesTooltipModel, seriesTooltipModel.ecModel);\n\t\n\t            var params = seriesModel.getDataParams(dataIndex, dataType);\n\t            var defaultHtml = seriesModel.formatTooltip(dataIndex, false, dataType);\n\t\n\t            var asyncTicket = 'item_' + seriesModel.name + '_' + dataIndex;\n\t\n\t            this._showTooltipContent(\n\t                tooltipModel, defaultHtml, params, asyncTicket,\n\t                e.offsetX, e.offsetY, e.position, e.target, api\n\t            );\n\t        },\n\t\n\t        _showTooltipContent: function (\n\t            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, target, api\n\t        ) {\n\t            // Reset ticket\n\t            this._ticket = '';\n\t\n\t            if (tooltipModel.get('showContent') && tooltipModel.get('show')) {\n\t                var tooltipContent = this._tooltipContent;\n\t                var confine = tooltipModel.get('confine');\n\t\n\t                var formatter = tooltipModel.get('formatter');\n\t                positionExpr = positionExpr || tooltipModel.get('position');\n\t                var html = defaultHtml;\n\t\n\t                if (formatter) {\n\t                    if (typeof formatter === 'string') {\n\t                        html = formatUtil.formatTpl(formatter, params);\n\t                    }\n\t                    else if (typeof formatter === 'function') {\n\t                        var self = this;\n\t                        var ticket = asyncTicket;\n\t                        var callback = function (cbTicket, html) {\n\t                            if (cbTicket === self._ticket) {\n\t                                tooltipContent.setContent(html);\n\t\n\t                                updatePosition(\n\t                                    positionExpr, x, y, confine,\n\t                                    tooltipContent, params, target, api\n\t                                );\n\t                            }\n\t                        };\n\t                        self._ticket = ticket;\n\t                        html = formatter(params, ticket, callback);\n\t                    }\n\t                }\n\t\n\t                tooltipContent.show(tooltipModel);\n\t                tooltipContent.setContent(html);\n\t\n\t                updatePosition(\n\t                    positionExpr, x, y, confine,\n\t                    tooltipContent, params, target, api\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show axis pointer\n\t         * @param {string} [coordSysName]\n\t         */\n\t        _showAxisPointer: function (coordSysName) {\n\t            if (coordSysName) {\n\t                var axisPointers = this._axisPointers[coordSysName];\n\t                axisPointers && zrUtil.each(axisPointers, function (el) {\n\t                    el.show();\n\t                });\n\t            }\n\t            else {\n\t                this.group.eachChild(function (child) {\n\t                    child.show();\n\t                });\n\t                this.group.show();\n\t            }\n\t        },\n\t\n\t        _resetLastHover: function () {\n\t            var lastHover = this._lastHover;\n\t            if (lastHover.payloadBatch) {\n\t                this._api.dispatchAction({\n\t                    type: 'downplay',\n\t                    batch: lastHover.payloadBatch\n\t                });\n\t            }\n\t            // Reset lastHover\n\t            this._lastHover = {};\n\t        },\n\t        /**\n\t         * Hide axis pointer\n\t         * @param {string} [coordSysName]\n\t         */\n\t        _hideAxisPointer: function (coordSysName) {\n\t            if (coordSysName) {\n\t                var axisPointers = this._axisPointers[coordSysName];\n\t                axisPointers && zrUtil.each(axisPointers, function (el) {\n\t                    el.hide();\n\t                });\n\t            }\n\t            else {\n\t                if (this.group.children().length) {\n\t                    this.group.hide();\n\t                }\n\t            }\n\t        },\n\t\n\t        _hide: function () {\n\t            clearTimeout(this._showTimeout);\n\t\n\t            this._hideAxisPointer();\n\t            this._resetLastHover();\n\t            if (!this._alwaysShowContent) {\n\t                this._tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n\t            }\n\t\n\t            this._api.dispatchAction({\n\t                type: 'hideTip',\n\t                from: this.uid\n\t            });\n\t\n\t            this._lastX = this._lastY = null;\n\t        },\n\t\n\t        dispose: function (ecModel, api) {\n\t            if (env.node) {\n\t                return;\n\t            }\n\t            var zr = api.getZr();\n\t            this._tooltipContent.hide();\n\t\n\t            zr.off('click', this._tryShow);\n\t            zr.off('mousemove', this._mousemove);\n\t            zr.off('mouseout', this._hide);\n\t            zr.off('globalout', this._hide);\n\t\n\t            api.off('showTip', this._manuallyShowTip);\n\t            api.off('hideTip', this._manuallyHideTip);\n\t        }\n\t    });\n\n\n/***/ },\n/* 119 */,\n/* 120 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t\n\t    function defaultKeyGetter(item) {\n\t        return item;\n\t    }\n\t\n\t    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n\t        this._old = oldArr;\n\t        this._new = newArr;\n\t\n\t        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n\t        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n\t    }\n\t\n\t    DataDiffer.prototype = {\n\t\n\t        constructor: DataDiffer,\n\t\n\t        /**\n\t         * Callback function when add a data\n\t         */\n\t        add: function (func) {\n\t            this._add = func;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Callback function when update a data\n\t         */\n\t        update: function (func) {\n\t            this._update = func;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Callback function when remove a data\n\t         */\n\t        remove: function (func) {\n\t            this._remove = func;\n\t            return this;\n\t        },\n\t\n\t        execute: function () {\n\t            var oldArr = this._old;\n\t            var newArr = this._new;\n\t            var oldKeyGetter = this._oldKeyGetter;\n\t            var newKeyGetter = this._newKeyGetter;\n\t\n\t            var oldDataIndexMap = {};\n\t            var newDataIndexMap = {};\n\t            var oldDataKeyArr = [];\n\t            var newDataKeyArr = [];\n\t            var i;\n\t\n\t            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n\t            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\t\n\t            // Travel by inverted order to make sure order consistency\n\t            // when duplicate keys exists (consider newDataIndex.pop() below).\n\t            // For performance consideration, these code below do not look neat.\n\t            for (i = 0; i < oldArr.length; i++) {\n\t                var key = oldDataKeyArr[i];\n\t                var idx = newDataIndexMap[key];\n\t\n\t                // idx can never be empty array here. see 'set null' logic below.\n\t                if (idx != null) {\n\t                    // Consider there is duplicate key (for example, use dataItem.name as key).\n\t                    // We should make sure every item in newArr and oldArr can be visited.\n\t                    var len = idx.length;\n\t                    if (len) {\n\t                        len === 1 && (newDataIndexMap[key] = null);\n\t                        idx = idx.unshift();\n\t                    }\n\t                    else {\n\t                        newDataIndexMap[key] = null;\n\t                    }\n\t                    this._update && this._update(idx, i);\n\t                }\n\t                else {\n\t                    this._remove && this._remove(i);\n\t                }\n\t            }\n\t\n\t            for (var i = 0; i < newDataKeyArr.length; i++) {\n\t                var key = newDataKeyArr[i];\n\t                if (newDataIndexMap.hasOwnProperty(key)) {\n\t                    var idx = newDataIndexMap[key];\n\t                    if (idx == null) {\n\t                        continue;\n\t                    }\n\t                    // idx can never be empty array here. see 'set null' logic above.\n\t                    if (!idx.length) {\n\t                        this._add && this._add(idx);\n\t                    }\n\t                    else {\n\t                        for (var j = 0, len = idx.length; j < len; j++) {\n\t                            this._add && this._add(idx[j]);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function initIndexMap(arr, map, keyArr, keyGetter) {\n\t        for (var i = 0; i < arr.length; i++) {\n\t            var key = keyGetter(arr[i], i);\n\t            var existence = map[key];\n\t            if (existence == null) {\n\t                keyArr.push(key);\n\t                map[key] = i;\n\t            }\n\t            else {\n\t                if (!existence.length) {\n\t                    map[key] = existence = [existence];\n\t                }\n\t                existence.push(i);\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = DataDiffer;\n\n\n/***/ },\n/* 121 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Complete dimensions by data (guess dimension).\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    /**\n\t     * Complete the dimensions array guessed from the data structure.\n\t     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n\t     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n\t     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n\t     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n\t     * @return {Array.<string>}\n\t     */\n\t    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n\t        if (!data) {\n\t            return dimensions;\n\t        }\n\t\n\t        var value0 = retrieveValue(data[0]);\n\t        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\t\n\t        defaultNames = defaultNames || [];\n\t        extraPrefix = extraPrefix || 'extra';\n\t        for (var i = 0; i < dimSize; i++) {\n\t            if (!dimensions[i]) {\n\t                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));\n\t                dimensions[i] = guessOrdinal(data, i)\n\t                    ? {type: 'ordinal', name: name}\n\t                    : name;\n\t            }\n\t        }\n\t\n\t        return dimensions;\n\t    }\n\t\n\t    // The rule should not be complex, otherwise user might not\n\t    // be able to known where the data is wrong.\n\t    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n\t        for (var i = 0, len = data.length; i < len; i++) {\n\t            var value = retrieveValue(data[i]);\n\t\n\t            if (!zrUtil.isArray(value)) {\n\t                return false;\n\t            }\n\t\n\t            var value = value[dimIndex];\n\t            if (value != null && isFinite(value)) {\n\t                return false;\n\t            }\n\t            else if (zrUtil.isString(value) && value !== '-') {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t\n\t    function retrieveValue(o) {\n\t        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n\t    }\n\t\n\t    module.exports = completeDimensions;\n\t\n\n\n/***/ },\n/* 122 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var graphic = __webpack_require__(10);\n\t    var zrUtil = __webpack_require__(1);\n\t    var PI = Math.PI;\n\t    /**\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     * @param {Object} [opts]\n\t     * @param {string} [opts.text]\n\t     * @param {string} [opts.color]\n\t     * @param {string} [opts.textColor]\n\t     * @return {module:zrender/Element}\n\t     */\n\t    module.exports = function (api, opts) {\n\t        opts = opts || {};\n\t        zrUtil.defaults(opts, {\n\t            text: 'loading',\n\t            color: '#c23531',\n\t            textColor: '#000',\n\t            maskColor: 'rgba(255, 255, 255, 0.8)',\n\t            zlevel: 0\n\t        });\n\t        var mask = new graphic.Rect({\n\t            style: {\n\t                fill: opts.maskColor\n\t            },\n\t            zlevel: opts.zlevel,\n\t            z: 10000\n\t        });\n\t        var arc = new graphic.Arc({\n\t            shape: {\n\t                startAngle: -PI / 2,\n\t                endAngle: -PI / 2 + 0.1,\n\t                r: 10\n\t            },\n\t            style: {\n\t                stroke: opts.color,\n\t                lineCap: 'round',\n\t                lineWidth: 5\n\t            },\n\t            zlevel: opts.zlevel,\n\t            z: 10001\n\t        });\n\t        var labelRect = new graphic.Rect({\n\t            style: {\n\t                fill: 'none',\n\t                text: opts.text,\n\t                textPosition: 'right',\n\t                textDistance: 10,\n\t                textFill: opts.textColor\n\t            },\n\t            zlevel: opts.zlevel,\n\t            z: 10001\n\t        });\n\t\n\t        arc.animateShape(true)\n\t            .when(1000, {\n\t                endAngle: PI * 3 / 2\n\t            })\n\t            .start('circularInOut');\n\t        arc.animateShape(true)\n\t            .when(1000, {\n\t                startAngle: PI * 3 / 2\n\t            })\n\t            .delay(300)\n\t            .start('circularInOut');\n\t\n\t        var group = new graphic.Group();\n\t        group.add(arc);\n\t        group.add(labelRect);\n\t        group.add(mask);\n\t        // Inject resize\n\t        group.resize = function () {\n\t            var cx = api.getWidth() / 2;\n\t            var cy = api.getHeight() / 2;\n\t            arc.setShape({\n\t                cx: cx,\n\t                cy: cy\n\t            });\n\t            var r = arc.shape.r;\n\t            labelRect.setShape({\n\t                x: cx - r,\n\t                y: cy - r,\n\t                width: r * 2,\n\t                height: r * 2\n\t            });\n\t\n\t            mask.setShape({\n\t                x: 0,\n\t                y: 0,\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t        };\n\t        group.resize();\n\t        return group;\n\t    };\n\n\n/***/ },\n/* 123 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * ECharts global model\n\t *\n\t * @module {echarts/model/Global}\n\t */\n\t\n\t\n\t\n\t    /**\n\t     * Caution: If the mechanism should be changed some day, these cases\n\t     * should be considered:\n\t     *\n\t     * (1) In `merge option` mode, if using the same option to call `setOption`\n\t     * many times, the result should be the same (try our best to ensure that).\n\t     * (2) In `merge option` mode, if a component has no id/name specified, it\n\t     * will be merged by index, and the result sequence of the components is\n\t     * consistent to the original sequence.\n\t     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n\t     * `mergeOption` in module:echarts/model/OptionManager.\n\t     */\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var modelUtil = __webpack_require__(11);\n\t    var Model = __webpack_require__(15);\n\t    var each = zrUtil.each;\n\t    var filter = zrUtil.filter;\n\t    var map = zrUtil.map;\n\t    var isArray = zrUtil.isArray;\n\t    var indexOf = zrUtil.indexOf;\n\t    var isObject = zrUtil.isObject;\n\t\n\t    var ComponentModel = __webpack_require__(18);\n\t\n\t    var globalDefault = __webpack_require__(125);\n\t\n\t    var OPTION_INNER_KEY = '\\0_ec_inner';\n\t\n\t    /**\n\t     * @alias module:echarts/model/Global\n\t     *\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {Object} theme\n\t     */\n\t    var GlobalModel = Model.extend({\n\t\n\t        constructor: GlobalModel,\n\t\n\t        init: function (option, parentModel, theme, optionManager) {\n\t            theme = theme || {};\n\t\n\t            this.option = null; // Mark as not initialized.\n\t\n\t            /**\n\t             * @type {module:echarts/model/Model}\n\t             * @private\n\t             */\n\t            this._theme = new Model(theme);\n\t\n\t            /**\n\t             * @type {module:echarts/model/OptionManager}\n\t             */\n\t            this._optionManager = optionManager;\n\t        },\n\t\n\t        setOption: function (option, optionPreprocessorFuncs) {\n\t            zrUtil.assert(\n\t                !(OPTION_INNER_KEY in option),\n\t                'please use chart.getOption()'\n\t            );\n\t\n\t            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\t\n\t            this.resetOption();\n\t        },\n\t\n\t        /**\n\t         * @param {string} type null/undefined: reset all.\n\t         *                      'recreate': force recreate all.\n\t         *                      'timeline': only reset timeline option\n\t         *                      'media': only reset media query option\n\t         * @return {boolean} Whether option changed.\n\t         */\n\t        resetOption: function (type) {\n\t            var optionChanged = false;\n\t            var optionManager = this._optionManager;\n\t\n\t            if (!type || type === 'recreate') {\n\t                var baseOption = optionManager.mountOption(type === 'recreate');\n\t\n\t                if (!this.option || type === 'recreate') {\n\t                    initBase.call(this, baseOption);\n\t                }\n\t                else {\n\t                    this.restoreData();\n\t                    this.mergeOption(baseOption);\n\t                }\n\t                optionChanged = true;\n\t            }\n\t\n\t            if (type === 'timeline' || type === 'media') {\n\t                this.restoreData();\n\t            }\n\t\n\t            if (!type || type === 'recreate' || type === 'timeline') {\n\t                var timelineOption = optionManager.getTimelineOption(this);\n\t                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n\t            }\n\t\n\t            if (!type || type === 'recreate' || type === 'media') {\n\t                var mediaOptions = optionManager.getMediaOption(this, this._api);\n\t                if (mediaOptions.length) {\n\t                    each(mediaOptions, function (mediaOption) {\n\t                        this.mergeOption(mediaOption, optionChanged = true);\n\t                    }, this);\n\t                }\n\t            }\n\t\n\t            return optionChanged;\n\t        },\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        mergeOption: function (newOption) {\n\t            var option = this.option;\n\t            var componentsMap = this._componentsMap;\n\t            var newCptTypes = [];\n\t\n\t            // 如果不存在对应的 component model 则直接 merge\n\t            each(newOption, function (componentOption, mainType) {\n\t                if (componentOption == null) {\n\t                    return;\n\t                }\n\t\n\t                if (!ComponentModel.hasClass(mainType)) {\n\t                    option[mainType] = option[mainType] == null\n\t                        ? zrUtil.clone(componentOption)\n\t                        : zrUtil.merge(option[mainType], componentOption, true);\n\t                }\n\t                else {\n\t                    newCptTypes.push(mainType);\n\t                }\n\t            });\n\t\n\t            // FIXME OPTION 同步是否要改回原来的\n\t            ComponentModel.topologicalTravel(\n\t                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n\t            );\n\t\n\t            this._seriesIndices = this._seriesIndices || [];\n\t\n\t            function visitComponent(mainType, dependencies) {\n\t                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\t\n\t                var mapResult = modelUtil.mappingToExists(\n\t                    componentsMap[mainType], newCptOptionList\n\t                );\n\t\n\t                modelUtil.makeIdAndName(mapResult);\n\t\n\t                // Set mainType and complete subType.\n\t                each(mapResult, function (item, index) {\n\t                    var opt = item.option;\n\t                    if (isObject(opt)) {\n\t                        item.keyInfo.mainType = mainType;\n\t                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n\t                    }\n\t                });\n\t\n\t                var dependentModels = getComponentsByTypes(\n\t                    componentsMap, dependencies\n\t                );\n\t\n\t                option[mainType] = [];\n\t                componentsMap[mainType] = [];\n\t\n\t                each(mapResult, function (resultItem, index) {\n\t                    var componentModel = resultItem.exist;\n\t                    var newCptOption = resultItem.option;\n\t\n\t                    zrUtil.assert(\n\t                        isObject(newCptOption) || componentModel,\n\t                        'Empty component definition'\n\t                    );\n\t\n\t                    // Consider where is no new option and should be merged using {},\n\t                    // see removeEdgeAndAdd in topologicalTravel and\n\t                    // ComponentModel.getAllClassMainTypes.\n\t                    if (!newCptOption) {\n\t                        componentModel.mergeOption({}, this);\n\t                        componentModel.optionUpdated({}, false);\n\t                    }\n\t                    else {\n\t                        var ComponentModelClass = ComponentModel.getClass(\n\t                            mainType, resultItem.keyInfo.subType, true\n\t                        );\n\t\n\t                        if (componentModel && componentModel instanceof ComponentModelClass) {\n\t                            componentModel.name = resultItem.keyInfo.name;\n\t                            componentModel.mergeOption(newCptOption, this);\n\t                            componentModel.optionUpdated(newCptOption, false);\n\t                        }\n\t                        else {\n\t                            // PENDING Global as parent ?\n\t                            var extraOpt = zrUtil.extend(\n\t                                {\n\t                                    dependentModels: dependentModels,\n\t                                    componentIndex: index\n\t                                },\n\t                                resultItem.keyInfo\n\t                            );\n\t                            componentModel = new ComponentModelClass(\n\t                                newCptOption, this, this, extraOpt\n\t                            );\n\t                            zrUtil.extend(componentModel, extraOpt);\n\t                            componentModel.init(newCptOption, this, this, extraOpt);\n\t                            // Call optionUpdated after init.\n\t                            // newCptOption has been used as componentModel.option\n\t                            // and may be merged with theme and default, so pass null\n\t                            // to avoid confusion.\n\t                            componentModel.optionUpdated(null, true);\n\t                        }\n\t                    }\n\t\n\t                    componentsMap[mainType][index] = componentModel;\n\t                    option[mainType][index] = componentModel.option;\n\t                }, this);\n\t\n\t                // Backup series for filtering.\n\t                if (mainType === 'series') {\n\t                    this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get option for output (cloned option and inner info removed)\n\t         * @public\n\t         * @return {Object}\n\t         */\n\t        getOption: function () {\n\t            var option = zrUtil.clone(this.option);\n\t\n\t            each(option, function (opts, mainType) {\n\t                if (ComponentModel.hasClass(mainType)) {\n\t                    var opts = modelUtil.normalizeToArray(opts);\n\t                    for (var i = opts.length - 1; i >= 0; i--) {\n\t                        // Remove options with inner id.\n\t                        if (modelUtil.isIdInner(opts[i])) {\n\t                            opts.splice(i, 1);\n\t                        }\n\t                    }\n\t                    option[mainType] = opts;\n\t                }\n\t            });\n\t\n\t            delete option[OPTION_INNER_KEY];\n\t\n\t            return option;\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/model/Model}\n\t         */\n\t        getTheme: function () {\n\t            return this._theme;\n\t        },\n\t\n\t        /**\n\t         * @param {string} mainType\n\t         * @param {number} [idx=0]\n\t         * @return {module:echarts/model/Component}\n\t         */\n\t        getComponent: function (mainType, idx) {\n\t            var list = this._componentsMap[mainType];\n\t            if (list) {\n\t                return list[idx || 0];\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object} condition\n\t         * @param {string} condition.mainType\n\t         * @param {string} [condition.subType] If ignore, only query by mainType\n\t         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n\t         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n\t         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n\t         * @return {Array.<module:echarts/model/Component>}\n\t         */\n\t        queryComponents: function (condition) {\n\t            var mainType = condition.mainType;\n\t            if (!mainType) {\n\t                return [];\n\t            }\n\t\n\t            var index = condition.index;\n\t            var id = condition.id;\n\t            var name = condition.name;\n\t\n\t            var cpts = this._componentsMap[mainType];\n\t\n\t            if (!cpts || !cpts.length) {\n\t                return [];\n\t            }\n\t\n\t            var result;\n\t\n\t            if (index != null) {\n\t                if (!isArray(index)) {\n\t                    index = [index];\n\t                }\n\t                result = filter(map(index, function (idx) {\n\t                    return cpts[idx];\n\t                }), function (val) {\n\t                    return !!val;\n\t                });\n\t            }\n\t            else if (id != null) {\n\t                var isIdArray = isArray(id);\n\t                result = filter(cpts, function (cpt) {\n\t                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n\t                        || (!isIdArray && cpt.id === id);\n\t                });\n\t            }\n\t            else if (name != null) {\n\t                var isNameArray = isArray(name);\n\t                result = filter(cpts, function (cpt) {\n\t                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n\t                        || (!isNameArray && cpt.name === name);\n\t                });\n\t            }\n\t            else {\n\t                // Return all components with mainType\n\t                result = cpts;\n\t            }\n\t\n\t            return filterBySubType(result, condition);\n\t        },\n\t\n\t        /**\n\t         * The interface is different from queryComponents,\n\t         * which is convenient for inner usage.\n\t         *\n\t         * @usage\n\t         * var result = findComponents(\n\t         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n\t         * );\n\t         * var result = findComponents(\n\t         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n\t         * );\n\t         * var result = findComponents(\n\t         *     {mainType: 'series'},\n\t         *     function (model, index) {...}\n\t         * );\n\t         * // result like [component0, componnet1, ...]\n\t         *\n\t         * @param {Object} condition\n\t         * @param {string} condition.mainType Mandatory.\n\t         * @param {string} [condition.subType] Optional.\n\t         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n\t         *        where xxx is mainType.\n\t         *        If query attribute is null/undefined or has no index/id/name,\n\t         *        do not filtering by query conditions, which is convenient for\n\t         *        no-payload situations or when target of action is global.\n\t         * @param {Function} [condition.filter] parameter: component, return boolean.\n\t         * @return {Array.<module:echarts/model/Component>}\n\t         */\n\t        findComponents: function (condition) {\n\t            var query = condition.query;\n\t            var mainType = condition.mainType;\n\t\n\t            var queryCond = getQueryCond(query);\n\t            var result = queryCond\n\t                ? this.queryComponents(queryCond)\n\t                : this._componentsMap[mainType];\n\t\n\t            return doFilter(filterBySubType(result, condition));\n\t\n\t            function getQueryCond(q) {\n\t                var indexAttr = mainType + 'Index';\n\t                var idAttr = mainType + 'Id';\n\t                var nameAttr = mainType + 'Name';\n\t                return q && (\n\t                        q.hasOwnProperty(indexAttr)\n\t                        || q.hasOwnProperty(idAttr)\n\t                        || q.hasOwnProperty(nameAttr)\n\t                    )\n\t                    ? {\n\t                        mainType: mainType,\n\t                        // subType will be filtered finally.\n\t                        index: q[indexAttr],\n\t                        id: q[idAttr],\n\t                        name: q[nameAttr]\n\t                    }\n\t                    : null;\n\t            }\n\t\n\t            function doFilter(res) {\n\t                return condition.filter\n\t                     ? filter(res, condition.filter)\n\t                     : res;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @usage\n\t         * eachComponent('legend', function (legendModel, index) {\n\t         *     ...\n\t         * });\n\t         * eachComponent(function (componentType, model, index) {\n\t         *     // componentType does not include subType\n\t         *     // (componentType is 'xxx' but not 'xxx.aa')\n\t         * });\n\t         * eachComponent(\n\t         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n\t         *     function (model, index) {...}\n\t         * );\n\t         * eachComponent(\n\t         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n\t         *     function (model, index) {...}\n\t         * );\n\t         *\n\t         * @param {string|Object=} mainType When mainType is object, the definition\n\t         *                                  is the same as the method 'findComponents'.\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachComponent: function (mainType, cb, context) {\n\t            var componentsMap = this._componentsMap;\n\t\n\t            if (typeof mainType === 'function') {\n\t                context = cb;\n\t                cb = mainType;\n\t                each(componentsMap, function (components, componentType) {\n\t                    each(components, function (component, index) {\n\t                        cb.call(context, componentType, component, index);\n\t                    });\n\t                });\n\t            }\n\t            else if (zrUtil.isString(mainType)) {\n\t                each(componentsMap[mainType], cb, context);\n\t            }\n\t            else if (isObject(mainType)) {\n\t                var queryResult = this.findComponents(mainType);\n\t                each(queryResult, cb, context);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         * @return {Array.<module:echarts/model/Series>}\n\t         */\n\t        getSeriesByName: function (name) {\n\t            var series = this._componentsMap.series;\n\t            return filter(series, function (oneSeries) {\n\t                return oneSeries.name === name;\n\t            });\n\t        },\n\t\n\t        /**\n\t         * @param {number} seriesIndex\n\t         * @return {module:echarts/model/Series}\n\t         */\n\t        getSeriesByIndex: function (seriesIndex) {\n\t            return this._componentsMap.series[seriesIndex];\n\t        },\n\t\n\t        /**\n\t         * @param {string} subType\n\t         * @return {Array.<module:echarts/model/Series>}\n\t         */\n\t        getSeriesByType: function (subType) {\n\t            var series = this._componentsMap.series;\n\t            return filter(series, function (oneSeries) {\n\t                return oneSeries.subType === subType;\n\t            });\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:echarts/model/Series>}\n\t         */\n\t        getSeries: function () {\n\t            return this._componentsMap.series.slice();\n\t        },\n\t\n\t        /**\n\t         * After filtering, series may be different\n\t         * frome raw series.\n\t         *\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachSeries: function (cb, context) {\n\t            assertSeriesInitialized(this);\n\t            each(this._seriesIndices, function (rawSeriesIndex) {\n\t                var series = this._componentsMap.series[rawSeriesIndex];\n\t                cb.call(context, series, rawSeriesIndex);\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * Iterate raw series before filtered.\n\t         *\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachRawSeries: function (cb, context) {\n\t            each(this._componentsMap.series, cb, context);\n\t        },\n\t\n\t        /**\n\t         * After filtering, series may be different.\n\t         * frome raw series.\n\t         *\n\t         * @parma {string} subType\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachSeriesByType: function (subType, cb, context) {\n\t            assertSeriesInitialized(this);\n\t            each(this._seriesIndices, function (rawSeriesIndex) {\n\t                var series = this._componentsMap.series[rawSeriesIndex];\n\t                if (series.subType === subType) {\n\t                    cb.call(context, series, rawSeriesIndex);\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * Iterate raw series before filtered of given type.\n\t         *\n\t         * @parma {string} subType\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachRawSeriesByType: function (subType, cb, context) {\n\t            return each(this.getSeriesByType(subType), cb, context);\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/model/Series} seriesModel\n\t         */\n\t        isSeriesFiltered: function (seriesModel) {\n\t            assertSeriesInitialized(this);\n\t            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n\t        },\n\t\n\t        /**\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        filterSeries: function (cb, context) {\n\t            assertSeriesInitialized(this);\n\t            var filteredSeries = filter(\n\t                this._componentsMap.series, cb, context\n\t            );\n\t            this._seriesIndices = createSeriesIndices(filteredSeries);\n\t        },\n\t\n\t        restoreData: function () {\n\t            var componentsMap = this._componentsMap;\n\t\n\t            this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t\n\t            var componentTypes = [];\n\t            each(componentsMap, function (components, componentType) {\n\t                componentTypes.push(componentType);\n\t            });\n\t\n\t            ComponentModel.topologicalTravel(\n\t                componentTypes,\n\t                ComponentModel.getAllClassMainTypes(),\n\t                function (componentType, dependencies) {\n\t                    each(componentsMap[componentType], function (component) {\n\t                        component.restoreData();\n\t                    });\n\t                }\n\t            );\n\t        }\n\t\n\t    });\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function mergeTheme(option, theme) {\n\t        zrUtil.each(theme, function (themeItem, name) {\n\t            // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n\t            if (!ComponentModel.hasClass(name)) {\n\t                if (typeof themeItem === 'object') {\n\t                    option[name] = !option[name]\n\t                        ? zrUtil.clone(themeItem)\n\t                        : zrUtil.merge(option[name], themeItem, false);\n\t                }\n\t                else {\n\t                    if (option[name] == null) {\n\t                        option[name] = themeItem;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t    }\n\t\n\t    function initBase(baseOption) {\n\t        baseOption = baseOption;\n\t\n\t        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n\t        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\t        this.option = {};\n\t        this.option[OPTION_INNER_KEY] = 1;\n\t\n\t        /**\n\t         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t\n\t        /**\n\t         * Mapping between filtered series list and raw series list.\n\t         * key: filtered series indices, value: raw series indices.\n\t         * @type {Array.<nubmer>}\n\t         * @private\n\t         */\n\t        this._seriesIndices = null;\n\t\n\t        mergeTheme(baseOption, this._theme.option);\n\t\n\t        // TODO Needs clone when merging to the unexisted property\n\t        zrUtil.merge(baseOption, globalDefault, false);\n\t\n\t        this.mergeOption(baseOption);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     * @param {Array.<string>|string} types model types\n\t     * @return {Object} key: {string} type, value: {Array.<Object>} models\n\t     */\n\t    function getComponentsByTypes(componentsMap, types) {\n\t        if (!zrUtil.isArray(types)) {\n\t            types = types ? [types] : [];\n\t        }\n\t\n\t        var ret = {};\n\t        each(types, function (type) {\n\t            ret[type] = (componentsMap[type] || []).slice();\n\t        });\n\t\n\t        return ret;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function determineSubType(mainType, newCptOption, existComponent) {\n\t        var subType = newCptOption.type\n\t            ? newCptOption.type\n\t            : existComponent\n\t            ? existComponent.subType\n\t            // Use determineSubType only when there is no existComponent.\n\t            : ComponentModel.determineSubType(mainType, newCptOption);\n\t\n\t        // tooltip, markline, markpoint may always has no subType\n\t        return subType;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function createSeriesIndices(seriesModels) {\n\t        return map(seriesModels, function (series) {\n\t            return series.componentIndex;\n\t        }) || [];\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function filterBySubType(components, condition) {\n\t        // Using hasOwnProperty for restrict. Consider\n\t        // subType is undefined in user payload.\n\t        return condition.hasOwnProperty('subType')\n\t            ? filter(components, function (cpt) {\n\t                return cpt.subType === condition.subType;\n\t            })\n\t            : components;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function assertSeriesInitialized(ecModel) {\n\t        // Components that use _seriesIndices should depends on series component,\n\t        // which make sure that their initialization is after series.\n\t        if (__DEV__) {\n\t            if (!ecModel._seriesIndices) {\n\t                throw new Error('Series has not been initialized yet.');\n\t            }\n\t        }\n\t    }\n\t\n\t    zrUtil.mixin(GlobalModel, __webpack_require__(47));\n\t\n\t    module.exports = GlobalModel;\n\n\n/***/ },\n/* 124 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * ECharts option manager\n\t *\n\t * @module {echarts/model/OptionManager}\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var modelUtil = __webpack_require__(11);\n\t    var ComponentModel = __webpack_require__(18);\n\t    var each = zrUtil.each;\n\t    var clone = zrUtil.clone;\n\t    var map = zrUtil.map;\n\t    var merge = zrUtil.merge;\n\t\n\t    var QUERY_REG = /^(min|max)?(.+)$/;\n\t\n\t    /**\n\t     * TERM EXPLANATIONS:\n\t     *\n\t     * [option]:\n\t     *\n\t     *     An object that contains definitions of components. For example:\n\t     *     var option = {\n\t     *         title: {...},\n\t     *         legend: {...},\n\t     *         visualMap: {...},\n\t     *         series: [\n\t     *             {data: [...]},\n\t     *             {data: [...]},\n\t     *             ...\n\t     *         ]\n\t     *     };\n\t     *\n\t     * [rawOption]:\n\t     *\n\t     *     An object input to echarts.setOption. 'rawOption' may be an\n\t     *     'option', or may be an object contains multi-options. For example:\n\t     *     var option = {\n\t     *         baseOption: {\n\t     *             title: {...},\n\t     *             legend: {...},\n\t     *             series: [\n\t     *                 {data: [...]},\n\t     *                 {data: [...]},\n\t     *                 ...\n\t     *             ]\n\t     *         },\n\t     *         timeline: {...},\n\t     *         options: [\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             ...\n\t     *         ],\n\t     *         media: [\n\t     *             {\n\t     *                 query: {maxWidth: 320},\n\t     *                 option: {series: {x: 20}, visualMap: {show: false}}\n\t     *             },\n\t     *             {\n\t     *                 query: {minWidth: 320, maxWidth: 720},\n\t     *                 option: {series: {x: 500}, visualMap: {show: true}}\n\t     *             },\n\t     *             {\n\t     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n\t     *             }\n\t     *         ]\n\t     *     };\n\t     *\n\t     * @alias module:echarts/model/OptionManager\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    function OptionManager(api) {\n\t\n\t        /**\n\t         * @private\n\t         * @type {module:echarts/ExtensionAPI}\n\t         */\n\t        this._api = api;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._timelineOptions = [];\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._mediaList = [];\n\t\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._mediaDefault;\n\t\n\t        /**\n\t         * -1, means default.\n\t         * empty means no media.\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._currentMediaIndices = [];\n\t\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._optionBackup;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._newBaseOption;\n\t    }\n\t\n\t    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n\t    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n\t    // rawOption cloned and backuped when timeline changed, which does no\n\t    // good to performance. What's more, that both timeline and setOption\n\t    // method supply 'notMerge' brings complex and some problems.\n\t    // Consider this case:\n\t    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n\t    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\t\n\t    OptionManager.prototype = {\n\t\n\t        constructor: OptionManager,\n\t\n\t        /**\n\t         * @public\n\t         * @param {Object} rawOption Raw option.\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @param {Array.<Function>} optionPreprocessorFuncs\n\t         * @return {Object} Init option\n\t         */\n\t        setOption: function (rawOption, optionPreprocessorFuncs) {\n\t            rawOption = clone(rawOption, true);\n\t\n\t            // FIXME\n\t            // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。\n\t\n\t            var oldOptionBackup = this._optionBackup;\n\t            var newParsedOption = parseRawOption.call(\n\t                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n\t            );\n\t            this._newBaseOption = newParsedOption.baseOption;\n\t\n\t            // For setOption at second time (using merge mode);\n\t            if (oldOptionBackup) {\n\t                // Only baseOption can be merged.\n\t                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\t\n\t                // For simplicity, timeline options and media options do not support merge,\n\t                // that is, if you `setOption` twice and both has timeline options, the latter\n\t                // timeline opitons will not be merged to the formers, but just substitude them.\n\t                if (newParsedOption.timelineOptions.length) {\n\t                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n\t                }\n\t                if (newParsedOption.mediaList.length) {\n\t                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n\t                }\n\t                if (newParsedOption.mediaDefault) {\n\t                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n\t                }\n\t            }\n\t            else {\n\t                this._optionBackup = newParsedOption;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {boolean} isRecreate\n\t         * @return {Object}\n\t         */\n\t        mountOption: function (isRecreate) {\n\t            var optionBackup = this._optionBackup;\n\t\n\t            // TODO\n\t            // 如果没有reset功能则不clone。\n\t\n\t            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n\t            this._mediaList = map(optionBackup.mediaList, clone);\n\t            this._mediaDefault = clone(optionBackup.mediaDefault);\n\t            this._currentMediaIndices = [];\n\t\n\t            return clone(isRecreate\n\t                // this._optionBackup.baseOption, which is created at the first `setOption`\n\t                // called, and is merged into every new option by inner method `mergeOption`\n\t                // each time `setOption` called, can be only used in `isRecreate`, because\n\t                // its reliability is under suspicion. In other cases option merge is\n\t                // performed by `model.mergeOption`.\n\t                ? optionBackup.baseOption : this._newBaseOption\n\t            );\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @return {Object}\n\t         */\n\t        getTimelineOption: function (ecModel) {\n\t            var option;\n\t            var timelineOptions = this._timelineOptions;\n\t\n\t            if (timelineOptions.length) {\n\t                // getTimelineOption can only be called after ecModel inited,\n\t                // so we can get currentIndex from timelineModel.\n\t                var timelineModel = ecModel.getComponent('timeline');\n\t                if (timelineModel) {\n\t                    option = clone(\n\t                        timelineOptions[timelineModel.getCurrentIndex()],\n\t                        true\n\t                    );\n\t                }\n\t            }\n\t\n\t            return option;\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @return {Array.<Object>}\n\t         */\n\t        getMediaOption: function (ecModel) {\n\t            var ecWidth = this._api.getWidth();\n\t            var ecHeight = this._api.getHeight();\n\t            var mediaList = this._mediaList;\n\t            var mediaDefault = this._mediaDefault;\n\t            var indices = [];\n\t            var result = [];\n\t\n\t            // No media defined.\n\t            if (!mediaList.length && !mediaDefault) {\n\t                return result;\n\t            }\n\t\n\t            // Multi media may be applied, the latter defined media has higher priority.\n\t            for (var i = 0, len = mediaList.length; i < len; i++) {\n\t                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n\t                    indices.push(i);\n\t                }\n\t            }\n\t\n\t            // FIXME\n\t            // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。\n\t            if (!indices.length && mediaDefault) {\n\t                indices = [-1];\n\t            }\n\t\n\t            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n\t                result = map(indices, function (index) {\n\t                    return clone(\n\t                        index === -1 ? mediaDefault.option : mediaList[index].option\n\t                    );\n\t                });\n\t            }\n\t            // Otherwise return nothing.\n\t\n\t            this._currentMediaIndices = indices;\n\t\n\t            return result;\n\t        }\n\t    };\n\t\n\t    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n\t        var timelineOptions = [];\n\t        var mediaList = [];\n\t        var mediaDefault;\n\t        var baseOption;\n\t\n\t        // Compatible with ec2.\n\t        var timelineOpt = rawOption.timeline;\n\t\n\t        if (rawOption.baseOption) {\n\t            baseOption = rawOption.baseOption;\n\t        }\n\t\n\t        // For timeline\n\t        if (timelineOpt || rawOption.options) {\n\t            baseOption = baseOption || {};\n\t            timelineOptions = (rawOption.options || []).slice();\n\t        }\n\t\n\t        // For media query\n\t        if (rawOption.media) {\n\t            baseOption = baseOption || {};\n\t            var media = rawOption.media;\n\t            each(media, function (singleMedia) {\n\t                if (singleMedia && singleMedia.option) {\n\t                    if (singleMedia.query) {\n\t                        mediaList.push(singleMedia);\n\t                    }\n\t                    else if (!mediaDefault) {\n\t                        // Use the first media default.\n\t                        mediaDefault = singleMedia;\n\t                    }\n\t                }\n\t            });\n\t        }\n\t\n\t        // For normal option\n\t        if (!baseOption) {\n\t            baseOption = rawOption;\n\t        }\n\t\n\t        // Set timelineOpt to baseOption in ec3,\n\t        // which is convenient for merge option.\n\t        if (!baseOption.timeline) {\n\t            baseOption.timeline = timelineOpt;\n\t        }\n\t\n\t        // Preprocess.\n\t        each([baseOption].concat(timelineOptions)\n\t            .concat(zrUtil.map(mediaList, function (media) {\n\t                return media.option;\n\t            })),\n\t            function (option) {\n\t                each(optionPreprocessorFuncs, function (preProcess) {\n\t                    preProcess(option, isNew);\n\t                });\n\t            }\n\t        );\n\t\n\t        return {\n\t            baseOption: baseOption,\n\t            timelineOptions: timelineOptions,\n\t            mediaDefault: mediaDefault,\n\t            mediaList: mediaList\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n\t     * Support: width, height, aspectRatio\n\t     * Can use max or min as prefix.\n\t     */\n\t    function applyMediaQuery(query, ecWidth, ecHeight) {\n\t        var realMap = {\n\t            width: ecWidth,\n\t            height: ecHeight,\n\t            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n\t        };\n\t\n\t        var applicatable = true;\n\t\n\t        zrUtil.each(query, function (value, attr) {\n\t            var matched = attr.match(QUERY_REG);\n\t\n\t            if (!matched || !matched[1] || !matched[2]) {\n\t                return;\n\t            }\n\t\n\t            var operator = matched[1];\n\t            var realAttr = matched[2].toLowerCase();\n\t\n\t            if (!compare(realMap[realAttr], value, operator)) {\n\t                applicatable = false;\n\t            }\n\t        });\n\t\n\t        return applicatable;\n\t    }\n\t\n\t    function compare(real, expect, operator) {\n\t        if (operator === 'min') {\n\t            return real >= expect;\n\t        }\n\t        else if (operator === 'max') {\n\t            return real <= expect;\n\t        }\n\t        else { // Equals\n\t            return real === expect;\n\t        }\n\t    }\n\t\n\t    function indicesEquals(indices1, indices2) {\n\t        // indices is always order by asc and has only finite number.\n\t        return indices1.join(',') === indices2.join(',');\n\t    }\n\t\n\t    /**\n\t     * Consider case:\n\t     * `chart.setOption(opt1);`\n\t     * Then user do some interaction like dataZoom, dataView changing.\n\t     * `chart.setOption(opt2);`\n\t     * Then user press 'reset button' in toolbox.\n\t     *\n\t     * After doing that all of the interaction effects should be reset, the\n\t     * chart should be the same as the result of invoke\n\t     * `chart.setOption(opt1); chart.setOption(opt2);`.\n\t     *\n\t     * Although it is not able ensure that\n\t     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n\t     * `chart.setOption(merge(opt1, opt2));` exactly,\n\t     * this might be the only simple way to implement that feature.\n\t     *\n\t     * MEMO: We've considered some other approaches:\n\t     * 1. Each model handle its self restoration but not uniform treatment.\n\t     *     (Too complex in logic and error-prone)\n\t     * 2. Use a shadow ecModel. (Performace expensive)\n\t     */\n\t    function mergeOption(oldOption, newOption) {\n\t        newOption = newOption || {};\n\t\n\t        each(newOption, function (newCptOpt, mainType) {\n\t            if (newCptOpt == null) {\n\t                return;\n\t            }\n\t\n\t            var oldCptOpt = oldOption[mainType];\n\t\n\t            if (!ComponentModel.hasClass(mainType)) {\n\t                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n\t            }\n\t            else {\n\t                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n\t                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\t\n\t                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\t\n\t                oldOption[mainType] = map(mapResult, function (item) {\n\t                    return (item.option && item.exist)\n\t                        ? merge(item.exist, item.option, true)\n\t                        : (item.exist || item.option);\n\t                });\n\t            }\n\t        });\n\t    }\n\t\n\t    module.exports = OptionManager;\n\n\n/***/ },\n/* 125 */\n/***/ function(module, exports) {\n\n\t\n\t    var platform = '';\n\t    // Navigator not exists in node\n\t    if (typeof navigator !== 'undefined') {\n\t        platform = navigator.platform || '';\n\t    }\n\t    module.exports = {\n\t        // 全图默认背景\n\t        // backgroundColor: 'rgba(0,0,0,0)',\n\t\n\t        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n\t        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n\t        // 浅色\n\t        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n\t        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n\t        // 深色\n\t        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\t\n\t        // 默认需要 Grid 配置项\n\t        // grid: {},\n\t        // 主题，主题\n\t        textStyle: {\n\t            // color: '#000',\n\t            // decoration: 'none',\n\t            // PENDING\n\t            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n\t            // fontFamily: 'Arial, Verdana, sans-serif',\n\t            fontSize: 12,\n\t            fontStyle: 'normal',\n\t            fontWeight: 'normal'\n\t        },\n\t\n\t        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n\t        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t        // Default is source-over\n\t        blendMode: null,\n\t\n\t        animation: true,\n\t        animationDuration: 1000,\n\t        animationDurationUpdate: 300,\n\t        animationEasing: 'exponentialOut',\n\t        animationEasingUpdate: 'cubicOut',\n\t\n\t        animationThreshold: 2000,\n\t        // Configuration for progressive/incremental rendering\n\t        progressiveThreshold: 3000,\n\t        progressive: 400,\n\t\n\t        // Threshold of if use single hover layer to optimize.\n\t        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n\t        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n\t        // which is unexpected.\n\t        // see example <echarts/test/heatmap-large.html>.\n\t        hoverLayerThreshold: 3000\n\t    };\n\n\n/***/ },\n/* 126 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    module.exports = {\n\t        getAreaStyle: __webpack_require__(43)(\n\t            [\n\t                ['fill', 'color'],\n\t                ['shadowBlur'],\n\t                ['shadowOffsetX'],\n\t                ['shadowOffsetY'],\n\t                ['opacity'],\n\t                ['shadowColor']\n\t            ]\n\t        )\n\t    };\n\n\n/***/ },\n/* 127 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t        getBoxLayoutParams: function () {\n\t            return {\n\t                left: this.get('left'),\n\t                top: this.get('top'),\n\t                right: this.get('right'),\n\t                bottom: this.get('bottom'),\n\t                width: this.get('width'),\n\t                height: this.get('height')\n\t            };\n\t        }\n\t    };\n\n\n/***/ },\n/* 128 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var getItemStyle = __webpack_require__(43)(\n\t        [\n\t            ['fill', 'color'],\n\t            ['stroke', 'borderColor'],\n\t            ['lineWidth', 'borderWidth'],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor'],\n\t            ['textPosition'],\n\t            ['textAlign']\n\t        ]\n\t    );\n\t    module.exports = {\n\t        getItemStyle: function (excludes) {\n\t            var style = getItemStyle.call(this, excludes);\n\t            var lineDash = this.getBorderLineDash();\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t\n\t        getBorderLineDash: function () {\n\t            var lineType = this.get('borderType');\n\t            return (lineType === 'solid' || lineType == null) ? null\n\t                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n\t        }\n\t    };\n\n\n/***/ },\n/* 129 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var getLineStyle = __webpack_require__(43)(\n\t        [\n\t            ['lineWidth', 'width'],\n\t            ['stroke', 'color'],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]\n\t    );\n\t    module.exports = {\n\t        getLineStyle: function (excludes) {\n\t            var style = getLineStyle.call(this, excludes);\n\t            var lineDash = this.getLineDash(style.lineWidth);\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t\n\t        getLineDash: function (lineWidth) {\n\t            if (lineWidth == null) {\n\t                lineWidth = 1;\n\t            }\n\t            var lineType = this.get('type');\n\t            var dotSize = Math.max(lineWidth, 2);\n\t            var dashSize = lineWidth * 4;\n\t            return (lineType === 'solid' || lineType == null) ? null\n\t                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n\t        }\n\t    };\n\n\n/***/ },\n/* 130 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var textContain = __webpack_require__(26);\n\t\n\t    function getShallow(model, path) {\n\t        return model && model.getShallow(path);\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Get color property or get color from option.textStyle.color\n\t         * @return {string}\n\t         */\n\t        getTextColor: function () {\n\t            var ecModel = this.ecModel;\n\t            return this.getShallow('color')\n\t                || (ecModel && ecModel.get('textStyle.color'));\n\t        },\n\t\n\t        /**\n\t         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n\t         * @return {string}\n\t         */\n\t        getFont: function () {\n\t            var ecModel = this.ecModel;\n\t            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n\t            return [\n\t                // FIXME in node-canvas fontWeight is before fontStyle\n\t                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n\t                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n\t                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n\t                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n\t            ].join(' ');\n\t        },\n\t\n\t        getTextRect: function (text) {\n\t            return textContain.getBoundingRect(\n\t                text,\n\t                this.getFont(),\n\t                this.getShallow('align'),\n\t                this.getShallow('baseline')\n\t            );\n\t        },\n\t\n\t        truncateText: function (text, containerWidth, ellipsis, options) {\n\t            return textContain.truncateText(\n\t                text, containerWidth, this.getFont(), ellipsis, options\n\t            );\n\t        }\n\t    };\n\n\n/***/ },\n/* 131 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var formatUtil = __webpack_require__(9);\n\t    var modelUtil = __webpack_require__(11);\n\t    var ComponentModel = __webpack_require__(18);\n\t    var colorPaletteMixin = __webpack_require__(47);\n\t    var env = __webpack_require__(14);\n\t    var layout = __webpack_require__(25);\n\t\n\t    var encodeHTML = formatUtil.encodeHTML;\n\t    var addCommas = formatUtil.addCommas;\n\t\n\t    var SeriesModel = ComponentModel.extend({\n\t\n\t        type: 'series.__base__',\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        seriesIndex: 0,\n\t\n\t        // coodinateSystem will be injected in the echarts/CoordinateSystem\n\t        coordinateSystem: null,\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        defaultOption: null,\n\t\n\t        /**\n\t         * Data provided for legend\n\t         * @type {Function}\n\t         */\n\t        // PENDING\n\t        legendDataProvider: null,\n\t\n\t        /**\n\t         * Access path of color for visual\n\t         */\n\t        visualColorAccessPath: 'itemStyle.normal.color',\n\t\n\t        /**\n\t         * Support merge layout params.\n\t         * Only support 'box' now (left/right/top/bottom/width/height).\n\t         * @type {string|Object} Object can be {ignoreSize: true}\n\t         * @readOnly\n\t         */\n\t        layoutMode: null,\n\t\n\t        init: function (option, parentModel, ecModel, extraOpt) {\n\t\n\t            /**\n\t             * @type {number}\n\t             * @readOnly\n\t             */\n\t            this.seriesIndex = this.componentIndex;\n\t\n\t            this.mergeDefaultAndTheme(option, ecModel);\n\t\n\t            /**\n\t             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n\t             * @private\n\t             */\n\t            this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n\t\n\t            // If we reverse the order (make this._data firstly, and then make\n\t            // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n\t            // cause this._data.graph.data !== this._data when using\n\t            // module:echarts/data/Graph or module:echarts/data/Tree.\n\t            // See module:echarts/data/helper/linkList\n\t            this._data = this._dataBeforeProcessed.cloneShallow();\n\t        },\n\t\n\t        /**\n\t         * Util for merge default and theme to option\n\t         * @param  {Object} option\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         */\n\t        mergeDefaultAndTheme: function (option, ecModel) {\n\t            var layoutMode = this.layoutMode;\n\t            var inputPositionParams = layoutMode\n\t                ? layout.getLayoutParams(option) : {};\n\t\n\t            zrUtil.merge(\n\t                option,\n\t                ecModel.getTheme().get(this.subType)\n\t            );\n\t            zrUtil.merge(option, this.getDefaultOption());\n\t\n\t            // Default label emphasis `position` and `show`\n\t            // FIXME Set label in mergeOption\n\t            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\t\n\t            this.fillDataTextStyle(option.data);\n\t\n\t            if (layoutMode) {\n\t                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t            }\n\t        },\n\t\n\t        mergeOption: function (newSeriesOption, ecModel) {\n\t            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n\t            this.fillDataTextStyle(newSeriesOption.data);\n\t\n\t            var layoutMode = this.layoutMode;\n\t            if (layoutMode) {\n\t                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n\t            }\n\t\n\t            var data = this.getInitialData(newSeriesOption, ecModel);\n\t            // TODO Merge data?\n\t            if (data) {\n\t                this._data = data;\n\t                this._dataBeforeProcessed = data.cloneShallow();\n\t            }\n\t        },\n\t\n\t        fillDataTextStyle: function (data) {\n\t            // Default data label emphasis `position` and `show`\n\t            // FIXME Tree structure data ?\n\t            // FIXME Performance ?\n\t            if (data) {\n\t                for (var i = 0; i < data.length; i++) {\n\t                    if (data[i] && data[i].label) {\n\t                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Init a data structure from data related option in series\n\t         * Must be overwritten\n\t         */\n\t        getInitialData: function () {},\n\t\n\t        /**\n\t         * @param {string} [dataType]\n\t         * @return {module:echarts/data/List}\n\t         */\n\t        getData: function (dataType) {\n\t            return dataType == null ? this._data : this._data.getLinkedData(dataType);\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/data/List} data\n\t         */\n\t        setData: function (data) {\n\t            this._data = data;\n\t        },\n\t\n\t        /**\n\t         * Get data before processed\n\t         * @return {module:echarts/data/List}\n\t         */\n\t        getRawData: function () {\n\t            return this._dataBeforeProcessed;\n\t        },\n\t\n\t        /**\n\t         * Coord dimension to data dimension.\n\t         *\n\t         * By default the result is the same as dimensions of series data.\n\t         * But in some series data dimensions are different from coord dimensions (i.e.\n\t         * candlestick and boxplot). Override this method to handle those cases.\n\t         *\n\t         * Coord dimension to data dimension can be one-to-many\n\t         *\n\t         * @param {string} coordDim\n\t         * @return {Array.<string>} dimensions on the axis.\n\t         */\n\t        coordDimToDataDim: function (coordDim) {\n\t            return [coordDim];\n\t        },\n\t\n\t        /**\n\t         * Convert data dimension to coord dimension.\n\t         *\n\t         * @param {string|number} dataDim\n\t         * @return {string}\n\t         */\n\t        dataDimToCoordDim: function (dataDim) {\n\t            return dataDim;\n\t        },\n\t\n\t        /**\n\t         * Get base axis if has coordinate system and has axis.\n\t         * By default use coordSys.getBaseAxis();\n\t         * Can be overrided for some chart.\n\t         * @return {type} description\n\t         */\n\t        getBaseAxis: function () {\n\t            var coordSys = this.coordinateSystem;\n\t            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n\t        },\n\t\n\t        // FIXME\n\t        /**\n\t         * Default tooltip formatter\n\t         *\n\t         * @param {number} dataIndex\n\t         * @param {boolean} [multipleSeries=false]\n\t         * @param {number} [dataType]\n\t         */\n\t        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n\t            function formatArrayValue(value) {\n\t                var result = [];\n\t\n\t                zrUtil.each(value, function (val, idx) {\n\t                    var dimInfo = data.getDimensionInfo(idx);\n\t                    var dimType = dimInfo && dimInfo.type;\n\t                    var valStr;\n\t\n\t                    if (dimType === 'ordinal') {\n\t                        valStr = val + '';\n\t                    }\n\t                    else if (dimType === 'time') {\n\t                        valStr = multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val);\n\t                    }\n\t                    else {\n\t                        valStr = addCommas(val);\n\t                    }\n\t\n\t                    valStr && result.push(valStr);\n\t                });\n\t\n\t                return result.join(', ');\n\t            }\n\t\n\t            var data = this._data;\n\t\n\t            var value = this.getRawValue(dataIndex);\n\t            var formattedValue = zrUtil.isArray(value)\n\t                ? formatArrayValue(value) : addCommas(value);\n\t            var name = data.getName(dataIndex);\n\t\n\t            var color = data.getItemVisual(dataIndex, 'color');\n\t            if (zrUtil.isObject(color) && color.colorStops) {\n\t                color = (color.colorStops[0] || {}).color;\n\t            }\n\t            color = color || 'transparent';\n\t\n\t            var colorEl = '<span style=\"display:inline-block;margin-right:5px;'\n\t                + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n\t\n\t            var seriesName = this.name;\n\t            // FIXME\n\t            if (seriesName === '\\0-') {\n\t                // Not show '-'\n\t                seriesName = '';\n\t            }\n\t            return !multipleSeries\n\t                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl\n\t                    + (name\n\t                        ? encodeHTML(name) + ' : ' + formattedValue\n\t                        : formattedValue)\n\t                  )\n\t                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);\n\t        },\n\t\n\t        /**\n\t         * @return {boolean}\n\t         */\n\t        ifEnableAnimation: function () {\n\t            if (env.node) {\n\t                return false;\n\t            }\n\t\n\t            var animationEnabled = this.getShallow('animation');\n\t            if (animationEnabled) {\n\t                if (this.getData().count() > this.getShallow('animationThreshold')) {\n\t                    animationEnabled = false;\n\t                }\n\t            }\n\t            return animationEnabled;\n\t        },\n\t\n\t        restoreData: function () {\n\t            this._data = this._dataBeforeProcessed.cloneShallow();\n\t        },\n\t\n\t        getColorFromPalette: function (name, scope) {\n\t            var ecModel = this.ecModel;\n\t            // PENDING\n\t            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n\t            if (!color) {\n\t                color = ecModel.getColorFromPalette(name, scope);\n\t            }\n\t            return color;\n\t        },\n\t\n\t        /**\n\t         * Get data indices for show tooltip content. See tooltip.\n\t         * @abstract\n\t         * @param {Array.<string>|string} dim\n\t         * @param {Array.<number>} value\n\t         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n\t         * @return {Array.<number>} data indices.\n\t         */\n\t        getAxisTooltipDataIndex: null,\n\t\n\t        /**\n\t         * See tooltip.\n\t         * @abstract\n\t         * @param {number} dataIndex\n\t         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n\t         */\n\t        getTooltipPosition: null\n\t    });\n\t\n\t    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n\t    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\t\n\t    module.exports = SeriesModel;\n\n\n/***/ },\n/* 132 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Compatitable with 2.0\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var compatStyle = __webpack_require__(133);\n\t\n\t    function get(opt, path) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        for (var i = 0; i < path.length; i++) {\n\t            obj = obj && obj[path[i]];\n\t            if (obj == null) {\n\t                break;\n\t            }\n\t        }\n\t        return obj;\n\t    }\n\t\n\t    function set(opt, path, val, overwrite) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        var key;\n\t        for (var i = 0; i < path.length - 1; i++) {\n\t            key = path[i];\n\t            if (obj[key] == null) {\n\t                obj[key] = {};\n\t            }\n\t            obj = obj[key];\n\t        }\n\t        if (overwrite || obj[path[i]] == null) {\n\t            obj[path[i]] = val;\n\t        }\n\t    }\n\t\n\t    function compatLayoutProperties(option) {\n\t        each(LAYOUT_PROPERTIES, function (prop) {\n\t            if (prop[0] in option && !(prop[1] in option)) {\n\t                option[prop[1]] = option[prop[0]];\n\t            }\n\t        });\n\t    }\n\t\n\t    var LAYOUT_PROPERTIES = [\n\t        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n\t    ];\n\t\n\t    var COMPATITABLE_COMPONENTS = [\n\t        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n\t    ];\n\t\n\t    var COMPATITABLE_SERIES = [\n\t        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n\t        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n\t        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n\t    ];\n\t\n\t    var each = zrUtil.each;\n\t\n\t    module.exports = function (option) {\n\t        each(option.series, function (seriesOpt) {\n\t            if (!zrUtil.isObject(seriesOpt)) {\n\t                return;\n\t            }\n\t\n\t            var seriesType = seriesOpt.type;\n\t\n\t            compatStyle(seriesOpt);\n\t\n\t            if (seriesType === 'pie' || seriesType === 'gauge') {\n\t                if (seriesOpt.clockWise != null) {\n\t                    seriesOpt.clockwise = seriesOpt.clockWise;\n\t                }\n\t            }\n\t            if (seriesType === 'gauge') {\n\t                var pointerColor = get(seriesOpt, 'pointer.color');\n\t                pointerColor != null\n\t                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n\t            }\n\t\n\t            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n\t                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n\t                    compatLayoutProperties(seriesOpt);\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t\n\t        // dataRange has changed to visualMap\n\t        if (option.dataRange) {\n\t            option.visualMap = option.dataRange;\n\t        }\n\t\n\t        each(COMPATITABLE_COMPONENTS, function (componentName) {\n\t            var options = option[componentName];\n\t            if (options) {\n\t                if (!zrUtil.isArray(options)) {\n\t                    options = [options];\n\t                }\n\t                each(options, function (option) {\n\t                    compatLayoutProperties(option);\n\t                });\n\t            }\n\t        });\n\t    };\n\n\n/***/ },\n/* 133 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var POSSIBLE_STYLES = [\n\t        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n\t        'chordStyle', 'label', 'labelLine'\n\t    ];\n\t\n\t    function compatItemStyle(opt) {\n\t        var itemStyleOpt = opt && opt.itemStyle;\n\t        if (itemStyleOpt) {\n\t            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n\t                var normalItemStyleOpt = itemStyleOpt.normal;\n\t                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n\t                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].normal) {\n\t                        opt[styleName].normal = normalItemStyleOpt[styleName];\n\t                    }\n\t                    else {\n\t                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n\t                    }\n\t                    normalItemStyleOpt[styleName] = null;\n\t                }\n\t                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].emphasis) {\n\t                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n\t                    }\n\t                    else {\n\t                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n\t                    }\n\t                    emphasisItemStyleOpt[styleName] = null;\n\t                }\n\t            });\n\t        }\n\t    }\n\t\n\t    module.exports = function (seriesOpt) {\n\t        if (!seriesOpt) {\n\t            return;\n\t        }\n\t        compatItemStyle(seriesOpt);\n\t        compatItemStyle(seriesOpt.markPoint);\n\t        compatItemStyle(seriesOpt.markLine);\n\t        var data = seriesOpt.data;\n\t        if (data) {\n\t            for (var i = 0; i < data.length; i++) {\n\t                compatItemStyle(data[i]);\n\t            }\n\t            // mark point data\n\t            var markPoint = seriesOpt.markPoint;\n\t            if (markPoint && markPoint.data) {\n\t                var mpData = markPoint.data;\n\t                for (var i = 0; i < mpData.length; i++) {\n\t                    compatItemStyle(mpData[i]);\n\t                }\n\t            }\n\t            // mark line data\n\t            var markLine = seriesOpt.markLine;\n\t            if (markLine && markLine.data) {\n\t                var mlData = markLine.data;\n\t                for (var i = 0; i < mlData.length; i++) {\n\t                    if (zrUtil.isArray(mlData[i])) {\n\t                        compatItemStyle(mlData[i][0]);\n\t                        compatItemStyle(mlData[i][1]);\n\t                    }\n\t                    else {\n\t                        compatItemStyle(mlData[i]);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\n\n/***/ },\n/* 134 */,\n/* 135 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Symbol factory\n\t\n\t\n\t    var graphic = __webpack_require__(10);\n\t    var BoundingRect = __webpack_require__(13);\n\t\n\t    /**\n\t     * Triangle shape\n\t     * @inner\n\t     */\n\t    var Triangle = graphic.extendShape({\n\t        type: 'triangle',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t        buildPath: function (path, shape) {\n\t            var cx = shape.cx;\n\t            var cy = shape.cy;\n\t            var width = shape.width / 2;\n\t            var height = shape.height / 2;\n\t            path.moveTo(cx, cy - height);\n\t            path.lineTo(cx + width, cy + height);\n\t            path.lineTo(cx - width, cy + height);\n\t            path.closePath();\n\t        }\n\t    });\n\t    /**\n\t     * Diamond shape\n\t     * @inner\n\t     */\n\t    var Diamond = graphic.extendShape({\n\t        type: 'diamond',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t        buildPath: function (path, shape) {\n\t            var cx = shape.cx;\n\t            var cy = shape.cy;\n\t            var width = shape.width / 2;\n\t            var height = shape.height / 2;\n\t            path.moveTo(cx, cy - height);\n\t            path.lineTo(cx + width, cy);\n\t            path.lineTo(cx, cy + height);\n\t            path.lineTo(cx - width, cy);\n\t            path.closePath();\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Pin shape\n\t     * @inner\n\t     */\n\t    var Pin = graphic.extendShape({\n\t        type: 'pin',\n\t        shape: {\n\t            // x, y on the cusp\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (path, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var w = shape.width / 5 * 3;\n\t            // Height must be larger than width\n\t            var h = Math.max(w, shape.height);\n\t            var r = w / 2;\n\t\n\t            // Dist on y with tangent point and circle center\n\t            var dy = r * r / (h - r);\n\t            var cy = y - h + r + dy;\n\t            var angle = Math.asin(dy / r);\n\t            // Dist on x with tangent point and circle center\n\t            var dx = Math.cos(angle) * r;\n\t\n\t            var tanX = Math.sin(angle);\n\t            var tanY = Math.cos(angle);\n\t\n\t            path.arc(\n\t                x, cy, r,\n\t                Math.PI - angle,\n\t                Math.PI * 2 + angle\n\t            );\n\t\n\t            var cpLen = r * 0.6;\n\t            var cpLen2 = r * 0.7;\n\t            path.bezierCurveTo(\n\t                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n\t                x, y - cpLen2,\n\t                x, y\n\t            );\n\t            path.bezierCurveTo(\n\t                x, y - cpLen2,\n\t                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n\t                x - dx, cy + dy\n\t            );\n\t            path.closePath();\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Arrow shape\n\t     * @inner\n\t     */\n\t    var Arrow = graphic.extendShape({\n\t\n\t        type: 'arrow',\n\t\n\t        shape: {\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var height = shape.height;\n\t            var width = shape.width;\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var dx = width / 3 * 2;\n\t            ctx.moveTo(x, y);\n\t            ctx.lineTo(x + dx, y + height);\n\t            ctx.lineTo(x, y + height / 4 * 3);\n\t            ctx.lineTo(x - dx, y + height);\n\t            ctx.lineTo(x, y);\n\t            ctx.closePath();\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Map of path contructors\n\t     * @type {Object.<string, module:zrender/graphic/Path>}\n\t     */\n\t    var symbolCtors = {\n\t        line: graphic.Line,\n\t\n\t        rect: graphic.Rect,\n\t\n\t        roundRect: graphic.Rect,\n\t\n\t        square: graphic.Rect,\n\t\n\t        circle: graphic.Circle,\n\t\n\t        diamond: Diamond,\n\t\n\t        pin: Pin,\n\t\n\t        arrow: Arrow,\n\t\n\t        triangle: Triangle\n\t    };\n\t\n\t    var symbolShapeMakers = {\n\t\n\t        line: function (x, y, w, h, shape) {\n\t            // FIXME\n\t            shape.x1 = x;\n\t            shape.y1 = y + h / 2;\n\t            shape.x2 = x + w;\n\t            shape.y2 = y + h / 2;\n\t        },\n\t\n\t        rect: function (x, y, w, h, shape) {\n\t            shape.x = x;\n\t            shape.y = y;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        roundRect: function (x, y, w, h, shape) {\n\t            shape.x = x;\n\t            shape.y = y;\n\t            shape.width = w;\n\t            shape.height = h;\n\t            shape.r = Math.min(w, h) / 4;\n\t        },\n\t\n\t        square: function (x, y, w, h, shape) {\n\t            var size = Math.min(w, h);\n\t            shape.x = x;\n\t            shape.y = y;\n\t            shape.width = size;\n\t            shape.height = size;\n\t        },\n\t\n\t        circle: function (x, y, w, h, shape) {\n\t            // Put circle in the center of square\n\t            shape.cx = x + w / 2;\n\t            shape.cy = y + h / 2;\n\t            shape.r = Math.min(w, h) / 2;\n\t        },\n\t\n\t        diamond: function (x, y, w, h, shape) {\n\t            shape.cx = x + w / 2;\n\t            shape.cy = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        pin: function (x, y, w, h, shape) {\n\t            shape.x = x + w / 2;\n\t            shape.y = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        arrow: function (x, y, w, h, shape) {\n\t            shape.x = x + w / 2;\n\t            shape.y = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        triangle: function (x, y, w, h, shape) {\n\t            shape.cx = x + w / 2;\n\t            shape.cy = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        }\n\t    };\n\t\n\t    var symbolBuildProxies = {};\n\t    for (var name in symbolCtors) {\n\t        if (symbolCtors.hasOwnProperty(name)) {\n\t            symbolBuildProxies[name] = new symbolCtors[name]();\n\t        }\n\t    }\n\t\n\t    var Symbol = graphic.extendShape({\n\t\n\t        type: 'symbol',\n\t\n\t        shape: {\n\t            symbolType: '',\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        beforeBrush: function () {\n\t            var style = this.style;\n\t            var shape = this.shape;\n\t            // FIXME\n\t            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n\t                style.textPosition = ['50%', '40%'];\n\t                style.textAlign = 'center';\n\t                style.textVerticalAlign = 'middle';\n\t            }\n\t        },\n\t\n\t        buildPath: function (ctx, shape, inBundle) {\n\t            var symbolType = shape.symbolType;\n\t            var proxySymbol = symbolBuildProxies[symbolType];\n\t            if (shape.symbolType !== 'none') {\n\t                if (!proxySymbol) {\n\t                    // Default rect\n\t                    symbolType = 'rect';\n\t                    proxySymbol = symbolBuildProxies[symbolType];\n\t                }\n\t                symbolShapeMakers[symbolType](\n\t                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n\t                );\n\t                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n\t            }\n\t        }\n\t    });\n\t\n\t    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n\t    var symbolPathSetColor = function (color) {\n\t        if (this.type !== 'image') {\n\t            var symbolStyle = this.style;\n\t            var symbolShape = this.shape;\n\t            if (symbolShape && symbolShape.symbolType === 'line') {\n\t                symbolStyle.stroke = color;\n\t            }\n\t            else if (this.__isEmptyBrush) {\n\t                symbolStyle.stroke = color;\n\t                symbolStyle.fill = '#fff';\n\t            }\n\t            else {\n\t                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\n\t                symbolStyle.fill && (symbolStyle.fill = color);\n\t                symbolStyle.stroke && (symbolStyle.stroke = color);\n\t            }\n\t            this.dirty(false);\n\t        }\n\t    };\n\t\n\t    var symbolUtil = {\n\t        /**\n\t         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n\t         * @param {string} symbolType\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {number} w\n\t         * @param {number} h\n\t         * @param {string} color\n\t         */\n\t        createSymbol: function (symbolType, x, y, w, h, color) {\n\t            var isEmpty = symbolType.indexOf('empty') === 0;\n\t            if (isEmpty) {\n\t                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n\t            }\n\t            var symbolPath;\n\t\n\t            if (symbolType.indexOf('image://') === 0) {\n\t                symbolPath = new graphic.Image({\n\t                    style: {\n\t                        image: symbolType.slice(8),\n\t                        x: x,\n\t                        y: y,\n\t                        width: w,\n\t                        height: h\n\t                    }\n\t                });\n\t            }\n\t            else if (symbolType.indexOf('path://') === 0) {\n\t                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n\t            }\n\t            else {\n\t                symbolPath = new Symbol({\n\t                    shape: {\n\t                        symbolType: symbolType,\n\t                        x: x,\n\t                        y: y,\n\t                        width: w,\n\t                        height: h\n\t                    }\n\t                });\n\t            }\n\t\n\t            symbolPath.__isEmptyBrush = isEmpty;\n\t\n\t            symbolPath.setColor = symbolPathSetColor;\n\t\n\t            symbolPath.setColor(color);\n\t\n\t            return symbolPath;\n\t        }\n\t    };\n\t\n\t    module.exports = symbolUtil;\n\n\n/***/ },\n/* 136 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var lib = {};\n\t\n\t    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n\t    var RATE = '\\0__throttleRate';\n\t    var THROTTLE_TYPE = '\\0__throttleType';\n\t\n\t    /**\n\t     * @public\n\t     * @param {(Function)} fn\n\t     * @param {number} [delay=0] Unit: ms.\n\t     * @param {boolean} [debounce=false]\n\t     *        true: If call interval less than `delay`, only the last call works.\n\t     *        false: If call interval less than `delay, call works on fixed rate.\n\t     * @return {(Function)} throttled fn.\n\t     */\n\t    lib.throttle = function (fn, delay, debounce) {\n\t\n\t        var currCall;\n\t        var lastCall = 0;\n\t        var lastExec = 0;\n\t        var timer = null;\n\t        var diff;\n\t        var scope;\n\t        var args;\n\t\n\t        delay = delay || 0;\n\t\n\t        function exec() {\n\t            lastExec = (new Date()).getTime();\n\t            timer = null;\n\t            fn.apply(scope, args || []);\n\t        }\n\t\n\t        var cb = function () {\n\t            currCall = (new Date()).getTime();\n\t            scope = this;\n\t            args = arguments;\n\t            diff = currCall - (debounce ? lastCall : lastExec) - delay;\n\t\n\t            clearTimeout(timer);\n\t\n\t            if (debounce) {\n\t                timer = setTimeout(exec, delay);\n\t            }\n\t            else {\n\t                if (diff >= 0) {\n\t                    exec();\n\t                }\n\t                else {\n\t                    timer = setTimeout(exec, -diff);\n\t                }\n\t            }\n\t\n\t            lastCall = currCall;\n\t        };\n\t\n\t        /**\n\t         * Clear throttle.\n\t         * @public\n\t         */\n\t        cb.clear = function () {\n\t            if (timer) {\n\t                clearTimeout(timer);\n\t                timer = null;\n\t            }\n\t        };\n\t\n\t        return cb;\n\t    };\n\t\n\t    /**\n\t     * Create throttle method or update throttle rate.\n\t     *\n\t     * @example\n\t     * ComponentView.prototype.render = function () {\n\t     *     ...\n\t     *     throttle.createOrUpdate(\n\t     *         this,\n\t     *         '_dispatchAction',\n\t     *         this.model.get('throttle'),\n\t     *         'fixRate'\n\t     *     );\n\t     * };\n\t     * ComponentView.prototype.remove = function () {\n\t     *     throttle.clear(this, '_dispatchAction');\n\t     * };\n\t     * ComponentView.prototype.dispose = function () {\n\t     *     throttle.clear(this, '_dispatchAction');\n\t     * };\n\t     *\n\t     * @public\n\t     * @param {Object} obj\n\t     * @param {string} fnAttr\n\t     * @param {number} [rate]\n\t     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n\t     * @return {Function} throttled function.\n\t     */\n\t    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n\t        var fn = obj[fnAttr];\n\t\n\t        if (!fn) {\n\t            return;\n\t        }\n\t\n\t        var originFn = fn[ORIGIN_METHOD] || fn;\n\t        var lastThrottleType = fn[THROTTLE_TYPE];\n\t        var lastRate = fn[RATE];\n\t\n\t        if (lastRate !== rate || lastThrottleType !== throttleType) {\n\t            if (rate == null || !throttleType) {\n\t                return (obj[fnAttr] = originFn);\n\t            }\n\t\n\t            fn = obj[fnAttr] = lib.throttle(\n\t                originFn, rate, throttleType === 'debounce'\n\t            );\n\t            fn[ORIGIN_METHOD] = originFn;\n\t            fn[THROTTLE_TYPE] = throttleType;\n\t            fn[RATE] = rate;\n\t        }\n\t\n\t        return fn;\n\t    };\n\t\n\t    /**\n\t     * Clear throttle. Example see throttle.createOrUpdate.\n\t     *\n\t     * @public\n\t     * @param {Object} obj\n\t     * @param {string} fnAttr\n\t     */\n\t    lib.clear = function (obj, fnAttr) {\n\t        var fn = obj[fnAttr];\n\t        if (fn && fn[ORIGIN_METHOD]) {\n\t            obj[fnAttr] = fn[ORIGIN_METHOD];\n\t        }\n\t    };\n\t\n\t    module.exports = lib;\n\t\n\n\n/***/ },\n/* 137 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Group = __webpack_require__(40);\n\t    var componentUtil = __webpack_require__(48);\n\t    var clazzUtil = __webpack_require__(21);\n\t\n\t    var Component = function () {\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewComponent');\n\t    };\n\t\n\t    Component.prototype = {\n\t\n\t        constructor: Component,\n\t\n\t        init: function (ecModel, api) {},\n\t\n\t        render: function (componentModel, ecModel, api, payload) {},\n\t\n\t        dispose: function () {}\n\t\n\t    };\n\t\n\t    var componentProto = Component.prototype;\n\t    componentProto.updateView\n\t        = componentProto.updateLayout\n\t        = componentProto.updateVisual\n\t        = function (seriesModel, ecModel, api, payload) {\n\t            // Do nothing;\n\t        };\n\t    // Enable Component.extend.\n\t    clazzUtil.enableClassExtend(Component);\n\t\n\t    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\t\n\t    module.exports = Component;\n\n\n/***/ },\n/* 138 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var Gradient = __webpack_require__(55);\n\t    module.exports = function (ecModel) {\n\t        function encodeColor(seriesModel) {\n\t            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n\t            var data = seriesModel.getData();\n\t            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n\t                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\t\n\t            // FIXME Set color function or use the platte color\n\t            data.setVisual('color', color);\n\t\n\t            // Only visible series has each data be visual encoded\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                if (typeof color === 'function' && !(color instanceof Gradient)) {\n\t                    data.each(function (idx) {\n\t                        data.setItemVisual(\n\t                            idx, 'color', color(seriesModel.getDataParams(idx))\n\t                        );\n\t                    });\n\t                }\n\t\n\t                // itemStyle in each data item\n\t                data.each(function (idx) {\n\t                    var itemModel = data.getItemModel(idx);\n\t                    var color = itemModel.get(colorAccessPath, true);\n\t                    if (color != null) {\n\t                        data.setItemVisual(idx, 'color', color);\n\t                    }\n\t                });\n\t            }\n\t        }\n\t        ecModel.eachRawSeries(encodeColor);\n\t    };\n\n\n/***/ },\n/* 139 */,\n/* 140 */,\n/* 141 */,\n/* 142 */,\n/* 143 */,\n/* 144 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports =\n\t/******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"/dist/\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ({\n\t\n\t/***/ 0:\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\tmodule.exports = __webpack_require__(280);\n\t\n\t\n\t/***/ },\n\t\n\t/***/ 53:\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __webpack_require__(51);\n\t\n\t/***/ },\n\t\n\t/***/ 280:\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\texports.__esModule = true;\n\t\n\t\tvar _main = __webpack_require__(281);\n\t\n\t\tvar _main2 = _interopRequireDefault(_main);\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t\t/* istanbul ignore next */\n\t\t_main2.default.install = function (Vue) {\n\t\t  Vue.component(_main2.default.name, _main2.default);\n\t\t};\n\t\n\t\texports.default = _main2.default;\n\t\n\t/***/ },\n\t\n\t/***/ 281:\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\tvar __vue_exports__, __vue_options__\n\t\tvar __vue_styles__ = {}\n\t\n\t\t/* script */\n\t\t__vue_exports__ = __webpack_require__(282)\n\t\n\t\t/* template */\n\t\tvar __vue_template__ = __webpack_require__(283)\n\t\t__vue_options__ = __vue_exports__ = __vue_exports__ || {}\n\t\tif (\n\t\t  typeof __vue_exports__.default === \"object\" ||\n\t\t  typeof __vue_exports__.default === \"function\"\n\t\t) {\n\t\t__vue_options__ = __vue_exports__ = __vue_exports__.default\n\t\t}\n\t\tif (typeof __vue_options__ === \"function\") {\n\t\t  __vue_options__ = __vue_options__.options\n\t\t}\n\t\n\t\t__vue_options__.render = __vue_template__.render\n\t\t__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\t\n\t\tmodule.exports = __vue_exports__\n\t\n\t\n\t/***/ },\n\t\n\t/***/ 282:\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\texports.__esModule = true;\n\t\n\t\tvar _vuePopper = __webpack_require__(53);\n\t\n\t\tvar _vuePopper2 = _interopRequireDefault(_vuePopper);\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t\texports.default = {\n\t\t  name: 'el-tooltip',\n\t\n\t\t  mixins: [_vuePopper2.default],\n\t\n\t\t  props: {\n\t\t    openDelay: {\n\t\t      type: Number,\n\t\t      default: 0\n\t\t    },\n\t\t    disabled: Boolean,\n\t\t    manual: Boolean,\n\t\t    effect: {\n\t\t      type: String,\n\t\t      default: 'dark'\n\t\t    },\n\t\t    content: String,\n\t\t    visibleArrow: {\n\t\t      default: true\n\t\t    },\n\t\t    transition: {\n\t\t      type: String,\n\t\t      default: 'fade-in-linear'\n\t\t    },\n\t\t    options: {\n\t\t      default: function _default() {\n\t\t        return {\n\t\t          boundariesPadding: 10,\n\t\t          gpuAcceleration: false\n\t\t        };\n\t\t      }\n\t\t    }\n\t\t  },\n\t\n\t\t  methods: {\n\t\t    handleShowPopper: function handleShowPopper() {\n\t\t      var _this = this;\n\t\n\t\t      if (this.manual) return;\n\t\t      this.timeout = setTimeout(function () {\n\t\t        _this.showPopper = true;\n\t\t      }, this.openDelay);\n\t\t    },\n\t\t    handleClosePopper: function handleClosePopper() {\n\t\t      if (this.manual) return;\n\t\t      clearTimeout(this.timeout);\n\t\t      this.showPopper = false;\n\t\t    }\n\t\t  }\n\t\t}; //\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\t//\n\t\n\t/***/ },\n\t\n\t/***/ 283:\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._c;\n\t\t  return _h('div', {\n\t\t    staticClass: \"el-tooltip\",\n\t\t    on: {\n\t\t      \"mouseenter\": _vm.handleShowPopper,\n\t\t      \"mouseleave\": _vm.handleClosePopper\n\t\t    }\n\t\t  }, [_h('div', {\n\t\t    ref: \"reference\",\n\t\t    staticClass: \"el-tooltip__rel\"\n\t\t  }, [_vm._t(\"default\")]), _h('transition', {\n\t\t    attrs: {\n\t\t      \"name\": _vm.transition\n\t\t    },\n\t\t    on: {\n\t\t      \"after-leave\": _vm.doDestroy\n\t\t    }\n\t\t  }, [_h('div', {\n\t\t    directives: [{\n\t\t      name: \"show\",\n\t\t      rawName: \"v-show\",\n\t\t      value: (!_vm.disabled && _vm.showPopper),\n\t\t      expression: \"!disabled && showPopper\"\n\t\t    }],\n\t\t    ref: \"popper\",\n\t\t    staticClass: \"el-tooltip__popper\",\n\t\t    class: ['is-' + _vm.effect]\n\t\t  }, [_vm._t(\"content\", [_h('div', {\n\t\t    domProps: {\n\t\t      \"textContent\": _vm._s(_vm.content)\n\t\t    }\n\t\t  })])])])])\n\t\t},staticRenderFns: []}\n\t\n\t/***/ }\n\t\n\t/******/ });\n\n/***/ },\n/* 145 */,\n/* 146 */,\n/* 147 */,\n/* 148 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(106);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(4)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../css-loader/index.js?-autoprefixer&sourceMap!./../../../postcss-loader/index.js!./tooltip.css\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../css-loader/index.js?-autoprefixer&sourceMap!./../../../postcss-loader/index.js!./tooltip.css\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 149 */,\n/* 150 */,\n/* 151 */,\n/* 152 */,\n/* 153 */,\n/* 154 */,\n/* 155 */,\n/* 156 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Handler\n\t * @module zrender/Handler\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (shenyi.914@gmail.com)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(1);\n\t    var Draggable = __webpack_require__(191);\n\t\n\t    var Eventful = __webpack_require__(28);\n\t\n\t    function makeEventPacket(eveType, target, event) {\n\t        return {\n\t            type: eveType,\n\t            event: event,\n\t            target: target,\n\t            cancelBubble: false,\n\t            offsetX: event.zrX,\n\t            offsetY: event.zrY,\n\t            gestureEvent: event.gestureEvent,\n\t            pinchX: event.pinchX,\n\t            pinchY: event.pinchY,\n\t            pinchScale: event.pinchScale,\n\t            wheelDelta: event.zrDelta,\n\t            zrByTouch: event.zrByTouch\n\t        };\n\t    }\n\t\n\t    function EmptyProxy () {}\n\t    EmptyProxy.prototype.dispose = function () {};\n\t\n\t    var handlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n\t    ];\n\t    /**\n\t     * @alias module:zrender/Handler\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Eventful\n\t     * @param {module:zrender/Storage} storage Storage instance.\n\t     * @param {module:zrender/Painter} painter Painter instance.\n\t     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n\t     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n\t     */\n\t    var Handler = function(storage, painter, proxy, painterRoot) {\n\t        Eventful.call(this);\n\t\n\t        this.storage = storage;\n\t\n\t        this.painter = painter;\n\t\n\t        this.painterRoot = painterRoot;\n\t\n\t        proxy = proxy || new EmptyProxy();\n\t\n\t        /**\n\t         * Proxy of event. can be Dom, WebGLSurface, etc.\n\t         */\n\t        this.proxy = proxy;\n\t\n\t        // Attach handler\n\t        proxy.handler = this;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._hovered;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Date}\n\t         */\n\t        this._lastTouchMoment;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastX;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastY;\n\t\n\t\n\t        Draggable.call(this);\n\t\n\t        util.each(handlerNames, function (name) {\n\t            proxy.on && proxy.on(name, this[name], this);\n\t        }, this);\n\t    };\n\t\n\t    Handler.prototype = {\n\t\n\t        constructor: Handler,\n\t\n\t        mousemove: function (event) {\n\t            var x = event.zrX;\n\t            var y = event.zrY;\n\t\n\t            var hovered = this.findHover(x, y, null);\n\t            var lastHovered = this._hovered;\n\t            var proxy = this.proxy;\n\t\n\t            this._hovered = hovered;\n\t\n\t            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\t\n\t            // Mouse out on previous hovered element\n\t            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n\t                this.dispatchToElement(lastHovered, 'mouseout', event);\n\t            }\n\t\n\t            // Mouse moving on one element\n\t            this.dispatchToElement(hovered, 'mousemove', event);\n\t\n\t            // Mouse over on a new element\n\t            if (hovered && hovered !== lastHovered) {\n\t                this.dispatchToElement(hovered, 'mouseover', event);\n\t            }\n\t        },\n\t\n\t        mouseout: function (event) {\n\t            this.dispatchToElement(this._hovered, 'mouseout', event);\n\t\n\t            // There might be some doms created by upper layer application\n\t            // at the same level of painter.getViewportRoot() (e.g., tooltip\n\t            // dom created by echarts), where 'globalout' event should not\n\t            // be triggered when mouse enters these doms. (But 'mouseout'\n\t            // should be triggered at the original hovered element as usual).\n\t            var element = event.toElement || event.relatedTarget;\n\t            var innerDom;\n\t            do {\n\t                element = element && element.parentNode;\n\t            }\n\t            while (element && element.nodeType != 9 && !(\n\t                innerDom = element === this.painterRoot\n\t            ));\n\t\n\t            !innerDom && this.trigger('globalout', {event: event});\n\t        },\n\t\n\t        /**\n\t         * Resize\n\t         */\n\t        resize: function (event) {\n\t            this._hovered = null;\n\t        },\n\t\n\t        /**\n\t         * Dispatch event\n\t         * @param {string} eventName\n\t         * @param {event=} eventArgs\n\t         */\n\t        dispatch: function (eventName, eventArgs) {\n\t            var handler = this[eventName];\n\t            handler && handler.call(this, eventArgs);\n\t        },\n\t\n\t        /**\n\t         * Dispose\n\t         */\n\t        dispose: function () {\n\t\n\t            this.proxy.dispose();\n\t\n\t            this.storage =\n\t            this.proxy =\n\t            this.painter = null;\n\t        },\n\t\n\t        /**\n\t         * 设置默认的cursor style\n\t         * @param {string} [cursorStyle='default'] 例如 crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            var proxy = this.proxy;\n\t            proxy.setCursor && proxy.setCursor(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * 事件分发代理\n\t         *\n\t         * @private\n\t         * @param {Object} targetEl 目标图形元素\n\t         * @param {string} eventName 事件名称\n\t         * @param {Object} event 事件对象\n\t         */\n\t        dispatchToElement: function (targetEl, eventName, event) {\n\t            var eventHandler = 'on' + eventName;\n\t            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\t\n\t            var el = targetEl;\n\t\n\t            while (el) {\n\t                el[eventHandler]\n\t                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t\n\t                el.trigger(eventName, eventPacket);\n\t\n\t                el = el.parent;\n\t\n\t                if (eventPacket.cancelBubble) {\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (!eventPacket.cancelBubble) {\n\t                // 冒泡到顶级 zrender 对象\n\t                this.trigger(eventName, eventPacket);\n\t                // 分发事件到用户自定义层\n\t                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\t                this.painter && this.painter.eachOtherLayer(function (layer) {\n\t                    if (typeof(layer[eventHandler]) == 'function') {\n\t                        layer[eventHandler].call(layer, eventPacket);\n\t                    }\n\t                    if (layer.trigger) {\n\t                        layer.trigger(eventName, eventPacket);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {module:zrender/graphic/Displayable} exclude\n\t         * @method\n\t         */\n\t        findHover: function(x, y, exclude) {\n\t            var list = this.storage.getDisplayList();\n\t            for (var i = list.length - 1; i >= 0 ; i--) {\n\t                if (!list[i].silent\n\t                 && list[i] !== exclude\n\t                 // getDisplayList may include ignored item in VML mode\n\t                 && !list[i].ignore\n\t                 && isHover(list[i], x, y)) {\n\t                    return list[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t        Handler.prototype[name] = function (event) {\n\t            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t            var hovered = this.findHover(event.zrX, event.zrY, null);\n\t\n\t            if (name === 'mousedown') {\n\t                this._downel = hovered;\n\t                // In case click triggered before mouseup\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'mosueup') {\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'click') {\n\t                if (this._downel !== this._upel) {\n\t                    return;\n\t                }\n\t            }\n\t\n\t            this.dispatchToElement(hovered, name, event);\n\t        };\n\t    });\n\t\n\t    function isHover(displayable, x, y) {\n\t        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t            var el = displayable;\n\t            while (el) {\n\t                // If ancestor is silent or clipped by ancestor\n\t                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n\t                    return false;\n\t                }\n\t                el = el.parent;\n\t            }\n\t            return true;\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    util.mixin(Handler, Eventful);\n\t    util.mixin(Handler, Draggable);\n\t\n\t    module.exports = Handler;\n\n\n/***/ },\n/* 157 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/Layer\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(1);\n\t    var config = __webpack_require__(39);\n\t    var Style = __webpack_require__(81);\n\t    var Pattern = __webpack_require__(80);\n\t\n\t    function returnFalse() {\n\t        return false;\n\t    }\n\t\n\t    /**\n\t     * 创建dom\n\t     *\n\t     * @inner\n\t     * @param {string} id dom id 待用\n\t     * @param {string} type dom type，such as canvas, div etc.\n\t     * @param {Painter} painter painter instance\n\t     * @param {number} number\n\t     */\n\t    function createDom(id, type, painter, dpr) {\n\t        var newDom = document.createElement(type);\n\t        var width = painter.getWidth();\n\t        var height = painter.getHeight();\n\t\n\t        var newDomStyle = newDom.style;\n\t        // 没append呢，请原谅我这样写，清晰~\n\t        newDomStyle.position = 'absolute';\n\t        newDomStyle.left = 0;\n\t        newDomStyle.top = 0;\n\t        newDomStyle.width = width + 'px';\n\t        newDomStyle.height = height + 'px';\n\t        newDom.width = width * dpr;\n\t        newDom.height = height * dpr;\n\t\n\t        // id不作为索引用，避免可能造成的重名，定义为私有属性\n\t        newDom.setAttribute('data-zr-dom-id', id);\n\t        return newDom;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Layer\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @param {string} id\n\t     * @param {module:zrender/Painter} painter\n\t     * @param {number} [dpr]\n\t     */\n\t    var Layer = function(id, painter, dpr) {\n\t        var dom;\n\t        dpr = dpr || config.devicePixelRatio;\n\t        if (typeof id === 'string') {\n\t            dom = createDom(id, 'canvas', painter, dpr);\n\t        }\n\t        // Not using isDom because in node it will return false\n\t        else if (util.isObject(id)) {\n\t            dom = id;\n\t            id = dom.id;\n\t        }\n\t        this.id = id;\n\t        this.dom = dom;\n\t\n\t        var domStyle = dom.style;\n\t        if (domStyle) { // Not in node\n\t            dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t            domStyle['-webkit-user-select'] = 'none';\n\t            domStyle['user-select'] = 'none';\n\t            domStyle['-webkit-touch-callout'] = 'none';\n\t            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t            domStyle['padding'] = 0;\n\t            domStyle['margin'] = 0;\n\t            domStyle['border-width'] = 0;\n\t        }\n\t\n\t        this.domBack = null;\n\t        this.ctxBack = null;\n\t\n\t        this.painter = painter;\n\t\n\t        this.config = null;\n\t\n\t        // Configs\n\t        /**\n\t         * 每次清空画布的颜色\n\t         * @type {string}\n\t         * @default 0\n\t         */\n\t        this.clearColor = 0;\n\t        /**\n\t         * 是否开启动态模糊\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        this.motionBlur = false;\n\t        /**\n\t         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t         * @type {number}\n\t         * @default 0.7\n\t         */\n\t        this.lastFrameAlpha = 0.7;\n\t\n\t        /**\n\t         * Layer dpr\n\t         * @type {number}\n\t         */\n\t        this.dpr = dpr;\n\t    };\n\t\n\t    Layer.prototype = {\n\t\n\t        constructor: Layer,\n\t\n\t        elCount: 0,\n\t\n\t        __dirty: true,\n\t\n\t        initContext: function () {\n\t            this.ctx = this.dom.getContext('2d');\n\t\n\t            this.ctx.dpr = this.dpr;\n\t        },\n\t\n\t        createBackBuffer: function () {\n\t            var dpr = this.dpr;\n\t\n\t            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n\t            this.ctxBack = this.domBack.getContext('2d');\n\t\n\t            if (dpr != 1) {\n\t                this.ctxBack.scale(dpr, dpr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param  {number} width\n\t         * @param  {number} height\n\t         */\n\t        resize: function (width, height) {\n\t            var dpr = this.dpr;\n\t\n\t            var dom = this.dom;\n\t            var domStyle = dom.style;\n\t            var domBack = this.domBack;\n\t\n\t            domStyle.width = width + 'px';\n\t            domStyle.height = height + 'px';\n\t\n\t            dom.width = width * dpr;\n\t            dom.height = height * dpr;\n\t\n\t            if (domBack) {\n\t                domBack.width = width * dpr;\n\t                domBack.height = height * dpr;\n\t\n\t                if (dpr != 1) {\n\t                    this.ctxBack.scale(dpr, dpr);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 清空该层画布\n\t         * @param {boolean} clearAll Clear all with out motion blur\n\t         */\n\t        clear: function (clearAll) {\n\t            var dom = this.dom;\n\t            var ctx = this.ctx;\n\t            var width = dom.width;\n\t            var height = dom.height;\n\t\n\t            var clearColor = this.clearColor;\n\t            var haveMotionBLur = this.motionBlur && !clearAll;\n\t            var lastFrameAlpha = this.lastFrameAlpha;\n\t\n\t            var dpr = this.dpr;\n\t\n\t            if (haveMotionBLur) {\n\t                if (!this.domBack) {\n\t                    this.createBackBuffer();\n\t                }\n\t\n\t                this.ctxBack.globalCompositeOperation = 'copy';\n\t                this.ctxBack.drawImage(\n\t                    dom, 0, 0,\n\t                    width / dpr,\n\t                    height / dpr\n\t                );\n\t            }\n\t\n\t            ctx.clearRect(0, 0, width, height);\n\t            if (clearColor) {\n\t                var clearColorGradientOrPattern;\n\t                // Gradient\n\t                if (clearColor.colorStops) {\n\t                    // Cache canvas gradient\n\t                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t                        x: 0,\n\t                        y: 0,\n\t                        width: width,\n\t                        height: height\n\t                    });\n\t\n\t                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t                }\n\t                // Pattern\n\t                else if (clearColor.image) {\n\t                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t                }\n\t                ctx.save();\n\t                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t                ctx.fillRect(0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t\n\t            if (haveMotionBLur) {\n\t                var domBack = this.domBack;\n\t                ctx.save();\n\t                ctx.globalAlpha = lastFrameAlpha;\n\t                ctx.drawImage(domBack, 0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Layer;\n\n\n/***/ },\n/* 158 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Default canvas painter\n\t * @module zrender/Painter\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t \n\t\n\t    var config = __webpack_require__(39);\n\t    var util = __webpack_require__(1);\n\t    var log = __webpack_require__(78);\n\t    var BoundingRect = __webpack_require__(13);\n\t    var timsort = __webpack_require__(53);\n\t\n\t    var Layer = __webpack_require__(157);\n\t\n\t    var requestAnimationFrame = __webpack_require__(75);\n\t\n\t    // PENDIGN\n\t    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t    //\n\t    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\t    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    function isLayerValid(layer) {\n\t        if (!layer) {\n\t            return false;\n\t        }\n\t\n\t        if (layer.isBuildin) {\n\t            return true;\n\t        }\n\t\n\t        if (typeof(layer.resize) !== 'function'\n\t            || typeof(layer.refresh) !== 'function'\n\t        ) {\n\t            return false;\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    function preProcessLayer(layer) {\n\t        layer.__unusedCount++;\n\t    }\n\t\n\t    function postProcessLayer(layer) {\n\t        if (layer.__unusedCount == 1) {\n\t            layer.clear();\n\t        }\n\t    }\n\t\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var viewRect = new BoundingRect(0, 0, 0, 0);\n\t    function isDisplayableCulled(el, width, height) {\n\t        tmpRect.copy(el.getBoundingRect());\n\t        if (el.transform) {\n\t            tmpRect.applyTransform(el.transform);\n\t        }\n\t        viewRect.width = width;\n\t        viewRect.height = height;\n\t        return !tmpRect.intersect(viewRect);\n\t    }\n\t\n\t    function isClipPathChanged(clipPaths, prevClipPaths) {\n\t        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n\t            return false;\n\t        }\n\t\n\t        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n\t            return true;\n\t        }\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            if (clipPaths[i] !== prevClipPaths[i]) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t\n\t    function doClip(clipPaths, ctx) {\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            var clipPath = clipPaths[i];\n\t            var path = clipPath.path;\n\t\n\t            clipPath.setTransform(ctx);\n\t            path.beginPath(ctx);\n\t            clipPath.buildPath(path, clipPath.shape);\n\t            ctx.clip();\n\t            // Transform back\n\t            clipPath.restoreTransform(ctx);\n\t        }\n\t    }\n\t\n\t    function createRoot(width, height) {\n\t        var domRoot = document.createElement('div');\n\t\n\t        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t        domRoot.style.cssText = [\n\t            'position:relative',\n\t            'overflow:hidden',\n\t            'width:' + width + 'px',\n\t            'height:' + height + 'px',\n\t            'padding:0',\n\t            'margin:0',\n\t            'border-width:0'\n\t        ].join(';') + ';';\n\t\n\t        return domRoot;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Painter\n\t     * @constructor\n\t     * @param {HTMLElement} root 绘图容器\n\t     * @param {module:zrender/Storage} storage\n\t     * @param {Ojbect} opts\n\t     */\n\t    var Painter = function (root, storage, opts) {\n\t        // In node environment using node-canvas\n\t        var singleCanvas = !root.nodeName // In node ?\n\t            || root.nodeName.toUpperCase() === 'CANVAS';\n\t\n\t        this._opts = opts = util.extend({}, opts || {});\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._singleCanvas = singleCanvas;\n\t        /**\n\t         * 绘图容器\n\t         * @type {HTMLElement}\n\t         */\n\t        this.root = root;\n\t\n\t        var rootStyle = root.style;\n\t\n\t        if (rootStyle) {\n\t            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t            rootStyle['-webkit-user-select'] =\n\t            rootStyle['user-select'] =\n\t            rootStyle['-webkit-touch-callout'] = 'none';\n\t\n\t            root.innerHTML = '';\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/Storage}\n\t         */\n\t        this.storage = storage;\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        var zlevelList = this._zlevelList = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:zrender/Layer>}\n\t         * @private\n\t         */\n\t        var layers = this._layers = {};\n\t\n\t        /**\n\t         * @type {Object.<string, Object>}\n\t         * @type {private}\n\t         */\n\t        this._layerConfig = {};\n\t\n\t        if (!singleCanvas) {\n\t            this._width = this._getSize(0);\n\t            this._height = this._getSize(1);\n\t\n\t            var domRoot = this._domRoot = createRoot(\n\t                this._width, this._height\n\t            );\n\t            root.appendChild(domRoot);\n\t        }\n\t        else {\n\t            // Use canvas width and height directly\n\t            var width = root.width;\n\t            var height = root.height;\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            // Create layer if only one given canvas\n\t            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t            var mainLayer = new Layer(root, this, 1);\n\t            mainLayer.initContext();\n\t            // FIXME Use canvas width and height\n\t            // mainLayer.resize(width, height);\n\t            layers[0] = mainLayer;\n\t            zlevelList.push(0);\n\t        }\n\t\n\t        this.pathToImage = this._createPathToImage();\n\t\n\t        // Layers for progressive rendering\n\t        this._progressiveLayers = [];\n\t\n\t        /**\n\t         * @type {module:zrender/Layer}\n\t         * @private\n\t         */\n\t        this._hoverlayer;\n\t\n\t        this._hoverElements = [];\n\t    };\n\t\n\t    Painter.prototype = {\n\t\n\t        constructor: Painter,\n\t\n\t        /**\n\t         * If painter use a single canvas\n\t         * @return {boolean}\n\t         */\n\t        isSingleCanvas: function () {\n\t            return this._singleCanvas;\n\t        },\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n\t        },\n\t\n\t        /**\n\t         * 刷新\n\t         * @param {boolean} [paintAll=false] 强制绘制所有displayable\n\t         */\n\t        refresh: function (paintAll) {\n\t\n\t            var list = this.storage.getDisplayList(true);\n\t\n\t            var zlevelList = this._zlevelList;\n\t\n\t            this._paintList(list, paintAll);\n\t\n\t            // Paint custum layers\n\t            for (var i = 0; i < zlevelList.length; i++) {\n\t                var z = zlevelList[i];\n\t                var layer = this._layers[z];\n\t                if (!layer.isBuildin && layer.refresh) {\n\t                    layer.refresh();\n\t                }\n\t            }\n\t\n\t            this.refreshHover();\n\t\n\t            if (this._progressiveLayers.length) {\n\t                this._startProgessive();\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        addHover: function (el, hoverStyle) {\n\t            if (el.__hoverMir) {\n\t                return;\n\t            }\n\t            var elMirror = new el.constructor({\n\t                style: el.style,\n\t                shape: el.shape\n\t            });\n\t            elMirror.__from = el;\n\t            el.__hoverMir = elMirror;\n\t            elMirror.setStyle(hoverStyle);\n\t            this._hoverElements.push(elMirror);\n\t        },\n\t\n\t        removeHover: function (el) {\n\t            var elMirror = el.__hoverMir;\n\t            var hoverElements = this._hoverElements;\n\t            var idx = util.indexOf(hoverElements, elMirror);\n\t            if (idx >= 0) {\n\t                hoverElements.splice(idx, 1);\n\t            }\n\t            el.__hoverMir = null;\n\t        },\n\t\n\t        clearHover: function (el) {\n\t            var hoverElements = this._hoverElements;\n\t            for (var i = 0; i < hoverElements.length; i++) {\n\t                var from = hoverElements[i].__from;\n\t                if (from) {\n\t                    from.__hoverMir = null;\n\t                }\n\t            }\n\t            hoverElements.length = 0;\n\t        },\n\t\n\t        refreshHover: function () {\n\t            var hoverElements = this._hoverElements;\n\t            var len = hoverElements.length;\n\t            var hoverLayer = this._hoverlayer;\n\t            hoverLayer && hoverLayer.clear();\n\t\n\t            if (!len) {\n\t                return;\n\t            }\n\t            timsort(hoverElements, this.storage.displayableSortFunc);\n\t\n\t            // Use a extream large zlevel\n\t            // FIXME?\n\t            if (!hoverLayer) {\n\t                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n\t            }\n\t\n\t            var scope = {};\n\t            hoverLayer.ctx.save();\n\t            for (var i = 0; i < len;) {\n\t                var el = hoverElements[i];\n\t                var originalEl = el.__from;\n\t                // Original el is removed\n\t                // PENDING\n\t                if (!(originalEl && originalEl.__zr)) {\n\t                    hoverElements.splice(i, 1);\n\t                    originalEl.__hoverMir = null;\n\t                    len--;\n\t                    continue;\n\t                }\n\t                i++;\n\t\n\t                // Use transform\n\t                // FIXME style and shape ?\n\t                if (!originalEl.invisible) {\n\t                    el.transform = originalEl.transform;\n\t                    el.invTransform = originalEl.invTransform;\n\t                    el.__clipPaths = originalEl.__clipPaths;\n\t                    // el.\n\t                    this._doPaintEl(el, hoverLayer, true, scope);\n\t                }\n\t            }\n\t            hoverLayer.ctx.restore();\n\t        },\n\t\n\t        _startProgessive: function () {\n\t            var self = this;\n\t\n\t            if (!self._furtherProgressive) {\n\t                return;\n\t            }\n\t\n\t            // Use a token to stop progress steps triggered by\n\t            // previous zr.refresh calling.\n\t            var token = self._progressiveToken = +new Date();\n\t\n\t            self._progress++;\n\t            requestAnimationFrame(step);\n\t\n\t            function step() {\n\t                // In case refreshed or disposed\n\t                if (token === self._progressiveToken && self.storage) {\n\t\n\t                    self._doPaintList(self.storage.getDisplayList());\n\t\n\t                    if (self._furtherProgressive) {\n\t                        self._progress++;\n\t                        requestAnimationFrame(step);\n\t                    }\n\t                    else {\n\t                        self._progressiveToken = -1;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _clearProgressive: function () {\n\t            this._progressiveToken = -1;\n\t            this._progress = 0;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                layer.__dirty && layer.clear();\n\t            });\n\t        },\n\t\n\t        _paintList: function (list, paintAll) {\n\t\n\t            if (paintAll == null) {\n\t                paintAll = false;\n\t            }\n\t\n\t            this._updateLayerStatus(list);\n\t\n\t            this._clearProgressive();\n\t\n\t            this.eachBuildinLayer(preProcessLayer);\n\t\n\t            this._doPaintList(list, paintAll);\n\t\n\t            this.eachBuildinLayer(postProcessLayer);\n\t        },\n\t\n\t        _doPaintList: function (list, paintAll) {\n\t            var currentLayer;\n\t            var currentZLevel;\n\t            var ctx;\n\t\n\t            // var invTransform = [];\n\t            var scope;\n\t\n\t            var progressiveLayerIdx = 0;\n\t            var currentProgressiveLayer;\n\t\n\t            var width = this._width;\n\t            var height = this._height;\n\t            var layerProgress;\n\t            var frame = this._progress;\n\t            function flushProgressiveLayer(layer) {\n\t                var dpr = ctx.dpr || 1;\n\t                ctx.save();\n\t                ctx.globalAlpha = 1;\n\t                ctx.shadowBlur = 0;\n\t                // Avoid layer don't clear in next progressive frame\n\t                currentLayer.__dirty = true;\n\t                ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t                ctx.restore();\n\t            }\n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t\n\t                var elFrame = el.__frame;\n\t\n\t                // Flush at current context\n\t                // PENDING\n\t                if (elFrame < 0 && currentProgressiveLayer) {\n\t                    flushProgressiveLayer(currentProgressiveLayer);\n\t                    currentProgressiveLayer = null;\n\t                }\n\t\n\t                // Change draw layer\n\t                if (currentZLevel !== elZLevel) {\n\t                    if (ctx) {\n\t                        ctx.restore();\n\t                    }\n\t\n\t                    // Reset scope\n\t                    scope = {};\n\t\n\t                    // Only 0 zlevel if only has one canvas\n\t                    currentZLevel = elZLevel;\n\t                    currentLayer = this.getLayer(currentZLevel);\n\t\n\t                    if (!currentLayer.isBuildin) {\n\t                        log(\n\t                            'ZLevel ' + currentZLevel\n\t                            + ' has been used by unkown layer ' + currentLayer.id\n\t                        );\n\t                    }\n\t\n\t                    ctx = currentLayer.ctx;\n\t                    ctx.save();\n\t\n\t                    // Reset the count\n\t                    currentLayer.__unusedCount = 0;\n\t\n\t                    if (currentLayer.__dirty || paintAll) {\n\t                        currentLayer.clear();\n\t                    }\n\t                }\n\t\n\t                if (!(currentLayer.__dirty || paintAll)) {\n\t                    continue;\n\t                }\n\t\n\t                if (elFrame >= 0) {\n\t                    // Progressive layer changed\n\t                    if (!currentProgressiveLayer) {\n\t                        currentProgressiveLayer = this._progressiveLayers[\n\t                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n\t                        ];\n\t\n\t                        currentProgressiveLayer.ctx.save();\n\t                        currentProgressiveLayer.renderScope = {};\n\t\n\t                        if (currentProgressiveLayer\n\t                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n\t                        ) {\n\t                            // flushProgressiveLayer(currentProgressiveLayer);\n\t                            // Quick jump all progressive elements\n\t                            // All progressive element are not dirty, jump over and flush directly\n\t                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n\t                            // currentProgressiveLayer = null;\n\t                            continue;\n\t                        }\n\t\n\t                        layerProgress = currentProgressiveLayer.__progress;\n\t\n\t                        if (!currentProgressiveLayer.__dirty) {\n\t                            // Keep rendering\n\t                            frame = layerProgress;\n\t                        }\n\t\n\t                        currentProgressiveLayer.__progress = frame + 1;\n\t                    }\n\t\n\t                    if (elFrame === frame) {\n\t                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t                    }\n\t                }\n\t                else {\n\t                    this._doPaintEl(el, currentLayer, paintAll, scope);\n\t                }\n\t\n\t                el.__dirty = false;\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                flushProgressiveLayer(currentProgressiveLayer);\n\t            }\n\t\n\t            // Restore the lastLayer ctx\n\t            ctx && ctx.restore();\n\t            // If still has clipping state\n\t            // if (scope.prevElClipPaths) {\n\t            //     ctx.restore();\n\t            // }\n\t\n\t            this._furtherProgressive = false;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                if (layer.__maxProgress >= layer.__progress) {\n\t                    this._furtherProgressive = true;\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t            var ctx = currentLayer.ctx;\n\t            var m = el.transform;\n\t            if (\n\t                (currentLayer.__dirty || forcePaint)\n\t                // Ignore invisible element\n\t                && !el.invisible\n\t                // Ignore transparent element\n\t                && el.style.opacity !== 0\n\t                // Ignore scale 0 element, in some environment like node-canvas\n\t                // Draw a scale 0 element can cause all following draw wrong\n\t                // And setTransform with scale 0 will cause set back transform failed.\n\t                && !(m && !m[0] && !m[3])\n\t                // Ignore culled element\n\t                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n\t            ) {\n\t\n\t                var clipPaths = el.__clipPaths;\n\t\n\t                // Optimize when clipping on group with several elements\n\t                if (scope.prevClipLayer !== currentLayer\n\t                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n\t                ) {\n\t                    // If has previous clipping state, restore from it\n\t                    if (scope.prevElClipPaths) {\n\t                        scope.prevClipLayer.ctx.restore();\n\t                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\t\n\t                        // Reset prevEl since context has been restored\n\t                        scope.prevEl = null;\n\t                    }\n\t                    // New clipping state\n\t                    if (clipPaths) {\n\t                        ctx.save();\n\t                        doClip(clipPaths, ctx);\n\t                        scope.prevClipLayer = currentLayer;\n\t                        scope.prevElClipPaths = clipPaths;\n\t                    }\n\t                }\n\t                el.beforeBrush && el.beforeBrush(ctx);\n\t\n\t                el.brush(ctx, scope.prevEl || null);\n\t                scope.prevEl = el;\n\t\n\t                el.afterBrush && el.afterBrush(ctx);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n\t         * @param {number} zlevel\n\t         * @return {module:zrender/Layer}\n\t         */\n\t        getLayer: function (zlevel) {\n\t            if (this._singleCanvas) {\n\t                return this._layers[0];\n\t            }\n\t\n\t            var layer = this._layers[zlevel];\n\t            if (!layer) {\n\t                // Create a new layer\n\t                layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t                layer.isBuildin = true;\n\t\n\t                if (this._layerConfig[zlevel]) {\n\t                    util.merge(layer, this._layerConfig[zlevel], true);\n\t                }\n\t\n\t                this.insertLayer(zlevel, layer);\n\t\n\t                // Context is created after dom inserted to document\n\t                // Or excanvas will get 0px clientWidth and clientHeight\n\t                layer.initContext();\n\t            }\n\t\n\t            return layer;\n\t        },\n\t\n\t        insertLayer: function (zlevel, layer) {\n\t\n\t            var layersMap = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var len = zlevelList.length;\n\t            var prevLayer = null;\n\t            var i = -1;\n\t            var domRoot = this._domRoot;\n\t\n\t            if (layersMap[zlevel]) {\n\t                log('ZLevel ' + zlevel + ' has been used already');\n\t                return;\n\t            }\n\t            // Check if is a valid layer\n\t            if (!isLayerValid(layer)) {\n\t                log('Layer of zlevel ' + zlevel + ' is not valid');\n\t                return;\n\t            }\n\t\n\t            if (len > 0 && zlevel > zlevelList[0]) {\n\t                for (i = 0; i < len - 1; i++) {\n\t                    if (\n\t                        zlevelList[i] < zlevel\n\t                        && zlevelList[i + 1] > zlevel\n\t                    ) {\n\t                        break;\n\t                    }\n\t                }\n\t                prevLayer = layersMap[zlevelList[i]];\n\t            }\n\t            zlevelList.splice(i + 1, 0, zlevel);\n\t\n\t            if (prevLayer) {\n\t                var prevDom = prevLayer.dom;\n\t                if (prevDom.nextSibling) {\n\t                    domRoot.insertBefore(\n\t                        layer.dom,\n\t                        prevDom.nextSibling\n\t                    );\n\t                }\n\t                else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t            else {\n\t                if (domRoot.firstChild) {\n\t                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t                }\n\t                else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t\n\t            layersMap[zlevel] = layer;\n\t        },\n\t\n\t        // Iterate each layer\n\t        eachLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                cb.call(context, this._layers[z], z);\n\t            }\n\t        },\n\t\n\t        // Iterate each buildin layer\n\t        eachBuildinLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        // Iterate each other layer except buildin layer\n\t        eachOtherLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (! layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 获取所有已创建的层\n\t         * @param {Array.<module:zrender/Layer>} [prevLayer]\n\t         */\n\t        getLayers: function () {\n\t            return this._layers;\n\t        },\n\t\n\t        _updateLayerStatus: function (list) {\n\t\n\t            var layers = this._layers;\n\t            var progressiveLayers = this._progressiveLayers;\n\t\n\t            var elCountsLastFrame = {};\n\t            var progressiveElCountsLastFrame = {};\n\t\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                elCountsLastFrame[z] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                progressiveElCountsLastFrame[idx] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            var progressiveLayerCount = 0;\n\t            var currentProgressiveLayer;\n\t            var lastProgressiveKey;\n\t            var frameCount = 0;\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var layer = layers[zlevel];\n\t                var elProgress = el.progressive;\n\t                if (layer) {\n\t                    layer.elCount++;\n\t                    layer.__dirty = layer.__dirty || el.__dirty;\n\t                }\n\t\n\t                /////// Update progressive\n\t                if (elProgress >= 0) {\n\t                    // Fix wrong progressive sequence problem.\n\t                    if (lastProgressiveKey !== elProgress) {\n\t                        lastProgressiveKey = elProgress;\n\t                        frameCount++;\n\t                    }\n\t                    var elFrame = el.__frame = frameCount - 1;\n\t                    if (!currentProgressiveLayer) {\n\t                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t                        currentProgressiveLayer = progressiveLayers[idx];\n\t                        if (!currentProgressiveLayer) {\n\t                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n\t                                'progressive', this, this.dpr\n\t                            );\n\t                            currentProgressiveLayer.initContext();\n\t                        }\n\t                        currentProgressiveLayer.__maxProgress = 0;\n\t                    }\n\t                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t                    currentProgressiveLayer.elCount++;\n\t\n\t                    currentProgressiveLayer.__maxProgress = Math.max(\n\t                        currentProgressiveLayer.__maxProgress, elFrame\n\t                    );\n\t\n\t                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t                        // Should keep rendering this  layer because progressive rendering is not finished yet\n\t                        layer.__dirty = true;\n\t                    }\n\t                }\n\t                else {\n\t                    el.__frame = -1;\n\t\n\t                    if (currentProgressiveLayer) {\n\t                        currentProgressiveLayer.__nextIdxNotProg = i;\n\t                        progressiveLayerCount++;\n\t                        currentProgressiveLayer = null;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                progressiveLayerCount++;\n\t                currentProgressiveLayer.__nextIdxNotProg = i;\n\t            }\n\t\n\t            // 层中的元素数量有发生变化\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                if (elCountsLastFrame[z] !== layer.elCount) {\n\t                    layer.__dirty = true;\n\t                }\n\t            });\n\t\n\t            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t                    el.__dirty = true;\n\t                }\n\t                if (layer.__dirty) {\n\t                    layer.__progress = 0;\n\t                }\n\t            });\n\t        },\n\t\n\t        /**\n\t         * 清除hover层外所有内容\n\t         */\n\t        clear: function () {\n\t            this.eachBuildinLayer(this._clearLayer);\n\t            return this;\n\t        },\n\t\n\t        _clearLayer: function (layer) {\n\t            layer.clear();\n\t        },\n\t\n\t        /**\n\t         * 修改指定zlevel的绘制参数\n\t         *\n\t         * @param {string} zlevel\n\t         * @param {Object} config 配置对象\n\t         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n\t         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n\t         * @param {number} [config.lastFrameAlpha=0.7]\n\t         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t         */\n\t        configLayer: function (zlevel, config) {\n\t            if (config) {\n\t                var layerConfig = this._layerConfig;\n\t                if (!layerConfig[zlevel]) {\n\t                    layerConfig[zlevel] = config;\n\t                }\n\t                else {\n\t                    util.merge(layerConfig[zlevel], config, true);\n\t                }\n\t\n\t                var layer = this._layers[zlevel];\n\t\n\t                if (layer) {\n\t                    util.merge(layer, layerConfig[zlevel], true);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 删除指定层\n\t         * @param {number} zlevel 层所在的zlevel\n\t         */\n\t        delLayer: function (zlevel) {\n\t            var layers = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var layer = layers[zlevel];\n\t            if (!layer) {\n\t                return;\n\t            }\n\t            layer.dom.parentNode.removeChild(layer.dom);\n\t            delete layers[zlevel];\n\t\n\t            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t        },\n\t\n\t        /**\n\t         * 区域大小变化后重绘\n\t         */\n\t        resize: function (width, height) {\n\t            var domRoot = this._domRoot;\n\t            // FIXME Why ?\n\t            domRoot.style.display = 'none';\n\t\n\t            // Save input w/h\n\t            var opts = this._opts;\n\t            width != null && (opts.width = width);\n\t            height != null && (opts.height = height);\n\t\n\t            width = this._getSize(0);\n\t            height = this._getSize(1);\n\t\n\t            domRoot.style.display = '';\n\t\n\t            // 优化没有实际改变的resize\n\t            if (this._width != width || height != this._height) {\n\t                domRoot.style.width = width + 'px';\n\t                domRoot.style.height = height + 'px';\n\t\n\t                for (var id in this._layers) {\n\t                    if (this._layers.hasOwnProperty(id)) {\n\t                        this._layers[id].resize(width, height);\n\t                    }\n\t                }\n\t                util.each(this._progressiveLayers, function (layer) {\n\t                    layer.resize(width, height);\n\t                });\n\t\n\t                this.refresh(true);\n\t            }\n\t\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 清除单独的一个层\n\t         * @param {number} zlevel\n\t         */\n\t        clearLayer: function (zlevel) {\n\t            var layer = this._layers[zlevel];\n\t            if (layer) {\n\t                layer.clear();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 释放\n\t         */\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this.root =\n\t            this.storage =\n\t\n\t            this._domRoot =\n\t            this._layers = null;\n\t        },\n\t\n\t        /**\n\t         * Get canvas which has all thing rendered\n\t         * @param {Object} opts\n\t         * @param {string} [opts.backgroundColor]\n\t         */\n\t        getRenderedCanvas: function (opts) {\n\t            opts = opts || {};\n\t            if (this._singleCanvas) {\n\t                return this._layers[0].dom;\n\t            }\n\t\n\t            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t            imageLayer.initContext();\n\t\n\t            imageLayer.clearColor = opts.backgroundColor;\n\t            imageLayer.clear();\n\t\n\t            var displayList = this.storage.getDisplayList(true);\n\t\n\t            var scope = {};\n\t            for (var i = 0; i < displayList.length; i++) {\n\t                var el = displayList[i];\n\t                this._doPaintEl(el, imageLayer, true, scope);\n\t            }\n\t\n\t            return imageLayer.dom;\n\t        },\n\t        /**\n\t         * 获取绘图区域宽度\n\t         */\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        /**\n\t         * 获取绘图区域高度\n\t         */\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        _getSize: function (whIdx) {\n\t            var opts = this._opts;\n\t            var wh = ['width', 'height'][whIdx];\n\t            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n\t            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n\t            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\t\n\t            if (opts[wh] != null && opts[wh] !== 'auto') {\n\t                return parseFloat(opts[wh]);\n\t            }\n\t\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t\n\t            return (\n\t                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n\t                - (parseInt10(stl[plt]) || 0)\n\t                - (parseInt10(stl[prb]) || 0)\n\t            ) | 0;\n\t        },\n\t\n\t        _pathToImage: function (id, path, width, height, dpr) {\n\t            var canvas = document.createElement('canvas');\n\t            var ctx = canvas.getContext('2d');\n\t\n\t            canvas.width = width * dpr;\n\t            canvas.height = height * dpr;\n\t\n\t            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\t\n\t            var pathTransform = {\n\t                position: path.position,\n\t                rotation: path.rotation,\n\t                scale: path.scale\n\t            };\n\t            path.position = [0, 0, 0];\n\t            path.rotation = 0;\n\t            path.scale = [1, 1];\n\t            if (path) {\n\t                path.brush(ctx);\n\t            }\n\t\n\t            var ImageShape = __webpack_require__(79);\n\t            var imgShape = new ImageShape({\n\t                id: id,\n\t                style: {\n\t                    x: 0,\n\t                    y: 0,\n\t                    image: canvas\n\t                }\n\t            });\n\t\n\t            if (pathTransform.position != null) {\n\t                imgShape.position = path.position = pathTransform.position;\n\t            }\n\t\n\t            if (pathTransform.rotation != null) {\n\t                imgShape.rotation = path.rotation = pathTransform.rotation;\n\t            }\n\t\n\t            if (pathTransform.scale != null) {\n\t                imgShape.scale = path.scale = pathTransform.scale;\n\t            }\n\t\n\t            return imgShape;\n\t        },\n\t\n\t        _createPathToImage: function () {\n\t            var me = this;\n\t\n\t            return function (id, e, width, height) {\n\t                return me._pathToImage(\n\t                    id, e, width, height, me.dpr\n\t                );\n\t            };\n\t        }\n\t    };\n\t\n\t    module.exports = Painter;\n\t\n\n\n/***/ },\n/* 159 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Storage内容仓库模块\n\t * @module zrender/Storage\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t * @author errorrik (errorrik@gmail.com)\n\t * @author pissang (https://github.com/pissang/)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(1);\n\t    var env = __webpack_require__(14);\n\t\n\t    var Group = __webpack_require__(40);\n\t\n\t    // Use timsort because in most case elements are partially sorted\n\t    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n\t    var timsort = __webpack_require__(53);\n\t\n\t    function shapeCompareFunc(a, b) {\n\t        if (a.zlevel === b.zlevel) {\n\t            if (a.z === b.z) {\n\t                // if (a.z2 === b.z2) {\n\t                //     // FIXME Slow has renderidx compare\n\t                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t                //     return a.__renderidx - b.__renderidx;\n\t                // }\n\t                return a.z2 - b.z2;\n\t            }\n\t            return a.z - b.z;\n\t        }\n\t        return a.zlevel - b.zlevel;\n\t    }\n\t    /**\n\t     * 内容仓库 (M)\n\t     * @alias module:zrender/Storage\n\t     * @constructor\n\t     */\n\t    var Storage = function () {\n\t        // 所有常规形状，id索引的map\n\t        this._elements = {};\n\t\n\t        this._roots = [];\n\t\n\t        this._displayList = [];\n\t\n\t        this._displayListLen = 0;\n\t    };\n\t\n\t    Storage.prototype = {\n\t\n\t        constructor: Storage,\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         *\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._roots.length; i++) {\n\t                this._roots[i].traverse(cb, context);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 返回所有图形的绘制队列\n\t         * @param {boolean} [update=false] 是否在返回前更新该数组\n\t         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n\t         *\n\t         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n\t         * @return {Array.<module:zrender/graphic/Displayable>}\n\t         */\n\t        getDisplayList: function (update, includeIgnore) {\n\t            includeIgnore = includeIgnore || false;\n\t            if (update) {\n\t                this.updateDisplayList(includeIgnore);\n\t            }\n\t            return this._displayList;\n\t        },\n\t\n\t        /**\n\t         * 更新图形的绘制队列。\n\t         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n\t         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n\t         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n\t         */\n\t        updateDisplayList: function (includeIgnore) {\n\t            this._displayListLen = 0;\n\t            var roots = this._roots;\n\t            var displayList = this._displayList;\n\t            for (var i = 0, len = roots.length; i < len; i++) {\n\t                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t            }\n\t            displayList.length = this._displayListLen;\n\t\n\t            // for (var i = 0, len = displayList.length; i < len; i++) {\n\t            //     displayList[i].__renderidx = i;\n\t            // }\n\t\n\t            // displayList.sort(shapeCompareFunc);\n\t            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t        },\n\t\n\t        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t\n\t            if (el.ignore && !includeIgnore) {\n\t                return;\n\t            }\n\t\n\t            el.beforeUpdate();\n\t\n\t            if (el.__dirty) {\n\t\n\t                el.update();\n\t\n\t            }\n\t\n\t            el.afterUpdate();\n\t\n\t            var clipPath = el.clipPath;\n\t            if (clipPath) {\n\t                // clipPath 的变换是基于 group 的变换\n\t                clipPath.parent = el;\n\t                clipPath.updateTransform();\n\t\n\t                // FIXME 效率影响\n\t                if (clipPaths) {\n\t                    clipPaths = clipPaths.slice();\n\t                    clipPaths.push(clipPath);\n\t                }\n\t                else {\n\t                    clipPaths = [clipPath];\n\t                }\n\t            }\n\t\n\t            if (el.isGroup) {\n\t                var children = el._children;\n\t\n\t                for (var i = 0; i < children.length; i++) {\n\t                    var child = children[i];\n\t\n\t                    // Force to mark as dirty if group is dirty\n\t                    // FIXME __dirtyPath ?\n\t                    if (el.__dirty) {\n\t                        child.__dirty = true;\n\t                    }\n\t\n\t                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t                }\n\t\n\t                // Mark group clean here\n\t                el.__dirty = false;\n\t\n\t            }\n\t            else {\n\t                el.__clipPaths = clipPaths;\n\t\n\t                this._displayList[this._displayListLen++] = el;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 添加图形(Shape)或者组(Group)到根节点\n\t         * @param {module:zrender/Element} el\n\t         */\n\t        addRoot: function (el) {\n\t            // Element has been added\n\t            if (this._elements[el.id]) {\n\t                return;\n\t            }\n\t\n\t            if (el instanceof Group) {\n\t                el.addChildrenToStorage(this);\n\t            }\n\t\n\t            this.addToMap(el);\n\t            this._roots.push(el);\n\t        },\n\t\n\t        /**\n\t         * 删除指定的图形(Shape)或者组(Group)\n\t         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage\n\t         */\n\t        delRoot: function (elId) {\n\t            if (elId == null) {\n\t                // 不指定elId清空\n\t                for (var i = 0; i < this._roots.length; i++) {\n\t                    var root = this._roots[i];\n\t                    if (root instanceof Group) {\n\t                        root.delChildrenFromStorage(this);\n\t                    }\n\t                }\n\t\n\t                this._elements = {};\n\t                this._roots = [];\n\t                this._displayList = [];\n\t                this._displayListLen = 0;\n\t\n\t                return;\n\t            }\n\t\n\t            if (elId instanceof Array) {\n\t                for (var i = 0, l = elId.length; i < l; i++) {\n\t                    this.delRoot(elId[i]);\n\t                }\n\t                return;\n\t            }\n\t\n\t            var el;\n\t            if (typeof(elId) == 'string') {\n\t                el = this._elements[elId];\n\t            }\n\t            else {\n\t                el = elId;\n\t            }\n\t\n\t            var idx = util.indexOf(this._roots, el);\n\t            if (idx >= 0) {\n\t                this.delFromMap(el.id);\n\t                this._roots.splice(idx, 1);\n\t                if (el instanceof Group) {\n\t                    el.delChildrenFromStorage(this);\n\t                }\n\t            }\n\t        },\n\t\n\t        addToMap: function (el) {\n\t            if (el instanceof Group) {\n\t                el.__storage = this;\n\t            }\n\t            el.dirty(false);\n\t\n\t            this._elements[el.id] = el;\n\t\n\t            return this;\n\t        },\n\t\n\t        get: function (elId) {\n\t            return this._elements[elId];\n\t        },\n\t\n\t        delFromMap: function (elId) {\n\t            var elements = this._elements;\n\t            var el = elements[elId];\n\t            if (el) {\n\t                delete elements[elId];\n\t                if (el instanceof Group) {\n\t                    el.__storage = null;\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 清空并且释放Storage\n\t         */\n\t        dispose: function () {\n\t            this._elements =\n\t            this._renderList =\n\t            this._roots = null;\n\t        },\n\t\n\t        displayableSortFunc: shapeCompareFunc\n\t    };\n\t\n\t    module.exports = Storage;\n\t\n\n\n/***/ },\n/* 160 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 动画主类, 调度和管理所有动画控制器\n\t *\n\t * @module zrender/animation/Animation\n\t * @author pissang(https://github.com/pissang)\n\t */\n\t// TODO Additive animation\n\t// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n\t// https://developer.apple.com/videos/wwdc2014/#236\n\t\n\t\n\t    var util = __webpack_require__(1);\n\t    var Dispatcher = __webpack_require__(42).Dispatcher;\n\t\n\t    var requestAnimationFrame = __webpack_require__(75);\n\t\n\t    var Animator = __webpack_require__(74);\n\t    /**\n\t     * @typedef {Object} IZRenderStage\n\t     * @property {Function} update\n\t     */\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animation\n\t     * @constructor\n\t     * @param {Object} [options]\n\t     * @param {Function} [options.onframe]\n\t     * @param {IZRenderStage} [options.stage]\n\t     * @example\n\t     *     var animation = new Animation();\n\t     *     var obj = {\n\t     *         x: 100,\n\t     *         y: 100\n\t     *     };\n\t     *     animation.animate(node.position)\n\t     *         .when(1000, {\n\t     *             x: 500,\n\t     *             y: 500\n\t     *         })\n\t     *         .when(2000, {\n\t     *             x: 100,\n\t     *             y: 100\n\t     *         })\n\t     *         .start('spline');\n\t     */\n\t    var Animation = function (options) {\n\t\n\t        options = options || {};\n\t\n\t        this.stage = options.stage || {};\n\t\n\t        this.onframe = options.onframe || function() {};\n\t\n\t        // private properties\n\t        this._clips = [];\n\t\n\t        this._running = false;\n\t\n\t        this._time;\n\t\n\t        this._pausedTime;\n\t\n\t        this._pauseStart;\n\t\n\t        this._paused = false;\n\t\n\t        Dispatcher.call(this);\n\t    };\n\t\n\t    Animation.prototype = {\n\t\n\t        constructor: Animation,\n\t        /**\n\t         * 添加 clip\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        addClip: function (clip) {\n\t            this._clips.push(clip);\n\t        },\n\t        /**\n\t         * 添加 animator\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        addAnimator: function (animator) {\n\t            animator.animation = this;\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.addClip(clips[i]);\n\t            }\n\t        },\n\t        /**\n\t         * 删除动画片段\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        removeClip: function(clip) {\n\t            var idx = util.indexOf(this._clips, clip);\n\t            if (idx >= 0) {\n\t                this._clips.splice(idx, 1);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 删除动画片段\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        removeAnimator: function (animator) {\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.removeClip(clips[i]);\n\t            }\n\t            animator.animation = null;\n\t        },\n\t\n\t        _update: function() {\n\t\n\t            var time = new Date().getTime() - this._pausedTime;\n\t            var delta = time - this._time;\n\t            var clips = this._clips;\n\t            var len = clips.length;\n\t\n\t            var deferredEvents = [];\n\t            var deferredClips = [];\n\t            for (var i = 0; i < len; i++) {\n\t                var clip = clips[i];\n\t                var e = clip.step(time);\n\t                // Throw out the events need to be called after\n\t                // stage.update, like destroy\n\t                if (e) {\n\t                    deferredEvents.push(e);\n\t                    deferredClips.push(clip);\n\t                }\n\t            }\n\t\n\t            // Remove the finished clip\n\t            for (var i = 0; i < len;) {\n\t                if (clips[i]._needsRemove) {\n\t                    clips[i] = clips[len - 1];\n\t                    clips.pop();\n\t                    len--;\n\t                }\n\t                else {\n\t                    i++;\n\t                }\n\t            }\n\t\n\t            len = deferredEvents.length;\n\t            for (var i = 0; i < len; i++) {\n\t                deferredClips[i].fire(deferredEvents[i]);\n\t            }\n\t\n\t            this._time = time;\n\t\n\t            this.onframe(delta);\n\t\n\t            this.trigger('frame', delta);\n\t\n\t            if (this.stage.update) {\n\t                this.stage.update();\n\t            }\n\t        },\n\t\n\t        _startLoop: function () {\n\t            var self = this;\n\t\n\t            this._running = true;\n\t\n\t            function step() {\n\t                if (self._running) {\n\t\n\t                    requestAnimationFrame(step);\n\t\n\t                    !self._paused && self._update();\n\t                }\n\t            }\n\t\n\t            requestAnimationFrame(step);\n\t        },\n\t\n\t        /**\n\t         * 开始运行动画\n\t         */\n\t        start: function () {\n\t\n\t            this._time = new Date().getTime();\n\t            this._pausedTime = 0;\n\t\n\t            this._startLoop();\n\t        },\n\t        /**\n\t         * 停止运行动画\n\t         */\n\t        stop: function () {\n\t            this._running = false;\n\t        },\n\t\n\t        /**\n\t         * Pause\n\t         */\n\t        pause: function () {\n\t            if (!this._paused) {\n\t                this._pauseStart = new Date().getTime();\n\t                this._paused = true;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Resume\n\t         */\n\t        resume: function () {\n\t            if (this._paused) {\n\t                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n\t                this._paused = false;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 清除所有动画片段\n\t         */\n\t        clear: function () {\n\t            this._clips = [];\n\t        },\n\t        /**\n\t         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n\t         * @param  {Object} target\n\t         * @param  {Object} options\n\t         * @param  {boolean} [options.loop=false] 是否循环播放动画\n\t         * @param  {Function} [options.getter=null]\n\t         *         如果指定getter函数，会通过getter函数取属性值\n\t         * @param  {Function} [options.setter=null]\n\t         *         如果指定setter函数，会通过setter函数设置属性值\n\t         * @return {module:zrender/animation/Animation~Animator}\n\t         */\n\t        // TODO Gap\n\t        animate: function (target, options) {\n\t            options = options || {};\n\t            var animator = new Animator(\n\t                target,\n\t                options.loop,\n\t                options.getter,\n\t                options.setter\n\t            );\n\t\n\t            return animator;\n\t        }\n\t    };\n\t\n\t    util.mixin(Animation, Dispatcher);\n\t\n\t    module.exports = Animation;\n\t\n\n\n/***/ },\n/* 161 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 动画主控制器\n\t * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n\t * @config life(1000) 动画时长\n\t * @config delay(0) 动画延迟时间\n\t * @config loop(true)\n\t * @config gap(0) 循环的间隔时间\n\t * @config onframe\n\t * @config easing(optional)\n\t * @config ondestroy(optional)\n\t * @config onrestart(optional)\n\t *\n\t * TODO pause\n\t */\n\t\n\t\n\t    var easingFuncs = __webpack_require__(162);\n\t\n\t    function Clip(options) {\n\t\n\t        this._target = options.target;\n\t\n\t        // 生命周期\n\t        this._life = options.life || 1000;\n\t        // 延时\n\t        this._delay = options.delay || 0;\n\t        // 开始时间\n\t        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\t        this._initialized = false;\n\t\n\t        // 是否循环\n\t        this.loop = options.loop == null ? false : options.loop;\n\t\n\t        this.gap = options.gap || 0;\n\t\n\t        this.easing = options.easing || 'Linear';\n\t\n\t        this.onframe = options.onframe;\n\t        this.ondestroy = options.ondestroy;\n\t        this.onrestart = options.onrestart;\n\t    }\n\t\n\t    Clip.prototype = {\n\t\n\t        constructor: Clip,\n\t\n\t        step: function (globalTime) {\n\t            // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t            // PENDING\n\t            if (!this._initialized) {\n\t                this._startTime = globalTime + this._delay;\n\t                this._initialized = true;\n\t            }\n\t\n\t            var percent = (globalTime - this._startTime) / this._life;\n\t\n\t            // 还没开始\n\t            if (percent < 0) {\n\t                return;\n\t            }\n\t\n\t            percent = Math.min(percent, 1);\n\t\n\t            var easing = this.easing;\n\t            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t            var schedule = typeof easingFunc === 'function'\n\t                ? easingFunc(percent)\n\t                : percent;\n\t\n\t            this.fire('frame', schedule);\n\t\n\t            // 结束\n\t            if (percent == 1) {\n\t                if (this.loop) {\n\t                    this.restart (globalTime);\n\t                    // 重新开始周期\n\t                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\t                    return 'restart';\n\t                }\n\t\n\t                // 动画完成将这个控制器标识为待删除\n\t                // 在Animation.update中进行批量删除\n\t                this._needsRemove = true;\n\t                return 'destroy';\n\t            }\n\t\n\t            return null;\n\t        },\n\t\n\t        restart: function (globalTime) {\n\t            var remainder = (globalTime - this._startTime) % this._life;\n\t            this._startTime = globalTime - remainder + this.gap;\n\t\n\t            this._needsRemove = false;\n\t        },\n\t\n\t        fire: function(eventType, arg) {\n\t            eventType = 'on' + eventType;\n\t            if (this[eventType]) {\n\t                this[eventType](this._target, arg);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Clip;\n\t\n\n\n/***/ },\n/* 162 */\n/***/ function(module, exports) {\n\n\t/**\n\t * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n\t * @see http://sole.github.io/tween.js/examples/03_graphs.html\n\t * @exports zrender/animation/easing\n\t */\n\t\n\t    var easing = {\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        linear: function (k) {\n\t            return k;\n\t        },\n\t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticIn: function (k) {\n\t            return k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticOut: function (k) {\n\t            return k * (2 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k;\n\t            }\n\t            return -0.5 * (--k * (k - 2) - 1);\n\t        },\n\t\n\t        // 三次方的缓动（t^3）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicIn: function (k) {\n\t            return k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicOut: function (k) {\n\t            return --k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k + 2);\n\t        },\n\t\n\t        // 四次方的缓动（t^4）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticIn: function (k) {\n\t            return k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticOut: function (k) {\n\t            return 1 - (--k * k * k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k;\n\t            }\n\t            return -0.5 * ((k -= 2) * k * k * k - 2);\n\t        },\n\t\n\t        // 五次方的缓动（t^5）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticIn: function (k) {\n\t            return k * k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticOut: function (k) {\n\t            return --k * k * k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t        },\n\t\n\t        // 正弦曲线的缓动（sin(t)）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalIn: function (k) {\n\t            return 1 - Math.cos(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalOut: function (k) {\n\t            return Math.sin(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalInOut: function (k) {\n\t            return 0.5 * (1 - Math.cos(Math.PI * k));\n\t        },\n\t\n\t        // 指数曲线的缓动（2^t）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialIn: function (k) {\n\t            return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialOut: function (k) {\n\t            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialInOut: function (k) {\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * Math.pow(1024, k - 1);\n\t            }\n\t            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t        },\n\t\n\t        // 圆形曲线的缓动（sqrt(1-t^2)）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularIn: function (k) {\n\t            return 1 - Math.sqrt(1 - k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularOut: function (k) {\n\t            return Math.sqrt(1 - (--k * k));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t            }\n\t            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t        },\n\t\n\t        // 创建类似于弹簧在停止前来回振荡的动画\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticIn: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return -(a * Math.pow(2, 10 * (k -= 1)) *\n\t                        Math.sin((k - s) * (2 * Math.PI) / p));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return (a * Math.pow(2, -10 * k) *\n\t                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticInOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p));\n\t            }\n\t            return a * Math.pow(2, -10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\n\t        },\n\t\n\t        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backIn: function (k) {\n\t            var s = 1.70158;\n\t            return k * k * ((s + 1) * k - s);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backOut: function (k) {\n\t            var s = 1.70158;\n\t            return --k * k * ((s + 1) * k + s) + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backInOut: function (k) {\n\t            var s = 1.70158 * 1.525;\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * (k * k * ((s + 1) * k - s));\n\t            }\n\t            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t        },\n\t\n\t        // 创建弹跳效果\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceIn: function (k) {\n\t            return 1 - easing.bounceOut(1 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceOut: function (k) {\n\t            if (k < (1 / 2.75)) {\n\t                return 7.5625 * k * k;\n\t            }\n\t            else if (k < (2 / 2.75)) {\n\t                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t            }\n\t            else if (k < (2.5 / 2.75)) {\n\t                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t            }\n\t            else {\n\t                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t            }\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceInOut: function (k) {\n\t            if (k < 0.5) {\n\t                return easing.bounceIn(k * 2) * 0.5;\n\t            }\n\t            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t        }\n\t    };\n\t\n\t    module.exports = easing;\n\t\n\t\n\n\n/***/ },\n/* 163 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var normalizeRadian = __webpack_require__(76).normalizeRadian;\n\t    var PI2 = Math.PI * 2;\n\t\n\t    module.exports = {\n\t        /**\n\t         * 圆弧描边包含判断\n\t         * @param  {number}  cx\n\t         * @param  {number}  cy\n\t         * @param  {number}  r\n\t         * @param  {number}  startAngle\n\t         * @param  {number}  endAngle\n\t         * @param  {boolean}  anticlockwise\n\t         * @param  {number} lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {Boolean}\n\t         */\n\t        containStroke: function (\n\t            cx, cy, r, startAngle, endAngle, anticlockwise,\n\t            lineWidth, x, y\n\t        ) {\n\t\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t\n\t            x -= cx;\n\t            y -= cy;\n\t            var d = Math.sqrt(x * x + y * y);\n\t\n\t            if ((d - _l > r) || (d + _l < r)) {\n\t                return false;\n\t            }\n\t            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n\t                // Is a circle\n\t                return true;\n\t            }\n\t            if (anticlockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = normalizeRadian(endAngle);\n\t                endAngle = normalizeRadian(tmp);\n\t            } else {\n\t                startAngle = normalizeRadian(startAngle);\n\t                endAngle = normalizeRadian(endAngle);\n\t            }\n\t            if (startAngle > endAngle) {\n\t                endAngle += PI2;\n\t            }\n\t\n\t            var angle = Math.atan2(y, x);\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return (angle >= startAngle && angle <= endAngle)\n\t                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n\t        }\n\t    };\n\n\n/***/ },\n/* 164 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(20);\n\t\n\t    module.exports = {\n\t        /**\n\t         * 三次贝塞尔曲线描边包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  x3\n\t         * @param  {number}  y3\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.cubicProjectPoint(\n\t                x0, y0, x1, y1, x2, y2, x3, y3,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 165 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = {\n\t        /**\n\t         * 线段包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            var _a = 0;\n\t            var _b = x0;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l)\n\t                || (y < y0 - _l && y < y1 - _l)\n\t                || (x > x0 + _l && x > x1 + _l)\n\t                || (x < x0 - _l && x < x1 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t\n\t            if (x0 !== x1) {\n\t                _a = (y0 - y1) / (x0 - x1);\n\t                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n\t            }\n\t            else {\n\t                return Math.abs(x - x0) <= _l / 2;\n\t            }\n\t            var tmp = _a * x - y + _b;\n\t            var _s = tmp * tmp / (_a * _a + 1);\n\t            return _s <= _l / 2 * _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 166 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var CMD = __webpack_require__(41).CMD;\n\t    var line = __webpack_require__(165);\n\t    var cubic = __webpack_require__(164);\n\t    var quadratic = __webpack_require__(167);\n\t    var arc = __webpack_require__(163);\n\t    var normalizeRadian = __webpack_require__(76).normalizeRadian;\n\t    var curve = __webpack_require__(20);\n\t\n\t    var windingLine = __webpack_require__(168);\n\t\n\t    var containStroke = line.containStroke;\n\t\n\t    var PI2 = Math.PI * 2;\n\t\n\t    var EPSILON = 1e-4;\n\t\n\t    function isAroundEqual(a, b) {\n\t        return Math.abs(a - b) < EPSILON;\n\t    }\n\t\n\t    // 临时数组\n\t    var roots = [-1, -1, -1];\n\t    var extrema = [-1, -1];\n\t\n\t    function swapExtrema() {\n\t        var tmp = extrema[0];\n\t        extrema[0] = extrema[1];\n\t        extrema[1] = tmp;\n\t    }\n\t\n\t    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2 && y > y3)\n\t            || (y < y0 && y < y1 && y < y2 && y < y3)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var w = 0;\n\t            var nExtrema = -1;\n\t            var y0_, y1_;\n\t            for (var i = 0; i < nRoots; i++) {\n\t                var t = roots[i];\n\t\n\t                // Avoid winding error when intersection point is the connect point of two line of polygon\n\t                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t                if (x_ < x) { // Quick reject\n\t                    continue;\n\t                }\n\t                if (nExtrema < 0) {\n\t                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t                        swapExtrema();\n\t                    }\n\t                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t                    if (nExtrema > 1) {\n\t                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t                    }\n\t                }\n\t                if (nExtrema == 2) {\n\t                    // 分成三段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else if (t < extrema[1]) {\n\t                        w += y1_ < y0_ ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y1_ ? unit : -unit;\n\t                    }\n\t                }\n\t                else {\n\t                    // 分成两段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y0_ ? unit : -unit;\n\t                    }\n\t                }\n\t            }\n\t            return w;\n\t        }\n\t    }\n\t\n\t    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2)\n\t            || (y < y0 && y < y1 && y < y2)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var t = curve.quadraticExtremum(y0, y1, y2);\n\t            if (t >= 0 && t <= 1) {\n\t                var w = 0;\n\t                var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t                for (var i = 0; i < nRoots; i++) {\n\t                    // Remove one endpoint.\n\t                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\t\n\t                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t                    if (x_ < x) {   // Quick reject\n\t                        continue;\n\t                    }\n\t                    if (roots[i] < t) {\n\t                        w += y_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y2 < y_ ? unit : -unit;\n\t                    }\n\t                }\n\t                return w;\n\t            }\n\t            else {\n\t                // Remove one endpoint.\n\t                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t                if (x_ < x) {   // Quick reject\n\t                    return 0;\n\t                }\n\t                return y2 < y0 ? unit : -unit;\n\t            }\n\t        }\n\t    }\n\t\n\t    // TODO\n\t    // Arc 旋转\n\t    function windingArc(\n\t        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n\t    ) {\n\t        y -= cy;\n\t        if (y > r || y < -r) {\n\t            return 0;\n\t        }\n\t        var tmp = Math.sqrt(r * r - y * y);\n\t        roots[0] = -tmp;\n\t        roots[1] = tmp;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff < 1e-4) {\n\t            return 0;\n\t        }\n\t        if (diff % PI2 < 1e-4) {\n\t            // Is a circle\n\t            startAngle = 0;\n\t            endAngle = PI2;\n\t            var dir = anticlockwise ? 1 : -1;\n\t            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t                return dir;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t\n\t        if (anticlockwise) {\n\t            var tmp = startAngle;\n\t            startAngle = normalizeRadian(endAngle);\n\t            endAngle = normalizeRadian(tmp);\n\t        }\n\t        else {\n\t            startAngle = normalizeRadian(startAngle);\n\t            endAngle = normalizeRadian(endAngle);\n\t        }\n\t        if (startAngle > endAngle) {\n\t            endAngle += PI2;\n\t        }\n\t\n\t        var w = 0;\n\t        for (var i = 0; i < 2; i++) {\n\t            var x_ = roots[i];\n\t            if (x_ + cx > x) {\n\t                var angle = Math.atan2(y, x_);\n\t                var dir = anticlockwise ? 1 : -1;\n\t                if (angle < 0) {\n\t                    angle = PI2 + angle;\n\t                }\n\t                if (\n\t                    (angle >= startAngle && angle <= endAngle)\n\t                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n\t                ) {\n\t                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t                        dir = -dir;\n\t                    }\n\t                    w += dir;\n\t                }\n\t            }\n\t        }\n\t        return w;\n\t    }\n\t\n\t    function containPath(data, lineWidth, isStroke, x, y) {\n\t        var w = 0;\n\t        var xi = 0;\n\t        var yi = 0;\n\t        var x0 = 0;\n\t        var y0 = 0;\n\t\n\t        for (var i = 0; i < data.length;) {\n\t            var cmd = data[i++];\n\t            // Begin a new subpath\n\t            if (cmd === CMD.M && i > 1) {\n\t                // Close previous subpath\n\t                if (!isStroke) {\n\t                    w += windingLine(xi, yi, x0, y0, x, y);\n\t                }\n\t                // 如果被任何一个 subpath 包含\n\t                // if (w !== 0) {\n\t                //     return true;\n\t                // }\n\t            }\n\t\n\t            if (i == 1) {\n\t                // 如果第一个命令是 L, C, Q\n\t                // 则 previous point 同绘制命令的第一个 point\n\t                //\n\t                // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                xi = data[i];\n\t                yi = data[i + 1];\n\t\n\t                x0 = xi;\n\t                y0 = yi;\n\t            }\n\t\n\t            switch (cmd) {\n\t                case CMD.M:\n\t                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                    // 在 closePath 的时候使用\n\t                    x0 = data[i++];\n\t                    y0 = data[i++];\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t                case CMD.L:\n\t                    if (isStroke) {\n\t                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n\t                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.C:\n\t                    if (isStroke) {\n\t                        if (cubic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingCubic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.Q:\n\t                    if (isStroke) {\n\t                        if (quadratic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingQuadratic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.A:\n\t                    // TODO Arc 判断的开销比较大\n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var theta = data[i++];\n\t                    var dTheta = data[i++];\n\t                    // TODO Arc 旋转\n\t                    var psi = data[i++];\n\t                    var anticlockwise = 1 - data[i++];\n\t                    var x1 = Math.cos(theta) * rx + cx;\n\t                    var y1 = Math.sin(theta) * ry + cy;\n\t                    // 不是直接使用 arc 命令\n\t                    if (i > 1) {\n\t                        w += windingLine(xi, yi, x1, y1, x, y);\n\t                    }\n\t                    else {\n\t                        // 第一个命令起点还未定义\n\t                        x0 = x1;\n\t                        y0 = y1;\n\t                    }\n\t                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\t                    var _x = (x - cx) * ry / rx + cx;\n\t                    if (isStroke) {\n\t                        if (arc.containStroke(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            lineWidth, _x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingArc(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            _x, y\n\t                        );\n\t                    }\n\t                    xi = Math.cos(theta + dTheta) * rx + cx;\n\t                    yi = Math.sin(theta + dTheta) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = data[i++];\n\t                    y0 = yi = data[i++];\n\t                    var width = data[i++];\n\t                    var height = data[i++];\n\t                    var x1 = x0 + width;\n\t                    var y1 = y0 + height;\n\t                    if (isStroke) {\n\t                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n\t                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n\t                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n\t                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n\t                        ) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // FIXME Clockwise ?\n\t                        w += windingLine(x1, y0, x1, y1, x, y);\n\t                        w += windingLine(x0, y1, x0, y0, x, y);\n\t                    }\n\t                    break;\n\t                case CMD.Z:\n\t                    if (isStroke) {\n\t                        if (containStroke(\n\t                            xi, yi, x0, y0, lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Close a subpath\n\t                        w += windingLine(xi, yi, x0, y0, x, y);\n\t                        // 如果被任何一个 subpath 包含\n\t                        // FIXME subpaths may overlap\n\t                        // if (w !== 0) {\n\t                        //     return true;\n\t                        // }\n\t                    }\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t            }\n\t        }\n\t        if (!isStroke && !isAroundEqual(yi, y0)) {\n\t            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t        }\n\t        return w !== 0;\n\t    }\n\t\n\t    module.exports = {\n\t        contain: function (pathData, x, y) {\n\t            return containPath(pathData, 0, false, x, y);\n\t        },\n\t\n\t        containStroke: function (pathData, lineWidth, x, y) {\n\t            return containPath(pathData, lineWidth, true, x, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 167 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(20);\n\t\n\t    module.exports = {\n\t        /**\n\t         * 二次贝塞尔曲线描边包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.quadraticProjectPoint(\n\t                x0, y0, x1, y1, x2, y2,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 168 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n\t        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n\t            return 0;\n\t        }\n\t        // Ignore horizontal line\n\t        if (y1 === y0) {\n\t            return 0;\n\t        }\n\t        var dir = y1 < y0 ? 1 : -1;\n\t        var t = (y - y0) / (y1 - y0);\n\t\n\t        // Avoid winding error when intersection point is the connect point of two line of polygon\n\t        if (t === 1 || t === 0) {\n\t            dir = y1 < y0 ? 0.5 : -0.5;\n\t        }\n\t\n\t        var x_ = t * (x1 - x0) + x0;\n\t\n\t        return x_ > x ? dir : 0;\n\t    };\n\n\n/***/ },\n/* 169 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Only implements needed gestures for mobile.\n\t */\n\t\n\t\n\t    var eventUtil = __webpack_require__(42);\n\t\n\t    var GestureMgr = function () {\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._track = [];\n\t    };\n\t\n\t    GestureMgr.prototype = {\n\t\n\t        constructor: GestureMgr,\n\t\n\t        recognize: function (event, target, root) {\n\t            this._doTrack(event, target, root);\n\t            return this._recognize(event);\n\t        },\n\t\n\t        clear: function () {\n\t            this._track.length = 0;\n\t            return this;\n\t        },\n\t\n\t        _doTrack: function (event, target, root) {\n\t            var touches = event.touches;\n\t\n\t            if (!touches) {\n\t                return;\n\t            }\n\t\n\t            var trackItem = {\n\t                points: [],\n\t                touches: [],\n\t                target: target,\n\t                event: event\n\t            };\n\t\n\t            for (var i = 0, len = touches.length; i < len; i++) {\n\t                var touch = touches[i];\n\t                var pos = eventUtil.clientToLocal(root, touch, {});\n\t                trackItem.points.push([pos.zrX, pos.zrY]);\n\t                trackItem.touches.push(touch);\n\t            }\n\t\n\t            this._track.push(trackItem);\n\t        },\n\t\n\t        _recognize: function (event) {\n\t            for (var eventName in recognizers) {\n\t                if (recognizers.hasOwnProperty(eventName)) {\n\t                    var gestureInfo = recognizers[eventName](this._track, event);\n\t                    if (gestureInfo) {\n\t                        return gestureInfo;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function dist(pointPair) {\n\t        var dx = pointPair[1][0] - pointPair[0][0];\n\t        var dy = pointPair[1][1] - pointPair[0][1];\n\t\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    }\n\t\n\t    function center(pointPair) {\n\t        return [\n\t            (pointPair[0][0] + pointPair[1][0]) / 2,\n\t            (pointPair[0][1] + pointPair[1][1]) / 2\n\t        ];\n\t    }\n\t\n\t    var recognizers = {\n\t\n\t        pinch: function (track, event) {\n\t            var trackLen = track.length;\n\t\n\t            if (!trackLen) {\n\t                return;\n\t            }\n\t\n\t            var pinchEnd = (track[trackLen - 1] || {}).points;\n\t            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t\n\t            if (pinchPre\n\t                && pinchPre.length > 1\n\t                && pinchEnd\n\t                && pinchEnd.length > 1\n\t            ) {\n\t                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t                !isFinite(pinchScale) && (pinchScale = 1);\n\t\n\t                event.pinchScale = pinchScale;\n\t\n\t                var pinchCenter = center(pinchEnd);\n\t                event.pinchX = pinchCenter[0];\n\t                event.pinchY = pinchCenter[1];\n\t\n\t                return {\n\t                    type: 'pinch',\n\t                    target: track[0].target,\n\t                    event: event\n\t                };\n\t            }\n\t        }\n\t\n\t        // Only pinch currently.\n\t    };\n\t\n\t    module.exports = GestureMgr;\n\t\n\n\n/***/ },\n/* 170 */\n/***/ function(module, exports) {\n\n\t// Simple LRU cache use doubly linked list\n\t// @module zrender/core/LRU\n\t\n\t\n\t    /**\n\t     * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t     * @constructor\n\t     */\n\t    var LinkedList = function() {\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.head = null;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.tail = null;\n\t\n\t        this._len = 0;\n\t    };\n\t\n\t    var linkedListProto = LinkedList.prototype;\n\t    /**\n\t     * Insert a new value at the tail\n\t     * @param  {} val\n\t     * @return {module:zrender/core/LRU~Entry}\n\t     */\n\t    linkedListProto.insert = function(val) {\n\t        var entry = new Entry(val);\n\t        this.insertEntry(entry);\n\t        return entry;\n\t    };\n\t\n\t    /**\n\t     * Insert an entry at the tail\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.insertEntry = function(entry) {\n\t        if (!this.head) {\n\t            this.head = this.tail = entry;\n\t        }\n\t        else {\n\t            this.tail.next = entry;\n\t            entry.prev = this.tail;\n\t            this.tail = entry;\n\t        }\n\t        this._len++;\n\t    };\n\t\n\t    /**\n\t     * Remove entry.\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.remove = function(entry) {\n\t        var prev = entry.prev;\n\t        var next = entry.next;\n\t        if (prev) {\n\t            prev.next = next;\n\t        }\n\t        else {\n\t            // Is head\n\t            this.head = next;\n\t        }\n\t        if (next) {\n\t            next.prev = prev;\n\t        }\n\t        else {\n\t            // Is tail\n\t            this.tail = prev;\n\t        }\n\t        entry.next = entry.prev = null;\n\t        this._len--;\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    linkedListProto.len = function() {\n\t        return this._len;\n\t    };\n\t\n\t    /**\n\t     * @constructor\n\t     * @param {} val\n\t     */\n\t    var Entry = function(val) {\n\t        /**\n\t         * @type {}\n\t         */\n\t        this.value = val;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.next;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.prev;\n\t    };\n\t\n\t    /**\n\t     * LRU Cache\n\t     * @constructor\n\t     * @alias module:zrender/core/LRU\n\t     */\n\t    var LRU = function(maxSize) {\n\t\n\t        this._list = new LinkedList();\n\t\n\t        this._map = {};\n\t\n\t        this._maxSize = maxSize || 10;\n\t    };\n\t\n\t    var LRUProto = LRU.prototype;\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @param  {} value\n\t     */\n\t    LRUProto.put = function(key, value) {\n\t        var list = this._list;\n\t        var map = this._map;\n\t        if (map[key] == null) {\n\t            var len = list.len();\n\t            if (len >= this._maxSize && len > 0) {\n\t                // Remove the least recently used\n\t                var leastUsedEntry = list.head;\n\t                list.remove(leastUsedEntry);\n\t                delete map[leastUsedEntry.key];\n\t            }\n\t\n\t            var entry = list.insert(value);\n\t            entry.key = key;\n\t            map[key] = entry;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @return {}\n\t     */\n\t    LRUProto.get = function(key) {\n\t        var entry = this._map[key];\n\t        var list = this._list;\n\t        if (entry != null) {\n\t            // Put the latest used entry in the tail\n\t            if (entry !== list.tail) {\n\t                list.remove(entry);\n\t                list.insertEntry(entry);\n\t            }\n\t\n\t            return entry.value;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Clear the cache\n\t     */\n\t    LRUProto.clear = function() {\n\t        this._list.clear();\n\t        this._map = {};\n\t    };\n\t\n\t    module.exports = LRU;\n\n\n/***/ },\n/* 171 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author Yi Shen(https://github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(7);\n\t    var curve = __webpack_require__(20);\n\t\n\t    var bbox = {};\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t\n\t    var start = vec2.create();\n\t    var end = vec2.create();\n\t    var extremity = vec2.create();\n\t\n\t    var PI2 = Math.PI * 2;\n\t    /**\n\t     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n\t     * @module zrender/core/bbox\n\t     * @param {Array<Object>} points 顶点数组\n\t     * @param {number} min\n\t     * @param {number} max\n\t     */\n\t    bbox.fromPoints = function(points, min, max) {\n\t        if (points.length === 0) {\n\t            return;\n\t        }\n\t        var p = points[0];\n\t        var left = p[0];\n\t        var right = p[0];\n\t        var top = p[1];\n\t        var bottom = p[1];\n\t        var i;\n\t\n\t        for (i = 1; i < points.length; i++) {\n\t            p = points[i];\n\t            left = mathMin(left, p[0]);\n\t            right = mathMax(right, p[0]);\n\t            top = mathMin(top, p[1]);\n\t            bottom = mathMax(bottom, p[1]);\n\t        }\n\t\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n\t        min[0] = mathMin(x0, x1);\n\t        min[1] = mathMin(y0, y1);\n\t        max[0] = mathMax(x0, x1);\n\t        max[1] = mathMax(y0, y1);\n\t    };\n\t\n\t    var xDim = [];\n\t    var yDim = [];\n\t    /**\n\t     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromCubic = function(\n\t        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n\t    ) {\n\t        var cubicExtrema = curve.cubicExtrema;\n\t        var cubicAt = curve.cubicAt;\n\t        var i;\n\t        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t        min[0] = Infinity;\n\t        min[1] = Infinity;\n\t        max[0] = -Infinity;\n\t        max[1] = -Infinity;\n\t\n\t        for (i = 0; i < n; i++) {\n\t            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t            min[0] = mathMin(x, min[0]);\n\t            max[0] = mathMax(x, max[0]);\n\t        }\n\t        n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t        for (i = 0; i < n; i++) {\n\t            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t            min[1] = mathMin(y, min[1]);\n\t            max[1] = mathMax(y, max[1]);\n\t        }\n\t\n\t        min[0] = mathMin(x0, min[0]);\n\t        max[0] = mathMax(x0, max[0]);\n\t        min[0] = mathMin(x3, min[0]);\n\t        max[0] = mathMax(x3, max[0]);\n\t\n\t        min[1] = mathMin(y0, min[1]);\n\t        max[1] = mathMax(y0, max[1]);\n\t        min[1] = mathMin(y3, min[1]);\n\t        max[1] = mathMax(y3, max[1]);\n\t    };\n\t\n\t    /**\n\t     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n\t        var quadraticExtremum = curve.quadraticExtremum;\n\t        var quadraticAt = curve.quadraticAt;\n\t        // Find extremities, where derivative in x dim or y dim is zero\n\t        var tx =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n\t            );\n\t        var ty =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n\t            );\n\t\n\t        var x = quadraticAt(x0, x1, x2, tx);\n\t        var y = quadraticAt(y0, y1, y2, ty);\n\t\n\t        min[0] = mathMin(x0, x2, x);\n\t        min[1] = mathMin(y0, y2, y);\n\t        max[0] = mathMax(x0, x2, x);\n\t        max[1] = mathMax(y0, y2, y);\n\t    };\n\t\n\t    /**\n\t     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n\t     * @method\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {number} rx\n\t     * @param {number} ry\n\t     * @param {number} startAngle\n\t     * @param {number} endAngle\n\t     * @param {number} anticlockwise\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromArc = function (\n\t        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n\t    ) {\n\t        var vec2Min = vec2.min;\n\t        var vec2Max = vec2.max;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t\n\t\n\t        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n\t            // Is a circle\n\t            min[0] = x - rx;\n\t            min[1] = y - ry;\n\t            max[0] = x + rx;\n\t            max[1] = y + ry;\n\t            return;\n\t        }\n\t\n\t        start[0] = mathCos(startAngle) * rx + x;\n\t        start[1] = mathSin(startAngle) * ry + y;\n\t\n\t        end[0] = mathCos(endAngle) * rx + x;\n\t        end[1] = mathSin(endAngle) * ry + y;\n\t\n\t        vec2Min(min, start, end);\n\t        vec2Max(max, start, end);\n\t\n\t        // Thresh to [0, Math.PI * 2]\n\t        startAngle = startAngle % (PI2);\n\t        if (startAngle < 0) {\n\t            startAngle = startAngle + PI2;\n\t        }\n\t        endAngle = endAngle % (PI2);\n\t        if (endAngle < 0) {\n\t            endAngle = endAngle + PI2;\n\t        }\n\t\n\t        if (startAngle > endAngle && !anticlockwise) {\n\t            endAngle += PI2;\n\t        }\n\t        else if (startAngle < endAngle && anticlockwise) {\n\t            startAngle += PI2;\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = endAngle;\n\t            endAngle = startAngle;\n\t            startAngle = tmp;\n\t        }\n\t\n\t        // var number = 0;\n\t        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t            if (angle > startAngle) {\n\t                extremity[0] = mathCos(angle) * rx + x;\n\t                extremity[1] = mathSin(angle) * ry + y;\n\t\n\t                vec2Min(min, extremity, min);\n\t                vec2Max(max, extremity, max);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = bbox;\n\t\n\n\n/***/ },\n/* 172 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var eventTool = __webpack_require__(42);\n\t    var zrUtil = __webpack_require__(1);\n\t    var Eventful = __webpack_require__(28);\n\t    var env = __webpack_require__(14);\n\t    var GestureMgr = __webpack_require__(169);\n\t\n\t    var addEventListener = eventTool.addEventListener;\n\t    var removeEventListener = eventTool.removeEventListener;\n\t    var normalizeEvent = eventTool.normalizeEvent;\n\t\n\t    var TOUCH_CLICK_DELAY = 300;\n\t\n\t    var mouseHandlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n\t    ];\n\t\n\t    var touchHandlerNames = [\n\t        'touchstart', 'touchend', 'touchmove'\n\t    ];\n\t\n\t    function eventNameFix(name) {\n\t        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n\t    }\n\t\n\t    function processGesture(proxy, event, stage) {\n\t        var gestureMgr = proxy._gestureMgr;\n\t\n\t        stage === 'start' && gestureMgr.clear();\n\t\n\t        var gestureInfo = gestureMgr.recognize(\n\t            event,\n\t            proxy.handler.findHover(event.zrX, event.zrY, null),\n\t            proxy.dom\n\t        );\n\t\n\t        stage === 'end' && gestureMgr.clear();\n\t\n\t        if (gestureInfo) {\n\t            // eventTool.stop(event);\n\t            var type = gestureInfo.type;\n\t            event.gestureEvent = type;\n\t\n\t            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Prevent mouse event from being dispatched after Touch Events action\n\t     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t     * Result: Blocking Mouse Events for 700ms.\n\t     */\n\t    function setTouchTimer(instance) {\n\t        instance._touching = true;\n\t        clearTimeout(instance._touchTimer);\n\t        instance._touchTimer = setTimeout(function () {\n\t            instance._touching = false;\n\t        }, 700);\n\t    }\n\t\n\t    function useTouchEvent() {\n\t        return env.touchEventsSupported;\n\t    }\n\t\n\t    var domHandlers = {\n\t        /**\n\t         * Mouse move handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mousemove: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            this.trigger('mousemove', event);\n\t        },\n\t\n\t        /**\n\t         * Mouse out handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mouseout: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            var element = event.toElement || event.relatedTarget;\n\t            if (element != this.dom) {\n\t                while (element && element.nodeType != 9) {\n\t                    // 忽略包含在root中的dom引起的mouseOut\n\t                    if (element === this.dom) {\n\t                        return;\n\t                    }\n\t\n\t                    element = element.parentNode;\n\t                }\n\t            }\n\t\n\t            this.trigger('mouseout', event);\n\t        },\n\t\n\t        /**\n\t         * Touch开始响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchstart: function (event) {\n\t            // Default mouse behaviour should not be disabled here.\n\t            // For example, page may needs to be slided.\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            this._lastTouchMoment = new Date();\n\t\n\t            processGesture(this, event, 'start');\n\t\n\t            // In touch device, trigger `mousemove`(`mouseover`) should\n\t            // be triggered.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            domHandlers.mousedown.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch移动响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchmove: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            processGesture(this, event, 'change');\n\t\n\t            // Mouse move should always be triggered no matter whether\n\t            // there is gestrue event, because mouse move and pinch may\n\t            // be used at the same time.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch结束响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchend: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            processGesture(this, event, 'end');\n\t\n\t            domHandlers.mouseup.call(this, event);\n\t\n\t            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n\t            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n\t            // we can conveniently implement \"hover style\" in both PC and touch device just\n\t            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n\t            // to remove \"hover style\" on an element, without any additional code for\n\t            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n\t            // style\" will remain for user view)\n\t\n\t            // click event should always be triggered no matter whether\n\t            // there is gestrue event. System click can not be prevented.\n\t            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t                domHandlers.click.call(this, event);\n\t            }\n\t\n\t            setTouchTimer(this);\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t        domHandlers[name] = function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t            this.trigger(name, event);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * 为控制类实例初始化dom 事件处理函数\n\t     *\n\t     * @inner\n\t     * @param {module:zrender/Handler} instance 控制类实例\n\t     */\n\t    function initDomHandler(instance) {\n\t        for (var i = 0; i < touchHandlerNames.length; i++) {\n\t            var name = touchHandlerNames[i];\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        }\n\t\n\t        for (var i = 0; i < mouseHandlerNames.length; i++) {\n\t            var name = mouseHandlerNames[i];\n\t            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t        }\n\t\n\t        function makeMouseHandler(fn, instance) {\n\t            return function () {\n\t                if (instance._touching) {\n\t                    return;\n\t                }\n\t                return fn.apply(instance, arguments);\n\t            };\n\t        }\n\t    }\n\t\n\t\n\t    function HandlerDomProxy(dom) {\n\t        Eventful.call(this);\n\t\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._touching = false;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._touchTimer;\n\t\n\t        /**\n\t         * @private\n\t         * @type {module:zrender/core/GestureMgr}\n\t         */\n\t        this._gestureMgr = new GestureMgr();\n\t\n\t        this._handlers = {};\n\t\n\t        initDomHandler(this);\n\t\n\t        if (useTouchEvent()) {\n\t            mountHandlers(touchHandlerNames, this);\n\t\n\t            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t            // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t        }\n\t\n\t        // Considering some devices that both enable touch and mouse event (like MS Surface\n\t        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t        // mouse event can not be handle in those devices.\n\t        mountHandlers(mouseHandlerNames, this);\n\t\n\t        function mountHandlers(handlerNames, instance) {\n\t            zrUtil.each(handlerNames, function (name) {\n\t                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t            }, instance);\n\t        }\n\t    }\n\t\n\t    var handlerDomProxyProto = HandlerDomProxy.prototype;\n\t    handlerDomProxyProto.dispose = function () {\n\t        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t\n\t        for (var i = 0; i < handlerNames.length; i++) {\n\t            var name = handlerNames[i];\n\t            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t        }\n\t    };\n\t\n\t    handlerDomProxyProto.setCursor = function (cursorStyle) {\n\t        this.dom.style.cursor = cursorStyle || 'default';\n\t    };\n\t\n\t    zrUtil.mixin(HandlerDomProxy, Eventful);\n\t\n\t    module.exports = HandlerDomProxy;\n\n\n/***/ },\n/* 173 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CompoundPath to improve performance\n\t\n\t\n\t    var Path = __webpack_require__(6);\n\t    module.exports = Path.extend({\n\t\n\t        type: 'compound',\n\t\n\t        shape: {\n\t\n\t            paths: null\n\t        },\n\t\n\t        _updatePathDirty: function () {\n\t            var dirtyPath = this.__dirtyPath;\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                // Mark as dirty if any subpath is dirty\n\t                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n\t            }\n\t            this.__dirtyPath = dirtyPath;\n\t            this.__dirty = this.__dirty || dirtyPath;\n\t        },\n\t\n\t        beforeBrush: function () {\n\t            this._updatePathDirty();\n\t            var paths = this.shape.paths || [];\n\t            var scale = this.getGlobalScale();\n\t            // Update path scale\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].path.setScale(scale[0], scale[1]);\n\t            }\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var paths = shape.paths || [];\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].buildPath(ctx, paths[i].shape, true);\n\t            }\n\t        },\n\t\n\t        afterBrush: function () {\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].__dirtyPath = false;\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            this._updatePathDirty();\n\t            return Path.prototype.getBoundingRect.call(this);\n\t        }\n\t    });\n\n\n/***/ },\n/* 174 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var Gradient = __webpack_require__(55);\n\t\n\t    /**\n\t     * x, y, x2, y2 are all percent from 0 to 1\n\t     * @param {number} [x=0]\n\t     * @param {number} [y=0]\n\t     * @param {number} [x2=1]\n\t     * @param {number} [y2=0]\n\t     * @param {Array.<Object>} colorStops\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t        this.x = x == null ? 0 : x;\n\t\n\t        this.y = y == null ? 0 : y;\n\t\n\t        this.x2 = x2 == null ? 1 : x2;\n\t\n\t        this.y2 = y2 == null ? 0 : y2;\n\t\n\t        // Can be cloned\n\t        this.type = 'linear';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    LinearGradient.prototype = {\n\t\n\t        constructor: LinearGradient\n\t    };\n\t\n\t    zrUtil.inherits(LinearGradient, Gradient);\n\t\n\t    module.exports = LinearGradient;\n\n\n/***/ },\n/* 175 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var Gradient = __webpack_require__(55);\n\t\n\t    /**\n\t     * x, y, r are all percent from 0 to 1\n\t     * @param {number} [x=0.5]\n\t     * @param {number} [y=0.5]\n\t     * @param {number} [r=0.5]\n\t     * @param {Array.<Object>} [colorStops]\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t        this.x = x == null ? 0.5 : x;\n\t\n\t        this.y = y == null ? 0.5 : y;\n\t\n\t        this.r = r == null ? 0.5 : r;\n\t\n\t        // Can be cloned\n\t        this.type = 'radial';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    RadialGradient.prototype = {\n\t\n\t        constructor: RadialGradient\n\t    };\n\t\n\t    zrUtil.inherits(RadialGradient, Gradient);\n\t\n\t    module.exports = RadialGradient;\n\n\n/***/ },\n/* 176 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Text element\n\t * @module zrender/graphic/Text\n\t *\n\t * TODO Wrapping\n\t *\n\t * Text not support gradient\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(54);\n\t    var zrUtil = __webpack_require__(1);\n\t    var textContain = __webpack_require__(26);\n\t\n\t    /**\n\t     * @alias zrender/graphic/Text\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    var Text = function (opts) {\n\t        Displayable.call(this, opts);\n\t    };\n\t\n\t    Text.prototype = {\n\t\n\t        constructor: Text,\n\t\n\t        type: 'text',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var x = style.x || 0;\n\t            var y = style.y || 0;\n\t            // Convert to string\n\t            var text = style.text;\n\t\n\t            // Convert to string\n\t            text != null && (text += '');\n\t\n\t            // Always bind style\n\t            style.bind(ctx, this, prevEl);\n\t\n\t            if (text) {\n\t\n\t                this.setTransform(ctx);\n\t\n\t                var textBaseline;\n\t                var textAlign = style.textAlign;\n\t                var font = style.textFont || style.font;\n\t                if (style.textVerticalAlign) {\n\t                    var rect = textContain.getBoundingRect(\n\t                        text, font, style.textAlign, 'top'\n\t                    );\n\t                    // Ignore textBaseline\n\t                    textBaseline = 'middle';\n\t                    switch (style.textVerticalAlign) {\n\t                        case 'middle':\n\t                            y -= rect.height / 2 - rect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= rect.height - rect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += rect.lineHeight / 2;\n\t                    }\n\t                }\n\t                else {\n\t                    textBaseline = style.textBaseline;\n\t                }\n\t\n\t                // TODO Invalid font\n\t                ctx.font = font || '12px sans-serif';\n\t                ctx.textAlign = textAlign || 'left';\n\t                // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t                if (ctx.textAlign !== textAlign) {\n\t                    ctx.textAlign = 'left';\n\t                }\n\t                ctx.textBaseline = textBaseline || 'alphabetic';\n\t                // Use canvas default alphabetic baseline\n\t                if (ctx.textBaseline !== textBaseline) {\n\t                    ctx.textBaseline = 'alphabetic';\n\t                }\n\t\n\t                var lineHeight = textContain.measureText('国', ctx.font).width;\n\t\n\t                var textLines = text.split('\\n');\n\t                for (var i = 0; i < textLines.length; i++) {\n\t                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n\t                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n\t                    y += lineHeight;\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            if (!this._rect) {\n\t                var style = this.style;\n\t                var textVerticalAlign = style.textVerticalAlign;\n\t                var rect = textContain.getBoundingRect(\n\t                    style.text + '', style.textFont || style.font, style.textAlign,\n\t                    textVerticalAlign ? 'top' : style.textBaseline\n\t                );\n\t                switch (textVerticalAlign) {\n\t                    case 'middle':\n\t                        rect.y -= rect.height / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        rect.y -= rect.height;\n\t                        break;\n\t                }\n\t                rect.x += style.x || 0;\n\t                rect.y += style.y || 0;\n\t                this._rect = rect;\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Text, Displayable);\n\t\n\t    module.exports = Text;\n\n\n/***/ },\n/* 177 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            var r = shape.r;\n\t            var r1;\n\t            var r2;\n\t            var r3;\n\t            var r4;\n\t\n\t            // Convert width and height to positive for better borderRadius\n\t            if (width < 0) {\n\t                x = x + width;\n\t                width = -width;\n\t            }\n\t            if (height < 0) {\n\t                y = y + height;\n\t                height = -height;\n\t            }\n\t\n\t            if (typeof r === 'number') {\n\t                r1 = r2 = r3 = r4 = r;\n\t            }\n\t            else if (r instanceof Array) {\n\t                if (r.length === 1) {\n\t                    r1 = r2 = r3 = r4 = r[0];\n\t                }\n\t                else if (r.length === 2) {\n\t                    r1 = r3 = r[0];\n\t                    r2 = r4 = r[1];\n\t                }\n\t                else if (r.length === 3) {\n\t                    r1 = r[0];\n\t                    r2 = r4 = r[1];\n\t                    r3 = r[2];\n\t                }\n\t                else {\n\t                    r1 = r[0];\n\t                    r2 = r[1];\n\t                    r3 = r[2];\n\t                    r4 = r[3];\n\t                }\n\t            }\n\t            else {\n\t                r1 = r2 = r3 = r4 = 0;\n\t            }\n\t\n\t            var total;\n\t            if (r1 + r2 > width) {\n\t                total = r1 + r2;\n\t                r1 *= width / total;\n\t                r2 *= width / total;\n\t            }\n\t            if (r3 + r4 > width) {\n\t                total = r3 + r4;\n\t                r3 *= width / total;\n\t                r4 *= width / total;\n\t            }\n\t            if (r2 + r3 > height) {\n\t                total = r2 + r3;\n\t                r2 *= height / total;\n\t                r3 *= height / total;\n\t            }\n\t            if (r1 + r4 > height) {\n\t                total = r1 + r4;\n\t                r1 *= height / total;\n\t                r4 *= height / total;\n\t            }\n\t            ctx.moveTo(x + r1, y);\n\t            ctx.lineTo(x + width - r2, y);\n\t            r2 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y, x + width, y + r2\n\t            );\n\t            ctx.lineTo(x + width, y + height - r3);\n\t            r3 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y + height, x + width - r3, y + height\n\t            );\n\t            ctx.lineTo(x + r4, y + height);\n\t            r4 !== 0 && ctx.quadraticCurveTo(\n\t                x, y + height, x, y + height - r4\n\t            );\n\t            ctx.lineTo(x, y + r1);\n\t            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 178 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 贝塞尔平滑曲线\n\t * @module zrender/shape/util/smoothBezier\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(7);\n\t    var v2Min = vec2.min;\n\t    var v2Max = vec2.max;\n\t    var v2Scale = vec2.scale;\n\t    var v2Distance = vec2.distance;\n\t    var v2Add = vec2.add;\n\t\n\t    /**\n\t     * 贝塞尔平滑曲线\n\t     * @alias module:zrender/shape/util/smoothBezier\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {number} smooth 平滑等级, 0-1\n\t     * @param {boolean} isLoop\n\t     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n\t     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n\t     *                           整个折线的包围盒做一个并集用来约束控制点。\n\t     * @param {Array} 计算出来的控制点数组\n\t     */\n\t    module.exports = function (points, smooth, isLoop, constraint) {\n\t        var cps = [];\n\t\n\t        var v = [];\n\t        var v1 = [];\n\t        var v2 = [];\n\t        var prevPoint;\n\t        var nextPoint;\n\t\n\t        var min, max;\n\t        if (constraint) {\n\t            min = [Infinity, Infinity];\n\t            max = [-Infinity, -Infinity];\n\t            for (var i = 0, len = points.length; i < len; i++) {\n\t                v2Min(min, min, points[i]);\n\t                v2Max(max, max, points[i]);\n\t            }\n\t            // 与指定的包围盒做并集\n\t            v2Min(min, min, constraint[0]);\n\t            v2Max(max, max, constraint[1]);\n\t        }\n\t\n\t        for (var i = 0, len = points.length; i < len; i++) {\n\t            var point = points[i];\n\t\n\t            if (isLoop) {\n\t                prevPoint = points[i ? i - 1 : len - 1];\n\t                nextPoint = points[(i + 1) % len];\n\t            }\n\t            else {\n\t                if (i === 0 || i === len - 1) {\n\t                    cps.push(vec2.clone(points[i]));\n\t                    continue;\n\t                }\n\t                else {\n\t                    prevPoint = points[i - 1];\n\t                    nextPoint = points[i + 1];\n\t                }\n\t            }\n\t\n\t            vec2.sub(v, nextPoint, prevPoint);\n\t\n\t            // use degree to scale the handle length\n\t            v2Scale(v, v, smooth);\n\t\n\t            var d0 = v2Distance(point, prevPoint);\n\t            var d1 = v2Distance(point, nextPoint);\n\t            var sum = d0 + d1;\n\t            if (sum !== 0) {\n\t                d0 /= sum;\n\t                d1 /= sum;\n\t            }\n\t\n\t            v2Scale(v1, v, -d0);\n\t            v2Scale(v2, v, d1);\n\t            var cp0 = v2Add([], point, v1);\n\t            var cp1 = v2Add([], point, v2);\n\t            if (constraint) {\n\t                v2Max(cp0, cp0, min);\n\t                v2Min(cp0, cp0, max);\n\t                v2Max(cp1, cp1, min);\n\t                v2Min(cp1, cp1, max);\n\t            }\n\t            cps.push(cp0);\n\t            cps.push(cp1);\n\t        }\n\t\n\t        if (isLoop) {\n\t            cps.push(cps.shift());\n\t        }\n\t\n\t        return cps;\n\t    };\n\t\n\n\n/***/ },\n/* 179 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Catmull-Rom spline 插值折线\n\t * @module zrender/shape/util/smoothSpline\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t    var vec2 = __webpack_require__(7);\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/shape/util/smoothSpline\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {boolean} isLoop\n\t     * @return {Array}\n\t     */\n\t    module.exports = function (points, isLoop) {\n\t        var len = points.length;\n\t        var ret = [];\n\t\n\t        var distance = 0;\n\t        for (var i = 1; i < len; i++) {\n\t            distance += vec2.distance(points[i - 1], points[i]);\n\t        }\n\t\n\t        var segs = distance / 2;\n\t        segs = segs < len ? len : segs;\n\t        for (var i = 0; i < segs; i++) {\n\t            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t            var idx = Math.floor(pos);\n\t\n\t            var w = pos - idx;\n\t\n\t            var p0;\n\t            var p1 = points[idx % len];\n\t            var p2;\n\t            var p3;\n\t            if (!isLoop) {\n\t                p0 = points[idx === 0 ? idx : idx - 1];\n\t                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t            }\n\t            else {\n\t                p0 = points[(idx - 1 + len) % len];\n\t                p2 = points[(idx + 1) % len];\n\t                p3 = points[(idx + 2) % len];\n\t            }\n\t\n\t            var w2 = w * w;\n\t            var w3 = w * w2;\n\t\n\t            ret.push([\n\t                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n\t                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n\t            ]);\n\t        }\n\t        return ret;\n\t    };\n\t\n\n\n/***/ },\n/* 180 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Mixin for drawing text in a element bounding rect\n\t * @module zrender/mixin/RectText\n\t */\n\t\n\t\n\t\n\t    var textContain = __webpack_require__(26);\n\t    var BoundingRect = __webpack_require__(13);\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var RectText = function () {};\n\t\n\t    function parsePercent(value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    }\n\t\n\t    RectText.prototype = {\n\t\n\t        constructor: RectText,\n\t\n\t        /**\n\t         * Draw text in a rect with specified position.\n\t         * @param  {CanvasRenderingContext} ctx\n\t         * @param  {Object} rect Displayable rect\n\t         * @return {Object} textRect Alternative precalculated text bounding rect\n\t         */\n\t        drawRectText: function (ctx, rect, textRect) {\n\t            var style = this.style;\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            if (!text) {\n\t                return;\n\t            }\n\t\n\t            // FIXME\n\t            ctx.save();\n\t\n\t            var x;\n\t            var y;\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            var align = style.textAlign;\n\t            var font = style.textFont || style.font;\n\t            var baseline = style.textBaseline;\n\t            var verticalAlign = style.textVerticalAlign;\n\t\n\t            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t\n\t            // Transform rect to view space\n\t            var transform = this.transform;\n\t            if (!style.textTransform) {\n\t                if (transform) {\n\t                    tmpRect.copy(rect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = tmpRect;\n\t                }\n\t            }\n\t            else {\n\t                this.setTransform(ctx);\n\t            }\n\t\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                // Percent\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t\n\t                if (verticalAlign) {\n\t                    switch (verticalAlign) {\n\t                        case 'middle':\n\t                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= textRect.height - textRect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += textRect.lineHeight / 2;\n\t                    }\n\t                    // Force bseline to be middle\n\t                    baseline = 'middle';\n\t                }\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, textRect, distance\n\t                );\n\t                x = res.x;\n\t                y = res.y;\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t\n\t            // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t            ctx.textAlign = align || 'left';\n\t            // Use canvas default alphabetic baseline\n\t            ctx.textBaseline = baseline || 'alphabetic';\n\t\n\t            var textFill = style.textFill;\n\t            var textStroke = style.textStroke;\n\t            textFill && (ctx.fillStyle = textFill);\n\t            textStroke && (ctx.strokeStyle = textStroke);\n\t\n\t            // TODO Invalid font\n\t            ctx.font = font || '12px sans-serif';\n\t\n\t            // Text shadow\n\t            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n\t            ctx.shadowBlur = style.textShadowBlur;\n\t            ctx.shadowColor = style.textShadowColor || 'transparent';\n\t            ctx.shadowOffsetX = style.textShadowOffsetX;\n\t            ctx.shadowOffsetY = style.textShadowOffsetY;\n\t\n\t            var textLines = text.split('\\n');\n\t\n\t            if (style.textRotation) {\n\t                transform && ctx.translate(transform[4], transform[5]);\n\t                ctx.rotate(style.textRotation);\n\t                transform && ctx.translate(-transform[4], -transform[5]);\n\t            }\n\t\n\t            for (var i = 0; i < textLines.length; i++) {\n\t                textFill && ctx.fillText(textLines[i], x, y);\n\t                textStroke && ctx.strokeText(textLines[i], x, y);\n\t                y += textRect.lineHeight;\n\t            }\n\t\n\t            ctx.restore();\n\t        }\n\t    };\n\t\n\t    module.exports = RectText;\n\n\n/***/ },\n/* 181 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 圆弧\n\t * @module zrender/graphic/shape/Arc\n\t */\n\t \n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'arc',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        style: {\n\t\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t        }\n\t    });\n\n\n/***/ },\n/* 182 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 贝塞尔曲线\n\t * @module zrender/shape/BezierCurve\n\t */\n\t\n\t\n\t    var curveTool = __webpack_require__(20);\n\t    var vec2 = __webpack_require__(7);\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\n\t    var quadraticAt = curveTool.quadraticAt;\n\t    var cubicAt = curveTool.cubicAt;\n\t    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n\t    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\t\n\t    var out = [];\n\t\n\t    function someVectorAt(shape, t, isTangent) {\n\t        var cpx2 = shape.cpx2;\n\t        var cpy2 = shape.cpy2;\n\t        if (cpx2 === null || cpy2 === null) {\n\t            return [\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n\t            ];\n\t        }\n\t        else {\n\t            return [\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n\t            ];\n\t        }\n\t    }\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'bezier-curve',\n\t\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            cpx1: 0,\n\t            cpy1: 0,\n\t            // cpx2: 0,\n\t            // cpy2: 0\n\t\n\t            // Curve show percent, for animating\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var cpx1 = shape.cpx1;\n\t            var cpy1 = shape.cpy1;\n\t            var cpx2 = shape.cpx2;\n\t            var cpy2 = shape.cpy2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (cpx2 == null || cpy2 == null) {\n\t                if (percent < 1) {\n\t                    quadraticSubdivide(\n\t                        x1, cpx1, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    x2 = out[2];\n\t                    quadraticSubdivide(\n\t                        y1, cpy1, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    y2 = out[2];\n\t                }\n\t\n\t                ctx.quadraticCurveTo(\n\t                    cpx1, cpy1,\n\t                    x2, y2\n\t                );\n\t            }\n\t            else {\n\t                if (percent < 1) {\n\t                    cubicSubdivide(\n\t                        x1, cpx1, cpx2, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    cpx2 = out[2];\n\t                    x2 = out[3];\n\t                    cubicSubdivide(\n\t                        y1, cpy1, cpy2, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    cpy2 = out[2];\n\t                    y2 = out[3];\n\t                }\n\t                ctx.bezierCurveTo(\n\t                    cpx1, cpy1,\n\t                    cpx2, cpy2,\n\t                    x2, y2\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (t) {\n\t            return someVectorAt(this.shape, t, false);\n\t        },\n\t\n\t        /**\n\t         * Get tangent at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        tangentAt: function (t) {\n\t            var p = someVectorAt(this.shape, t, true);\n\t            return vec2.normalize(p, p);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 183 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 圆形\n\t * @module zrender/shape/Circle\n\t */\n\t\n\t\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'circle',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0\n\t        },\n\t\n\t\n\t        buildPath : function (ctx, shape, inBundle) {\n\t            // Better stroking in ShapeBundle\n\t            // Always do it may have performence issue ( fill may be 2x more cost)\n\t            if (inBundle) {\n\t                ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            }\n\t            // Better stroking in ShapeBundle\n\t            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 184 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 直线\n\t * @module zrender/graphic/shape/Line\n\t */\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'line',\n\t\n\t        shape: {\n\t            // Start point\n\t            x1: 0,\n\t            y1: 0,\n\t            // End point\n\t            x2: 0,\n\t            y2: 0,\n\t\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var percent = shape.percent;\n\t\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (percent < 1) {\n\t                x2 = x1 * (1 - percent) + x2 * percent;\n\t                y2 = y1 * (1 - percent) + y2 * percent;\n\t            }\n\t            ctx.lineTo(x2, y2);\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} percent\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (p) {\n\t            var shape = this.shape;\n\t            return [\n\t                shape.x1 * (1 - p) + shape.x2 * p,\n\t                shape.y1 * (1 - p) + shape.y2 * p\n\t            ];\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 185 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 多边形\n\t * @module zrender/shape/Polygon\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(82);\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t        \n\t        type: 'polygon',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, true);\n\t        }\n\t    });\n\n\n/***/ },\n/* 186 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/graphic/shape/Polyline\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(82);\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t        \n\t        type: 'polyline',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, false);\n\t        }\n\t    });\n\n\n/***/ },\n/* 187 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 矩形\n\t * @module zrender/graphic/shape/Rect\n\t */\n\t\n\t\n\t    var roundRectHelper = __webpack_require__(177);\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'rect',\n\t\n\t        shape: {\n\t            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n\t            // r缩写为1         相当于 [1, 1, 1, 1]\n\t            // r缩写为[1]       相当于 [1, 1, 1, 1]\n\t            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n\t            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n\t            r: 0,\n\t\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            if (!shape.r) {\n\t                ctx.rect(x, y, width, height);\n\t            }\n\t            else {\n\t                roundRectHelper.buildPath(ctx, shape);\n\t            }\n\t            ctx.closePath();\n\t            return;\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 188 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 圆环\n\t * @module zrender/graphic/shape/Ring\n\t */\n\t\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'ring',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            r0: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var PI2 = Math.PI * 2;\n\t            ctx.moveTo(x + shape.r, y);\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\n\t            ctx.moveTo(x + shape.r0, y);\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 189 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 扇形\n\t * @module zrender/graphic/shape/Sector\n\t */\n\t\n\t\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'sector',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r0: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r0 = Math.max(shape.r0 || 0, 0);\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\n\t\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t\n\t            ctx.lineTo(\n\t                Math.cos(endAngle) * r0 + x,\n\t                Math.sin(endAngle) * r0 + y\n\t            );\n\t\n\t            if (r0 !== 0) {\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t            }\n\t\n\t            ctx.closePath();\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 190 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/mixin/Animatable\n\t */\n\t\n\t\n\t    var Animator = __webpack_require__(74);\n\t    var util = __webpack_require__(1);\n\t    var isString = util.isString;\n\t    var isFunction = util.isFunction;\n\t    var isObject = util.isObject;\n\t    var log = __webpack_require__(78);\n\t\n\t    /**\n\t     * @alias modue:zrender/mixin/Animatable\n\t     * @constructor\n\t     */\n\t    var Animatable = function () {\n\t\n\t        /**\n\t         * @type {Array.<module:zrender/animation/Animator>}\n\t         * @readOnly\n\t         */\n\t        this.animators = [];\n\t    };\n\t\n\t    Animatable.prototype = {\n\t\n\t        constructor: Animatable,\n\t\n\t        /**\n\t         * 动画\n\t         *\n\t         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\n\t         * @param {boolean} [loop] 动画是否循环\n\t         * @return {module:zrender/animation/Animator}\n\t         * @example:\n\t         *     el.animate('style', false)\n\t         *         .when(1000, {x: 10} )\n\t         *         .done(function(){ // Animation done })\n\t         *         .start()\n\t         */\n\t        animate: function (path, loop) {\n\t            var target;\n\t            var animatingShape = false;\n\t            var el = this;\n\t            var zr = this.__zr;\n\t            if (path) {\n\t                var pathSplitted = path.split('.');\n\t                var prop = el;\n\t                // If animating shape\n\t                animatingShape = pathSplitted[0] === 'shape';\n\t                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t                    if (!prop) {\n\t                        continue;\n\t                    }\n\t                    prop = prop[pathSplitted[i]];\n\t                }\n\t                if (prop) {\n\t                    target = prop;\n\t                }\n\t            }\n\t            else {\n\t                target = el;\n\t            }\n\t\n\t            if (!target) {\n\t                log(\n\t                    'Property \"'\n\t                    + path\n\t                    + '\" is not existed in element '\n\t                    + el.id\n\t                );\n\t                return;\n\t            }\n\t\n\t            var animators = el.animators;\n\t\n\t            var animator = new Animator(target, loop);\n\t\n\t            animator.during(function (target) {\n\t                el.dirty(animatingShape);\n\t            })\n\t            .done(function () {\n\t                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t                animators.splice(util.indexOf(animators, animator), 1);\n\t            });\n\t\n\t            animators.push(animator);\n\t\n\t            // If animate after added to the zrender\n\t            if (zr) {\n\t                zr.animation.addAnimator(animator);\n\t            }\n\t\n\t            return animator;\n\t        },\n\t\n\t        /**\n\t         * 停止动画\n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stopAnimation: function (forwardToLast) {\n\t            var animators = this.animators;\n\t            var len = animators.length;\n\t            for (var i = 0; i < len; i++) {\n\t                animators[i].stop(forwardToLast);\n\t            }\n\t            animators.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {Object} target\n\t         * @param {number} [time=500] Time in ms\n\t         * @param {string} [easing='linear']\n\t         * @param {number} [delay=0]\n\t         * @param {Function} [callback]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el.animateTo({\n\t         *      position: [10, 10]\n\t         *  }, function () { // done })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n\t         *  el.animateTo({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100, 'cubicOut', function () { // done })\n\t         */\n\t         // TODO Return animation key\n\t        animateTo: function (target, time, delay, easing, callback) {\n\t            // animateTo(target, time, easing, callback);\n\t            if (isString(delay)) {\n\t                callback = easing;\n\t                easing = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, delay, callback);\n\t            else if (isFunction(easing)) {\n\t                callback = easing;\n\t                easing = 'linear';\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, callback);\n\t            else if (isFunction(delay)) {\n\t                callback = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, callback)\n\t            else if (isFunction(time)) {\n\t                callback = time;\n\t                time = 500;\n\t            }\n\t            // animateTo(target)\n\t            else if (!time) {\n\t                time = 500;\n\t            }\n\t            // Stop all previous animations\n\t            this.stopAnimation();\n\t            this._animateToShallow('', this, target, time, delay, easing, callback);\n\t\n\t            // Animators may be removed immediately after start\n\t            // if there is nothing to animate\n\t            var animators = this.animators.slice();\n\t            var count = animators.length;\n\t            function done() {\n\t                count--;\n\t                if (!count) {\n\t                    callback && callback();\n\t                }\n\t            }\n\t\n\t            // No animators. This should be checked before animators[i].start(),\n\t            // because 'done' may be executed immediately if no need to animate.\n\t            if (!count) {\n\t                callback && callback();\n\t            }\n\t            // Start after all animators created\n\t            // Incase any animator is done immediately when all animation properties are not changed\n\t            for (var i = 0; i < animators.length; i++) {\n\t                animators[i]\n\t                    .done(done)\n\t                    .start(easing);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {string} path=''\n\t         * @param {Object} source=this\n\t         * @param {Object} target\n\t         * @param {number} [time=500]\n\t         * @param {number} [delay=0]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el._animateToShallow({\n\t         *      position: [10, 10]\n\t         *  })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms\n\t         *  el._animateToShallow({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100)\n\t         */\n\t        _animateToShallow: function (path, source, target, time, delay) {\n\t            var objShallow = {};\n\t            var propertyCount = 0;\n\t            for (var name in target) {\n\t                if (!target.hasOwnProperty(name)) {\n\t                    continue;\n\t                }\n\t\n\t                if (source[name] != null) {\n\t                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n\t                        this._animateToShallow(\n\t                            path ? path + '.' + name : name,\n\t                            source[name],\n\t                            target[name],\n\t                            time,\n\t                            delay\n\t                        );\n\t                    }\n\t                    else {\n\t                        objShallow[name] = target[name];\n\t                        propertyCount++;\n\t                    }\n\t                }\n\t                else if (target[name] != null) {\n\t                    // Attr directly if not has property\n\t                    // FIXME, if some property not needed for element ?\n\t                    if (!path) {\n\t                        this.attr(name, target[name]);\n\t                    }\n\t                    else {  // Shape or style\n\t                        var props = {};\n\t                        props[path] = {};\n\t                        props[path][name] = target[name];\n\t                        this.attr(props);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (propertyCount > 0) {\n\t                this.animate(path, false)\n\t                    .when(time == null ? 500 : time, objShallow)\n\t                    .delay(delay || 0);\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    module.exports = Animatable;\n\n\n/***/ },\n/* 191 */\n/***/ function(module, exports) {\n\n\t// TODO Draggable for group\n\t// FIXME Draggable on element which has parent rotation or scale\n\t\n\t    function Draggable() {\n\t\n\t        this.on('mousedown', this._dragStart, this);\n\t        this.on('mousemove', this._drag, this);\n\t        this.on('mouseup', this._dragEnd, this);\n\t        this.on('globalout', this._dragEnd, this);\n\t        // this._dropTarget = null;\n\t        // this._draggingTarget = null;\n\t\n\t        // this._x = 0;\n\t        // this._y = 0;\n\t    }\n\t\n\t    Draggable.prototype = {\n\t\n\t        constructor: Draggable,\n\t\n\t        _dragStart: function (e) {\n\t            var draggingTarget = e.target;\n\t            if (draggingTarget && draggingTarget.draggable) {\n\t                this._draggingTarget = draggingTarget;\n\t                draggingTarget.dragging = true;\n\t                this._x = e.offsetX;\n\t                this._y = e.offsetY;\n\t\n\t                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n\t            }\n\t        },\n\t\n\t        _drag: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t\n\t                var dx = x - this._x;\n\t                var dy = y - this._y;\n\t                this._x = x;\n\t                this._y = y;\n\t\n\t                draggingTarget.drift(dx, dy, e);\n\t                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\t\n\t                var dropTarget = this.findHover(x, y, draggingTarget);\n\t                var lastDropTarget = this._dropTarget;\n\t                this._dropTarget = dropTarget;\n\t\n\t                if (draggingTarget !== dropTarget) {\n\t                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n\t                    }\n\t                    if (dropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _dragEnd: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t\n\t            if (draggingTarget) {\n\t                draggingTarget.dragging = false;\n\t            }\n\t\n\t            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\t\n\t            if (this._dropTarget) {\n\t                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n\t            }\n\t\n\t            this._draggingTarget = null;\n\t            this._dropTarget = null;\n\t        }\n\t\n\t    };\n\t\n\t    module.exports = Draggable;\n\n\n/***/ },\n/* 192 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 提供变换扩展\n\t * @module zrender/mixin/Transformable\n\t * @author pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var matrix = __webpack_require__(27);\n\t    var vector = __webpack_require__(7);\n\t    var mIdentity = matrix.identity;\n\t\n\t    var EPSILON = 5e-5;\n\t\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/mixin/Transformable\n\t     * @constructor\n\t     */\n\t    var Transformable = function (opts) {\n\t        opts = opts || {};\n\t        // If there are no given position, rotation, scale\n\t        if (!opts.position) {\n\t            /**\n\t             * 平移\n\t             * @type {Array.<number>}\n\t             * @default [0, 0]\n\t             */\n\t            this.position = [0, 0];\n\t        }\n\t        if (opts.rotation == null) {\n\t            /**\n\t             * 旋转\n\t             * @type {Array.<number>}\n\t             * @default 0\n\t             */\n\t            this.rotation = 0;\n\t        }\n\t        if (!opts.scale) {\n\t            /**\n\t             * 缩放\n\t             * @type {Array.<number>}\n\t             * @default [1, 1]\n\t             */\n\t            this.scale = [1, 1];\n\t        }\n\t        /**\n\t         * 旋转和缩放的原点\n\t         * @type {Array.<number>}\n\t         * @default null\n\t         */\n\t        this.origin = this.origin || null;\n\t    };\n\t\n\t    var transformableProto = Transformable.prototype;\n\t    transformableProto.transform = null;\n\t\n\t    /**\n\t     * 判断是否需要有坐标变换\n\t     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n\t     */\n\t    transformableProto.needLocalTransform = function () {\n\t        return isNotAroundZero(this.rotation)\n\t            || isNotAroundZero(this.position[0])\n\t            || isNotAroundZero(this.position[1])\n\t            || isNotAroundZero(this.scale[0] - 1)\n\t            || isNotAroundZero(this.scale[1] - 1);\n\t    };\n\t\n\t    transformableProto.updateTransform = function () {\n\t        var parent = this.parent;\n\t        var parentHasTransform = parent && parent.transform;\n\t        var needLocalTransform = this.needLocalTransform();\n\t\n\t        var m = this.transform;\n\t        if (!(needLocalTransform || parentHasTransform)) {\n\t            m && mIdentity(m);\n\t            return;\n\t        }\n\t\n\t        m = m || matrix.create();\n\t\n\t        if (needLocalTransform) {\n\t            this.getLocalTransform(m);\n\t        }\n\t        else {\n\t            mIdentity(m);\n\t        }\n\t\n\t        // 应用父节点变换\n\t        if (parentHasTransform) {\n\t            if (needLocalTransform) {\n\t                matrix.mul(m, parent.transform, m);\n\t            }\n\t            else {\n\t                matrix.copy(m, parent.transform);\n\t            }\n\t        }\n\t        // 保存这个变换矩阵\n\t        this.transform = m;\n\t\n\t        this.invTransform = this.invTransform || matrix.create();\n\t        matrix.invert(this.invTransform, m);\n\t    };\n\t\n\t    transformableProto.getLocalTransform = function (m) {\n\t        m = m || [];\n\t        mIdentity(m);\n\t\n\t        var origin = this.origin;\n\t\n\t        var scale = this.scale;\n\t        var rotation = this.rotation;\n\t        var position = this.position;\n\t        if (origin) {\n\t            // Translate to origin\n\t            m[4] -= origin[0];\n\t            m[5] -= origin[1];\n\t        }\n\t        matrix.scale(m, m, scale);\n\t        if (rotation) {\n\t            matrix.rotate(m, m, rotation);\n\t        }\n\t        if (origin) {\n\t            // Translate back from origin\n\t            m[4] += origin[0];\n\t            m[5] += origin[1];\n\t        }\n\t\n\t        m[4] += position[0];\n\t        m[5] += position[1];\n\t\n\t        return m;\n\t    };\n\t    /**\n\t     * 将自己的transform应用到context上\n\t     * @param {Context2D} ctx\n\t     */\n\t    transformableProto.setTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        if (m) {\n\t            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t        }\n\t        else {\n\t            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t        }\n\t    };\n\t\n\t    transformableProto.restoreTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t    }\n\t\n\t    var tmpTransform = [];\n\t\n\t    /**\n\t     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n\t     */\n\t    transformableProto.decomposeTransform = function () {\n\t        if (!this.transform) {\n\t            return;\n\t        }\n\t        var parent = this.parent;\n\t        var m = this.transform;\n\t        if (parent && parent.transform) {\n\t            // Get local transform and decompose them to position, scale, rotation\n\t            matrix.mul(tmpTransform, parent.invTransform, m);\n\t            m = tmpTransform;\n\t        }\n\t        var sx = m[0] * m[0] + m[1] * m[1];\n\t        var sy = m[2] * m[2] + m[3] * m[3];\n\t        var position = this.position;\n\t        var scale = this.scale;\n\t        if (isNotAroundZero(sx - 1)) {\n\t            sx = Math.sqrt(sx);\n\t        }\n\t        if (isNotAroundZero(sy - 1)) {\n\t            sy = Math.sqrt(sy);\n\t        }\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        position[0] = m[4];\n\t        position[1] = m[5];\n\t        scale[0] = sx;\n\t        scale[1] = sy;\n\t        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t    };\n\t\n\t    /**\n\t     * Get global scale\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.getGlobalScale = function () {\n\t        var m = this.transform;\n\t        if (!m) {\n\t            return [1, 1];\n\t        }\n\t        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        return [sx, sy];\n\t    };\n\t    /**\n\t     * 变换坐标位置到 shape 的局部坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToLocal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var invTransform = this.invTransform;\n\t        if (invTransform) {\n\t            vector.applyTransform(v2, v2, invTransform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    /**\n\t     * 变换局部坐标位置到全局坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToGlobal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var transform = this.transform;\n\t        if (transform) {\n\t            vector.applyTransform(v2, v2, transform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    module.exports = Transformable;\n\t\n\n\n/***/ },\n/* 193 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Path = __webpack_require__(6);\n\t    var PathProxy = __webpack_require__(41);\n\t    var transformPath = __webpack_require__(194);\n\t    var matrix = __webpack_require__(27);\n\t\n\t    // command chars\n\t    var cc = [\n\t        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n\t        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n\t    ];\n\t\n\t    var mathSqrt = Math.sqrt;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var PI = Math.PI;\n\t\n\t    var vMag = function(v) {\n\t        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t    };\n\t    var vRatio = function(u, v) {\n\t        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t    };\n\t    var vAngle = function(u, v) {\n\t        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n\t                * Math.acos(vRatio(u, v));\n\t    };\n\t\n\t    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t        var psi = psiDeg * (PI / 180.0);\n\t        var xp = mathCos(psi) * (x1 - x2) / 2.0\n\t                 + mathSin(psi) * (y1 - y2) / 2.0;\n\t        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n\t                 + mathCos(psi) * (y1 - y2) / 2.0;\n\t\n\t        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\t\n\t        if (lambda > 1) {\n\t            rx *= mathSqrt(lambda);\n\t            ry *= mathSqrt(lambda);\n\t        }\n\t\n\t        var f = (fa === fs ? -1 : 1)\n\t            * mathSqrt((((rx * rx) * (ry * ry))\n\t                    - ((rx * rx) * (yp * yp))\n\t                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n\t                    + (ry * ry) * (xp * xp))\n\t                ) || 0;\n\t\n\t        var cxp = f * rx * yp / ry;\n\t        var cyp = f * -ry * xp / rx;\n\t\n\t        var cx = (x1 + x2) / 2.0\n\t                 + mathCos(psi) * cxp\n\t                 - mathSin(psi) * cyp;\n\t        var cy = (y1 + y2) / 2.0\n\t                + mathSin(psi) * cxp\n\t                + mathCos(psi) * cyp;\n\t\n\t        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n\t        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n\t        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n\t        var dTheta = vAngle(u, v);\n\t\n\t        if (vRatio(u, v) <= -1) {\n\t            dTheta = PI;\n\t        }\n\t        if (vRatio(u, v) >= 1) {\n\t            dTheta = 0;\n\t        }\n\t        if (fs === 0 && dTheta > 0) {\n\t            dTheta = dTheta - 2 * PI;\n\t        }\n\t        if (fs === 1 && dTheta < 0) {\n\t            dTheta = dTheta + 2 * PI;\n\t        }\n\t\n\t        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t    }\n\t\n\t    function createPathProxyFromString(data) {\n\t        if (!data) {\n\t            return [];\n\t        }\n\t\n\t        // command string\n\t        var cs = data.replace(/-/g, ' -')\n\t            .replace(/  /g, ' ')\n\t            .replace(/ /g, ',')\n\t            .replace(/,,/g, ',');\n\t\n\t        var n;\n\t        // create pipes so that we can split the data\n\t        for (n = 0; n < cc.length; n++) {\n\t            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t        }\n\t\n\t        // create array\n\t        var arr = cs.split('|');\n\t        // init context point\n\t        var cpx = 0;\n\t        var cpy = 0;\n\t\n\t        var path = new PathProxy();\n\t        var CMD = PathProxy.CMD;\n\t\n\t        var prevCmd;\n\t        for (n = 1; n < arr.length; n++) {\n\t            var str = arr[n];\n\t            var c = str.charAt(0);\n\t            var off = 0;\n\t            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t            var cmd;\n\t\n\t            if (p.length > 0 && p[0] === '') {\n\t                p.shift();\n\t            }\n\t\n\t            for (var i = 0; i < p.length; i++) {\n\t                p[i] = parseFloat(p[i]);\n\t            }\n\t            while (off < p.length && !isNaN(p[off])) {\n\t                if (isNaN(p[0])) {\n\t                    break;\n\t                }\n\t                var ctlPtx;\n\t                var ctlPty;\n\t\n\t                var rx;\n\t                var ry;\n\t                var psi;\n\t                var fa;\n\t                var fs;\n\t\n\t                var x1 = cpx;\n\t                var y1 = cpy;\n\t\n\t                // convert l, H, h, V, and v to L\n\t                switch (c) {\n\t                    case 'l':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'L':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'm':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'l';\n\t                        break;\n\t                    case 'M':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'L';\n\t                        break;\n\t                    case 'h':\n\t                        cpx += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'H':\n\t                        cpx = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'v':\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'V':\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'C':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n\t                        );\n\t                        cpx = p[off - 2];\n\t                        cpy = p[off - 1];\n\t                        break;\n\t                    case 'c':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy\n\t                        );\n\t                        cpx += p[off - 2];\n\t                        cpy += p[off - 1];\n\t                        break;\n\t                    case 'S':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 's':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = cpx + p[off++];\n\t                        y1 = cpy + p[off++];\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'Q':\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'q':\n\t                        x1 = p[off++] + cpx;\n\t                        y1 = p[off++] + cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'T':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 't':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 'A':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                    case 'a':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                }\n\t            }\n\t\n\t            if (c === 'z' || c === 'Z') {\n\t                cmd = CMD.Z;\n\t                path.addData(cmd);\n\t            }\n\t\n\t            prevCmd = cmd;\n\t        }\n\t\n\t        path.toStatic();\n\t\n\t        return path;\n\t    }\n\t\n\t    // TODO Optimize double memory cost problem\n\t    function createPathOptions(str, opts) {\n\t        var pathProxy = createPathProxyFromString(str);\n\t        var transform;\n\t        opts = opts || {};\n\t        opts.buildPath = function (path) {\n\t            path.setData(pathProxy.data);\n\t            transform && transformPath(path, transform);\n\t            // Svg and vml renderer don't have context\n\t            var ctx = path.getContext();\n\t            if (ctx) {\n\t                path.rebuildPath(ctx);\n\t            }\n\t        };\n\t\n\t        opts.applyTransform = function (m) {\n\t            if (!transform) {\n\t                transform = matrix.create();\n\t            }\n\t            matrix.mul(transform, m, transform);\n\t            this.dirty(true);\n\t        };\n\t\n\t        return opts;\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Create a Path object from path string data\n\t         * http://www.w3.org/TR/SVG/paths.html#PathData\n\t         * @param  {Object} opts Other options\n\t         */\n\t        createFromString: function (str, opts) {\n\t            return new Path(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Create a Path class from path string data\n\t         * @param  {string} str\n\t         * @param  {Object} opts Other options\n\t         */\n\t        extendFromString: function (str, opts) {\n\t            return Path.extend(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Merge multiple paths\n\t         */\n\t        // TODO Apply transform\n\t        // TODO stroke dash\n\t        // TODO Optimize double memory cost problem\n\t        mergePath: function (pathEls, opts) {\n\t            var pathList = [];\n\t            var len = pathEls.length;\n\t            for (var i = 0; i < len; i++) {\n\t                var pathEl = pathEls[i];\n\t                if (pathEl.__dirty) {\n\t                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t                }\n\t                pathList.push(pathEl.path);\n\t            }\n\t\n\t            var pathBundle = new Path(opts);\n\t            pathBundle.buildPath = function (path) {\n\t                path.appendPath(pathList);\n\t                // Svg and vml renderer don't have context\n\t                var ctx = path.getContext();\n\t                if (ctx) {\n\t                    path.rebuildPath(ctx);\n\t                }\n\t            };\n\t\n\t            return pathBundle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 194 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var CMD = __webpack_require__(41).CMD;\n\t    var vec2 = __webpack_require__(7);\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t\n\t    var points = [[], [], []];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAtan2 = Math.atan2;\n\t    function transformPath(path, m) {\n\t        var data = path.data;\n\t        var cmd;\n\t        var nPoint;\n\t        var i;\n\t        var j;\n\t        var k;\n\t        var p;\n\t\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var R = CMD.R;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        for (i = 0, j = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            j = i;\n\t            nPoint = 0;\n\t\n\t            switch (cmd) {\n\t                case M:\n\t                    nPoint = 1;\n\t                    break;\n\t                case L:\n\t                    nPoint = 1;\n\t                    break;\n\t                case C:\n\t                    nPoint = 3;\n\t                    break;\n\t                case Q:\n\t                    nPoint = 2;\n\t                    break;\n\t                case A:\n\t                    var x = m[4];\n\t                    var y = m[5];\n\t                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n\t                    // cx\n\t                    data[i++] += x;\n\t                    // cy\n\t                    data[i++] += y;\n\t                    // Scale rx and ry\n\t                    // FIXME Assume psi is 0 here\n\t                    data[i++] *= sx;\n\t                    data[i++] *= sy;\n\t\n\t                    // Start angle\n\t                    data[i++] += angle;\n\t                    // end angle\n\t                    data[i++] += angle;\n\t                    // FIXME psi\n\t                    i += 2;\n\t                    j = i;\n\t                    break;\n\t                case R:\n\t                    // x0, y0\n\t                    p[0] = data[i++];\n\t                    p[1] = data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t                    // x1, y1\n\t                    p[0] += data[i++];\n\t                    p[1] += data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t            }\n\t\n\t            for (k = 0; k < nPoint; k++) {\n\t                var p = points[k];\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t\n\t                v2ApplyTransform(p, p, m);\n\t                // Write back\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = transformPath;\n\n\n/***/ },\n/* 195 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * ZRender, a high performance 2d drawing library.\n\t *\n\t * Copyright (c) 2013, Baidu Inc.\n\t * All rights reserved.\n\t *\n\t * LICENSE\n\t * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n\t */\n\t// Global defines\n\t\n\t    var guid = __webpack_require__(77);\n\t    var env = __webpack_require__(14);\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var Handler = __webpack_require__(156);\n\t    var Storage = __webpack_require__(159);\n\t    var Animation = __webpack_require__(160);\n\t    var HandlerProxy = __webpack_require__(172);\n\t\n\t    var useVML = !env.canvasSupported;\n\t\n\t    var painterCtors = {\n\t        canvas: __webpack_require__(158)\n\t    };\n\t\n\t    var instances = {};    // ZRender实例map索引\n\t\n\t    var zrender = {};\n\t\n\t    /**\n\t     * @type {string}\n\t     */\n\t    zrender.version = '3.2.2';\n\t\n\t    /**\n\t     * Initializing a zrender instance\n\t     * @param {HTMLElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.init = function(dom, opts) {\n\t        var zr = new ZRender(guid(), dom, opts);\n\t        instances[zr.id] = zr;\n\t        return zr;\n\t    };\n\t\n\t    /**\n\t     * Dispose zrender instance\n\t     * @param {module:zrender/ZRender} zr\n\t     */\n\t    zrender.dispose = function (zr) {\n\t        if (zr) {\n\t            zr.dispose();\n\t        }\n\t        else {\n\t            for (var key in instances) {\n\t                if (instances.hasOwnProperty(key)) {\n\t                    instances[key].dispose();\n\t                }\n\t            }\n\t            instances = {};\n\t        }\n\t\n\t        return zrender;\n\t    };\n\t\n\t    /**\n\t     * Get zrender instance by id\n\t     * @param {string} id zrender instance id\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.getInstance = function (id) {\n\t        return instances[id];\n\t    };\n\t\n\t    zrender.registerPainter = function (name, Ctor) {\n\t        painterCtors[name] = Ctor;\n\t    };\n\t\n\t    function delInstance(id) {\n\t        delete instances[id];\n\t    }\n\t\n\t    /**\n\t     * @module zrender/ZRender\n\t     */\n\t    /**\n\t     * @constructor\n\t     * @alias module:zrender/ZRender\n\t     * @param {string} id\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     */\n\t    var ZRender = function(id, dom, opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         */\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id = id;\n\t\n\t        var self = this;\n\t        var storage = new Storage();\n\t\n\t        var rendererType = opts.renderer;\n\t        if (useVML) {\n\t            if (!painterCtors.vml) {\n\t                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t            }\n\t            rendererType = 'vml';\n\t        }\n\t        else if (!rendererType || !painterCtors[rendererType]) {\n\t            rendererType = 'canvas';\n\t        }\n\t        var painter = new painterCtors[rendererType](dom, storage, opts);\n\t\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t\n\t        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\t\n\t        /**\n\t         * @type {module:zrender/animation/Animation}\n\t         */\n\t        this.animation = new Animation({\n\t            stage: {\n\t                update: zrUtil.bind(this.flush, this)\n\t            }\n\t        });\n\t        this.animation.start();\n\t\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._needsRefresh;\n\t\n\t        // 修改 storage.delFromMap, 每次删除元素之前删除动画\n\t        // FIXME 有点ugly\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t\n\t            oldDelFromMap.call(storage, elId);\n\t\n\t            el && el.removeSelfFromZr(self);\n\t        };\n\t\n\t        storage.addToMap = function (el) {\n\t            oldAddToMap.call(storage, el);\n\t\n\t            el.addSelfToZr(self);\n\t        };\n\t    };\n\t\n\t    ZRender.prototype = {\n\t\n\t        constructor: ZRender,\n\t        /**\n\t         * 获取实例唯一标识\n\t         * @return {string}\n\t         */\n\t        getId: function () {\n\t            return this.id;\n\t        },\n\t\n\t        /**\n\t         * 添加元素\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        add: function (el) {\n\t            this.storage.addRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * 删除元素\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        remove: function (el) {\n\t            this.storage.delRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Change configuration of layer\n\t         * @param {string} zLevel\n\t         * @param {Object} config\n\t         * @param {string} [config.clearColor=0] Clear color\n\t         * @param {string} [config.motionBlur=false] If enable motion blur\n\t         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n\t        */\n\t        configLayer: function (zLevel, config) {\n\t            this.painter.configLayer(zLevel, config);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Repaint the canvas immediately\n\t         */\n\t        refreshImmediately: function () {\n\t            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t            // Or it will cause zrender refreshes again and again.\n\t            this._needsRefresh = false;\n\t            this.painter.refresh();\n\t            /**\n\t             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t             */\n\t            this._needsRefresh = false;\n\t        },\n\t\n\t        /**\n\t         * Mark and repaint the canvas in the next frame of browser\n\t         */\n\t        refresh: function() {\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Perform all refresh\n\t         */\n\t        flush: function () {\n\t            if (this._needsRefresh) {\n\t                this.refreshImmediately();\n\t            }\n\t            if (this._needsRefreshHover) {\n\t                this.refreshHoverImmediately();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element to hover layer\n\t         * @param  {module:zrender/Element} el\n\t         * @param {Object} style\n\t         */\n\t        addHover: function (el, style) {\n\t            if (this.painter.addHover) {\n\t                this.painter.addHover(el, style);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element from hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        removeHover: function (el) {\n\t            if (this.painter.removeHover) {\n\t                this.painter.removeHover(el);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clear all hover elements in hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        clearHover: function () {\n\t            if (this.painter.clearHover) {\n\t                this.painter.clearHover();\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Refresh hover in next frame\n\t         */\n\t        refreshHover: function () {\n\t            this._needsRefreshHover = true;\n\t        },\n\t\n\t        /**\n\t         * Refresh hover immediately\n\t         */\n\t        refreshHoverImmediately: function () {\n\t            this._needsRefreshHover = false;\n\t            this.painter.refreshHover && this.painter.refreshHover();\n\t        },\n\t\n\t        /**\n\t         * Resize the canvas.\n\t         * Should be invoked when container size is changed\n\t         * @param {Object} [opts]\n\t         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t         */\n\t        resize: function(opts) {\n\t            opts = opts || {};\n\t            this.painter.resize(opts.width, opts.height);\n\t            this.handler.resize();\n\t        },\n\t\n\t        /**\n\t         * Stop and clear all animation immediately\n\t         */\n\t        clearAnimation: function () {\n\t            this.animation.clear();\n\t        },\n\t\n\t        /**\n\t         * Get container width\n\t         */\n\t        getWidth: function() {\n\t            return this.painter.getWidth();\n\t        },\n\t\n\t        /**\n\t         * Get container height\n\t         */\n\t        getHeight: function() {\n\t            return this.painter.getHeight();\n\t        },\n\t\n\t        /**\n\t         * Export the canvas as Base64 URL\n\t         * @param {string} type\n\t         * @param {string} [backgroundColor='#fff']\n\t         * @return {string} Base64 URL\n\t         */\n\t        // toDataURL: function(type, backgroundColor) {\n\t        //     return this.painter.getRenderedCanvas({\n\t        //         backgroundColor: backgroundColor\n\t        //     }).toDataURL(type);\n\t        // },\n\t\n\t        /**\n\t         * Converting a path to image.\n\t         * It has much better performance of drawing image rather than drawing a vector path.\n\t         * @param {module:zrender/graphic/Path} e\n\t         * @param {number} width\n\t         * @param {number} height\n\t         */\n\t        pathToImage: function(e, width, height) {\n\t            var id = guid();\n\t            return this.painter.pathToImage(id, e, width, height);\n\t        },\n\t\n\t        /**\n\t         * Set default cursor\n\t         * @param {string} [cursorStyle='default'] 例如 crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            this.handler.setCursorStyle(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * Bind event\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {Function} eventHandler Handler function\n\t         * @param {Object} [context] Context object\n\t         */\n\t        on: function(eventName, eventHandler, context) {\n\t            this.handler.on(eventName, eventHandler, context);\n\t        },\n\t\n\t        /**\n\t         * Unbind event\n\t         * @param {string} eventName Event name\n\t         * @param {Function} [eventHandler] Handler function\n\t         */\n\t        off: function(eventName, eventHandler) {\n\t            this.handler.off(eventName, eventHandler);\n\t        },\n\t\n\t        /**\n\t         * Trigger event manually\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {event=} event Event object\n\t         */\n\t        trigger: function (eventName, event) {\n\t            this.handler.trigger(eventName, event);\n\t        },\n\t\n\t\n\t        /**\n\t         * Clear all objects and the canvas.\n\t         */\n\t        clear: function () {\n\t            this.storage.delRoot();\n\t            this.painter.clear();\n\t        },\n\t\n\t        /**\n\t         * Dispose self.\n\t         */\n\t        dispose: function () {\n\t            this.animation.stop();\n\t\n\t            this.clear();\n\t            this.storage.dispose();\n\t            this.painter.dispose();\n\t            this.handler.dispose();\n\t\n\t            this.animation =\n\t            this.storage =\n\t            this.painter =\n\t            this.handler = null;\n\t\n\t            delInstance(this.id);\n\t        }\n\t    };\n\t\n\t    module.exports = zrender;\n\t\n\n\n/***/ },\n/* 196 */,\n/* 197 */,\n/* 198 */,\n/* 199 */,\n/* 200 */,\n/* 201 */,\n/* 202 */,\n/* 203 */,\n/* 204 */,\n/* 205 */,\n/* 206 */,\n/* 207 */,\n/* 208 */,\n/* 209 */,\n/* 210 */,\n/* 211 */,\n/* 212 */,\n/* 213 */,\n/* 214 */,\n/* 215 */,\n/* 216 */,\n/* 217 */,\n/* 218 */,\n/* 219 */,\n/* 220 */,\n/* 221 */,\n/* 222 */,\n/* 223 */,\n/* 224 */,\n/* 225 */,\n/* 226 */,\n/* 227 */,\n/* 228 */,\n/* 229 */,\n/* 230 */,\n/* 231 */,\n/* 232 */,\n/* 233 */,\n/* 234 */,\n/* 235 */,\n/* 236 */,\n/* 237 */,\n/* 238 */,\n/* 239 */,\n/* 240 */,\n/* 241 */,\n/* 242 */,\n/* 243 */,\n/* 244 */,\n/* 245 */,\n/* 246 */,\n/* 247 */,\n/* 248 */,\n/* 249 */,\n/* 250 */,\n/* 251 */,\n/* 252 */,\n/* 253 */,\n/* 254 */,\n/* 255 */,\n/* 256 */,\n/* 257 */,\n/* 258 */,\n/* 259 */,\n/* 260 */,\n/* 261 */,\n/* 262 */,\n/* 263 */,\n/* 264 */,\n/* 265 */,\n/* 266 */,\n/* 267 */,\n/* 268 */,\n/* 269 */,\n/* 270 */,\n/* 271 */,\n/* 272 */,\n/* 273 */,\n/* 274 */,\n/* 275 */,\n/* 276 */,\n/* 277 */,\n/* 278 */,\n/* 279 */,\n/* 280 */,\n/* 281 */,\n/* 282 */,\n/* 283 */,\n/* 284 */,\n/* 285 */,\n/* 286 */,\n/* 287 */,\n/* 288 */,\n/* 289 */,\n/* 290 */,\n/* 291 */,\n/* 292 */,\n/* 293 */,\n/* 294 */,\n/* 295 */,\n/* 296 */,\n/* 297 */,\n/* 298 */,\n/* 299 */,\n/* 300 */,\n/* 301 */,\n/* 302 */,\n/* 303 */,\n/* 304 */,\n/* 305 */,\n/* 306 */,\n/* 307 */,\n/* 308 */,\n/* 309 */,\n/* 310 */,\n/* 311 */,\n/* 312 */,\n/* 313 */,\n/* 314 */,\n/* 315 */,\n/* 316 */,\n/* 317 */,\n/* 318 */,\n/* 319 */,\n/* 320 */,\n/* 321 */,\n/* 322 */,\n/* 323 */,\n/* 324 */,\n/* 325 */,\n/* 326 */,\n/* 327 */,\n/* 328 */,\n/* 329 */,\n/* 330 */,\n/* 331 */,\n/* 332 */,\n/* 333 */,\n/* 334 */,\n/* 335 */,\n/* 336 */,\n/* 337 */,\n/* 338 */,\n/* 339 */,\n/* 340 */,\n/* 341 */,\n/* 342 */,\n/* 343 */,\n/* 344 */,\n/* 345 */,\n/* 346 */,\n/* 347 */,\n/* 348 */,\n/* 349 */,\n/* 350 */,\n/* 351 */,\n/* 352 */,\n/* 353 */,\n/* 354 */,\n/* 355 */,\n/* 356 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _lodash = __webpack_require__(19);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tvar _vue = __webpack_require__(16);\n\t\n\tvar _vue2 = _interopRequireDefault(_vue);\n\t\n\tvar _echarts = __webpack_require__(5);\n\t\n\tvar _echarts2 = _interopRequireDefault(_echarts);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t__webpack_require__(426);\n\t__webpack_require__(131);\n\t__webpack_require__(115);\n\t__webpack_require__(110);\n\t\n\texports.default = {\n\t  props: ['chartOption'],\n\t  data: function data() {\n\t    return {\n\t      chart: null\n\t    };\n\t  },\n\t  mounted: function mounted() {\n\t    this.chart = _echarts2.default.init(this.$refs.echart);\n\t    var option = {\n\t      tooltip: {\n\t        show: true,\n\t        trigger: 'item',\n\t        formatter: function formatter(params, ticket, callback) {\n\t          return '<div style=\"text-align:center; font-size:14px;\">' + params.name + '<br/>' + _vue2.default.filter('ktCurrency')(params.value) + '(' + params.percent + '%)' + '</div>';\n\t        }\n\t      },\n\t      color: ['#21a9e1', '#35cbef', '#1fdab1', '#92e68d'],\n\t      legend: {\n\t        orient: 'vertical',\n\t        x: '20px',\n\t        left: '0px',\n\t        top: 'center',\n\t\n\t        data: [],\n\t        textStyle: {\n\t          fontSize: 14,\n\t          color: '#262c38' },\n\t        itemWidth: 16,\n\t        itemHeight: 16,\n\t        itemGap: 20\n\t      },\n\t      series: [{\n\t        name: '',\n\t        type: 'pie',\n\t        center: ['70%', '50%'],\n\t        radius: ['50%', '80%'],\n\t        avoidLabelOverlap: false,\n\t        label: {\n\t          normal: {\n\t            show: false,\n\t            position: 'center'\n\t          },\n\t          emphasis: {\n\t            show: true,\n\t            textStyle: {\n\t              fontSize: '25',\n\t              fontWeight: 'bold'\n\t            }\n\t          }\n\t        },\n\t        labelLine: {\n\t          normal: {\n\t            show: false\n\t          }\n\t        },\n\t        data: []\n\t      }]\n\t    };\n\t\n\t    this.chart.setOption(_lodash2.default.merge({}, option, this.chartOption));\n\t  },\n\t\n\t\n\t  watch: {\n\t    chartOption: function chartOption() {\n\t      this.chart.setOption(this.chartOption);\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 357 */,\n/* 358 */,\n/* 359 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _promise = __webpack_require__(97);\n\t\n\tvar _promise2 = _interopRequireDefault(_promise);\n\t\n\tvar _loading = __webpack_require__(38);\n\t\n\tvar _loading2 = _interopRequireDefault(_loading);\n\t\n\tvar _loading3 = __webpack_require__(37);\n\t\n\tvar _loading4 = _interopRequireDefault(_loading3);\n\t\n\tvar _tooltip = __webpack_require__(148);\n\t\n\tvar _tooltip2 = _interopRequireDefault(_tooltip);\n\t\n\tvar _base = __webpack_require__(52);\n\t\n\tvar _base2 = _interopRequireDefault(_base);\n\t\n\tvar _tooltip3 = __webpack_require__(144);\n\t\n\tvar _tooltip4 = _interopRequireDefault(_tooltip3);\n\t\n\tvar _lodash = __webpack_require__(19);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tvar _resources = __webpack_require__(56);\n\t\n\tvar _ktPieEchart = __webpack_require__(490);\n\t\n\tvar _ktPieEchart2 = _interopRequireDefault(_ktPieEchart);\n\t\n\tvar _mixin = __webpack_require__(64);\n\t\n\tvar _mixin2 = _interopRequireDefault(_mixin);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  mixins: [_mixin2.default],\n\t  components: {\n\t    KtPieEchart: _ktPieEchart2.default,\n\t    ElTooltip: _tooltip4.default\n\t  },\n\t\n\t  methods: {\n\t    toDetails: function toDetails(product) {\n\t      this.$router.push({\n\t        name: 'productDashboard',\n\t        params: {\n\t          id: product.id,\n\t          name: product.name\n\t        }\n\t      });\n\t    },\n\t    subsistGet: function subsistGet() {\n\t      var _this = this;\n\t\n\t      return _resources.subsist.get().then(function (res) {\n\t        return res.json();\n\t      }).then(function (data) {\n\t        _this.balance = data.balance;\n\t      });\n\t    },\n\t    stockGet: function stockGet() {\n\t      var _this2 = this;\n\t\n\t      return _resources.stock.get().then(function (res) {\n\t        return res.json();\n\t      }).then(function (data) {\n\t        _this2.pieChartOption = _lodash2.default.merge({}, _this2.pieChartOption, {\n\t          legend: {\n\t            data: _lodash2.default.map(data.balance.by_consignee, 'consignee')\n\t          },\n\t          series: [{\n\t            name: '',\n\t            type: 'pie',\n\t            center: ['70%', '50%'],\n\t            radius: ['50%', '80%'],\n\t            avoidLabelOverlap: false,\n\t            label: {\n\t              normal: {\n\t                show: false,\n\t                position: 'center'\n\t              },\n\t              emphasis: {\n\t                show: true,\n\t                textStyle: {\n\t                  fontSize: '25',\n\t                  fontWeight: 'bold'\n\t                }\n\t              }\n\t            },\n\t            labelLine: {\n\t              normal: {\n\t                show: false\n\t              }\n\t            },\n\t            data: _lodash2.default.map(data.balance.by_consignee, function (v) {\n\t              return {\n\t                name: v.consignee,\n\t                value: v.balance\n\t              };\n\t            })\n\t          }]\n\t        });\n\t      });\n\t    },\n\t    liquidationGet: function liquidationGet() {\n\t      var _this3 = this;\n\t\n\t      return _resources.liquidation.get().then(function (res) {\n\t        return res.json();\n\t      }).then(function (data) {\n\t        _this3.summary = data.summary;\n\t        _this3.virtualAssets = _lodash2.default.groupBy(data.virtual_assets, function (v) {\n\t          return v.consignee;\n\t        });\n\t      });\n\t    }\n\t  },\n\t\n\t  mounted: function mounted() {\n\t    var _this4 = this;\n\t\n\t    this.instLoading = _loading4.default.service({\n\t      target: '.overview'\n\t    });\n\t\n\t    _promise2.default.all([this.subsistGet(), this.stockGet(), this.liquidationGet()]).then(function () {\n\t      _this4.instLoading.close();\n\t    }).catch(function (res) {\n\t      _this4.instLoading.close();\n\t    });\n\t  },\n\t  data: function data() {\n\t    return {\n\t      balance: '',\n\t      pieChartOption: {},\n\t      summary: '',\n\t      virtualAssets: ''\n\t    };\n\t  }\n\t};\n\n/***/ },\n/* 360 */,\n/* 361 */,\n/* 362 */,\n/* 363 */,\n/* 364 */,\n/* 365 */,\n/* 366 */,\n/* 367 */,\n/* 368 */,\n/* 369 */,\n/* 370 */,\n/* 371 */,\n/* 372 */,\n/* 373 */,\n/* 374 */,\n/* 375 */,\n/* 376 */,\n/* 377 */,\n/* 378 */,\n/* 379 */,\n/* 380 */,\n/* 381 */,\n/* 382 */,\n/* 383 */,\n/* 384 */,\n/* 385 */,\n/* 386 */,\n/* 387 */,\n/* 388 */,\n/* 389 */,\n/* 390 */,\n/* 391 */,\n/* 392 */,\n/* 393 */,\n/* 394 */,\n/* 395 */,\n/* 396 */,\n/* 397 */,\n/* 398 */,\n/* 399 */,\n/* 400 */,\n/* 401 */,\n/* 402 */,\n/* 403 */,\n/* 404 */,\n/* 405 */,\n/* 406 */,\n/* 407 */,\n/* 408 */,\n/* 409 */,\n/* 410 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(3)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".fl{float:left}.fr{float:right}.overview{background:#ecf1f7}.overview h2{margin-bottom:10px;font-size:17px}.today-overview{overflow:hidden}.today-overview .overview-left,.today-overview .overview-right{border-radius:4px;background:#fff;padding:10px;width:49.5%}.today-overview .overview-left h3{background:#ecf1f7;height:40px;line-height:40px;font-size:14px;text-indent:10px;border-radius:4px}.today-overview .overview-left .overview-left-middle{height:164px;line-height:164px;text-align:center;border-bottom:1px solid #ecf1f7}.today-overview .overview-left .overview-left-middle i{font-size:57px;color:#eef1f3;display:inline-block;vertical-align:middle}.today-overview .overview-left .overview-left-middle span{position:relative;font-size:35px;color:#66cebe;margin-left:35px;margin-top:3px;vertical-align:middle}.today-overview .overview-left .overview-left-middle span:before{content:\\\"\\\\FFE5\\\";font-size:30px;color:#c4c4c4;margin-right:10px;margin-top:5px}.today-overview .overview-left .overview-left-down{height:72px;line-height:72px;overflow:hidden;padding:0 10px}.today-overview .overview-left .overview-left-down .Principal span{font-size:14px}.today-overview .overview-left .overview-left-down .Principal em{font-style:normal;color:#66cebe;margin-left:8px}.today-overview .overview-left .overview-left-down .Principal em:before{content:\\\"\\\\FFE5\\\";font-size:13px;color:#c4c4c4;margin-right:7px}.today-overview .overview-left .overview-left-down .Interest span{font-size:14px}.today-overview .overview-left .overview-left-down .Interest em{font-style:normal;color:#66cebe;margin-left:8px}.today-overview .overview-left .overview-left-down .Interest em:before{content:\\\"\\\\FFE5\\\";font-size:13px;color:#c4c4c4;margin-right:7px}.today-overview .overview-right h3{background:#ecf1f7;height:40px;line-height:40px;font-size:14px;text-indent:10px;border-radius:4px}.today-overview .overview-right .overview-right-middle{height:237px}.today-square{margin-top:25px}.today-square h2 i{font-size:15px;color:#b4becf;margin-left:5px}.today-square h2 .information{font-size:13px}.today-square h2 .information span{color:#54c9b8}.today-square h2 .information em{font-style:normal}.overview-table{max-height:500px;overflow-y:scroll}\", \"\", {\"version\":3,\"sources\":[\"/./src/views/ex/dashboard.vue\"],\"names\":[],\"mappings\":\"AACA,IAAI,UAAU,CACb,AACD,IAAI,WAAW,CACd,AACD,UAAU,kBAAkB,CAC3B,AACD,aAAa,mBAAmB,cAAc,CAC7C,AACD,gBAAgB,eAAe,CAC9B,AACD,+DAA+D,kBAAkB,gBAAgB,aAAa,WAAW,CACxH,AACD,kCAAkC,mBAAmB,YAAY,iBAAiB,eAAe,iBAAiB,iBAAiB,CAClI,AACD,qDAAqD,aAAa,kBAAkB,kBAAkB,+BAA+B,CACpI,AACD,uDAAuD,eAAe,cAAc,qBAAqB,qBAAqB,CAC7H,AACD,0DAA0D,kBAAkB,eAAe,cAAc,iBAAiB,eAAe,qBAAqB,CAC7J,AACD,iEAAiE,gBAAY,eAAe,cAAc,kBAAkB,cAAc,CACzI,AACD,mDAAmD,YAAY,iBAAiB,gBAAgB,cAAc,CAC7G,AACD,mEAAmE,cAAc,CAChF,AACD,iEAAiE,kBAAkB,cAAc,eAAe,CAC/G,AACD,wEAAwE,gBAAY,eAAe,cAAc,gBAAgB,CAChI,AACD,kEAAkE,cAAc,CAC/E,AACD,gEAAgE,kBAAkB,cAAc,eAAe,CAC9G,AACD,uEAAuE,gBAAY,eAAe,cAAc,gBAAgB,CAC/H,AACD,mCAAmC,mBAAmB,YAAY,iBAAiB,eAAe,iBAAiB,iBAAiB,CACnI,AACD,uDAAuD,YAAY,CAClE,AACD,cAAc,eAAe,CAC5B,AACD,mBAAmB,eAAe,cAAc,eAAe,CAC9D,AACD,8BAA8B,cAAc,CAC3C,AACD,mCAAmC,aAAa,CAC/C,AACD,iCAAiC,iBAAiB,CACjD,AACD,gBAAgB,iBAAiB,iBAAiB,CACjD\",\"file\":\"dashboard.vue\",\"sourcesContent\":[\"\\n.fl{float:left\\n}\\n.fr{float:right\\n}\\n.overview{background:#ecf1f7\\n}\\n.overview h2{margin-bottom:10px;font-size:17px\\n}\\n.today-overview{overflow:hidden\\n}\\n.today-overview .overview-left,.today-overview .overview-right{border-radius:4px;background:#fff;padding:10px;width:49.5%\\n}\\n.today-overview .overview-left h3{background:#ecf1f7;height:40px;line-height:40px;font-size:14px;text-indent:10px;border-radius:4px\\n}\\n.today-overview .overview-left .overview-left-middle{height:164px;line-height:164px;text-align:center;border-bottom:1px solid #ecf1f7\\n}\\n.today-overview .overview-left .overview-left-middle i{font-size:57px;color:#eef1f3;display:inline-block;vertical-align:middle\\n}\\n.today-overview .overview-left .overview-left-middle span{position:relative;font-size:35px;color:#66cebe;margin-left:35px;margin-top:3px;vertical-align:middle\\n}\\n.today-overview .overview-left .overview-left-middle span:before{content:\\\"￥\\\";font-size:30px;color:#c4c4c4;margin-right:10px;margin-top:5px\\n}\\n.today-overview .overview-left .overview-left-down{height:72px;line-height:72px;overflow:hidden;padding:0 10px\\n}\\n.today-overview .overview-left .overview-left-down .Principal span{font-size:14px\\n}\\n.today-overview .overview-left .overview-left-down .Principal em{font-style:normal;color:#66cebe;margin-left:8px\\n}\\n.today-overview .overview-left .overview-left-down .Principal em:before{content:\\\"￥\\\";font-size:13px;color:#c4c4c4;margin-right:7px\\n}\\n.today-overview .overview-left .overview-left-down .Interest span{font-size:14px\\n}\\n.today-overview .overview-left .overview-left-down .Interest em{font-style:normal;color:#66cebe;margin-left:8px\\n}\\n.today-overview .overview-left .overview-left-down .Interest em:before{content:\\\"￥\\\";font-size:13px;color:#c4c4c4;margin-right:7px\\n}\\n.today-overview .overview-right h3{background:#ecf1f7;height:40px;line-height:40px;font-size:14px;text-indent:10px;border-radius:4px\\n}\\n.today-overview .overview-right .overview-right-middle{height:237px\\n}\\n.today-square{margin-top:25px\\n}\\n.today-square h2 i{font-size:15px;color:#b4becf;margin-left:5px\\n}\\n.today-square h2 .information{font-size:13px\\n}\\n.today-square h2 .information span{color:#54c9b8\\n}\\n.today-square h2 .information em{font-style:normal\\n}\\n.overview-table{max-height:500px;overflow-y:scroll\\n}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\t\n\t// exports\n\n\n/***/ },\n/* 411 */,\n/* 412 */,\n/* 413 */,\n/* 414 */,\n/* 415 */,\n/* 416 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(3)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".pie-echarts{min-width:400px;width:400px;height:237px;margin:0 auto}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/kt-pie-echart.vue\"],\"names\":[],\"mappings\":\"AACA,aAAc,gBAAgB,AAAC,YAAY,AAAC,aAAa,AAAC,aAAc,CACvE\",\"file\":\"kt-pie-echart.vue\",\"sourcesContent\":[\"\\n.pie-echarts{ min-width:400px; width:400px; height:237px; margin:0 auto;\\n}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\t\n\t// exports\n\n\n/***/ },\n/* 417 */,\n/* 418 */,\n/* 419 */,\n/* 420 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var echarts = __webpack_require__(5);\n\t    var zrUtil = __webpack_require__(1);\n\t    module.exports = function (seriesType, actionInfos) {\n\t        zrUtil.each(actionInfos, function (actionInfo) {\n\t            actionInfo.update = 'updateView';\n\t            /**\n\t             * @payload\n\t             * @property {string} seriesName\n\t             * @property {string} name\n\t             */\n\t            echarts.registerAction(actionInfo, function (payload, ecModel) {\n\t                var selected = {};\n\t                ecModel.eachComponent(\n\t                    {mainType: 'series', subType: seriesType, query: payload},\n\t                    function (seriesModel) {\n\t                        if (seriesModel[actionInfo.method]) {\n\t                            seriesModel[actionInfo.method](payload.name);\n\t                        }\n\t                        var data = seriesModel.getData();\n\t                        // Create selected map\n\t                        data.each(function (idx) {\n\t                            var name = data.getName(idx);\n\t                            selected[name] = seriesModel.isSelected(name) || false;\n\t                        });\n\t                    }\n\t                );\n\t                return {\n\t                    name: payload.name,\n\t                    selected: selected\n\t                };\n\t            });\n\t        });\n\t    };\n\n\n/***/ },\n/* 421 */,\n/* 422 */,\n/* 423 */,\n/* 424 */,\n/* 425 */,\n/* 426 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var echarts = __webpack_require__(5);\n\t\n\t    __webpack_require__(427);\n\t    __webpack_require__(428);\n\t\n\t    __webpack_require__(420)('pie', [{\n\t        type: 'pieToggleSelect',\n\t        event: 'pieselectchanged',\n\t        method: 'toggleSelected'\n\t    }, {\n\t        type: 'pieSelect',\n\t        event: 'pieselected',\n\t        method: 'select'\n\t    }, {\n\t        type: 'pieUnSelect',\n\t        event: 'pieunselected',\n\t        method: 'unSelect'\n\t    }]);\n\t\n\t    echarts.registerVisual(zrUtil.curry(__webpack_require__(449), 'pie'));\n\t\n\t    echarts.registerLayout(zrUtil.curry(\n\t        __webpack_require__(430), 'pie'\n\t    ));\n\t\n\t    echarts.registerProcessor(zrUtil.curry(__webpack_require__(445), 'pie'));\n\n\n/***/ },\n/* 427 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var List = __webpack_require__(71);\n\t    var zrUtil = __webpack_require__(1);\n\t    var modelUtil = __webpack_require__(11);\n\t    var completeDimensions = __webpack_require__(121);\n\t\n\t    var dataSelectableMixin = __webpack_require__(433);\n\t\n\t    var PieSeries = __webpack_require__(5).extendSeriesModel({\n\t\n\t        type: 'series.pie',\n\t\n\t        // Overwrite\n\t        init: function (option) {\n\t            PieSeries.superApply(this, 'init', arguments);\n\t\n\t            // Enable legend selection for each data item\n\t            // Use a function instead of direct access because data reference may changed\n\t            this.legendDataProvider = function () {\n\t                return this._dataBeforeProcessed;\n\t            };\n\t\n\t            this.updateSelectedMap(option.data);\n\t\n\t            this._defaultLabelLine(option);\n\t        },\n\t\n\t        // Overwrite\n\t        mergeOption: function (newOption) {\n\t            PieSeries.superCall(this, 'mergeOption', newOption);\n\t            this.updateSelectedMap(this.option.data);\n\t        },\n\t\n\t        getInitialData: function (option, ecModel) {\n\t            var dimensions = completeDimensions(['value'], option.data);\n\t            var list = new List(dimensions, this);\n\t            list.initData(option.data);\n\t            return list;\n\t        },\n\t\n\t        // Overwrite\n\t        getDataParams: function (dataIndex) {\n\t            var data = this._data;\n\t            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n\t            var sum = data.getSum('value');\n\t            // FIXME toFixed?\n\t            //\n\t            // Percent is 0 if sum is 0\n\t            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\t\n\t            params.$vars.push('percent');\n\t            return params;\n\t        },\n\t\n\t        _defaultLabelLine: function (option) {\n\t            // Extend labelLine emphasis\n\t            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\t\n\t            var labelLineNormalOpt = option.labelLine.normal;\n\t            var labelLineEmphasisOpt = option.labelLine.emphasis;\n\t            // Not show label line if `label.normal.show = false`\n\t            labelLineNormalOpt.show = labelLineNormalOpt.show\n\t                && option.label.normal.show;\n\t            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n\t                && option.label.emphasis.show;\n\t        },\n\t\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 2,\n\t            legendHoverLink: true,\n\t\n\t            hoverAnimation: true,\n\t            // 默认全局居中\n\t            center: ['50%', '50%'],\n\t            radius: [0, '75%'],\n\t            // 默认顺时针\n\t            clockwise: true,\n\t            startAngle: 90,\n\t            // 最小角度改为0\n\t            minAngle: 0,\n\t            // 选中是扇区偏移量\n\t            selectedOffset: 10,\n\t\n\t            // If use strategy to avoid label overlapping\n\t            avoidLabelOverlap: true,\n\t            // 选择模式，默认关闭，可选single，multiple\n\t            // selectedMode: false,\n\t            // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）\n\t            // roseType: null,\n\t\n\t            label: {\n\t                normal: {\n\t                    // If rotate around circle\n\t                    rotate: false,\n\t                    show: true,\n\t                    // 'outer', 'inside', 'center'\n\t                    position: 'outer'\n\t                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n\t                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n\t                    // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数\n\t                },\n\t                emphasis: {}\n\t            },\n\t            // Enabled when label.normal.position is 'outer'\n\t            labelLine: {\n\t                normal: {\n\t                    show: true,\n\t                    // 引导线两段中的第一段长度\n\t                    length: 15,\n\t                    // 引导线两段中的第二段长度\n\t                    length2: 15,\n\t                    smooth: false,\n\t                    lineStyle: {\n\t                        // color: 各异,\n\t                        width: 1,\n\t                        type: 'solid'\n\t                    }\n\t                }\n\t            },\n\t            itemStyle: {\n\t                normal: {\n\t                    borderWidth: 1\n\t                },\n\t                emphasis: {}\n\t            },\n\t\n\t            animationEasing: 'cubicOut',\n\t\n\t            data: []\n\t        }\n\t    });\n\t\n\t    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\t\n\t    module.exports = PieSeries;\n\n\n/***/ },\n/* 428 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var graphic = __webpack_require__(10);\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    /**\n\t     * @param {module:echarts/model/Series} seriesModel\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n\t        var data = seriesModel.getData();\n\t        var dataIndex = this.dataIndex;\n\t        var name = data.getName(dataIndex);\n\t        var selectedOffset = seriesModel.get('selectedOffset');\n\t\n\t        api.dispatchAction({\n\t            type: 'pieToggleSelect',\n\t            from: uid,\n\t            name: name,\n\t            seriesId: seriesModel.id\n\t        });\n\t\n\t        data.each(function (idx) {\n\t            toggleItemSelected(\n\t                data.getItemGraphicEl(idx),\n\t                data.getItemLayout(idx),\n\t                seriesModel.isSelected(data.getName(idx)),\n\t                selectedOffset,\n\t                hasAnimation\n\t            );\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @param {module:zrender/graphic/Sector} el\n\t     * @param {Object} layout\n\t     * @param {boolean} isSelected\n\t     * @param {number} selectedOffset\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n\t        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t\n\t        var dx = Math.cos(midAngle);\n\t        var dy = Math.sin(midAngle);\n\t\n\t        var offset = isSelected ? selectedOffset : 0;\n\t        var position = [dx * offset, dy * offset];\n\t\n\t        hasAnimation\n\t            // animateTo will stop revious animation like update transition\n\t            ? el.animate()\n\t                .when(200, {\n\t                    position: position\n\t                })\n\t                .start('bounceOut')\n\t            : el.attr('position', position);\n\t    }\n\t\n\t    /**\n\t     * Piece of pie including Sector, Label, LabelLine\n\t     * @constructor\n\t     * @extends {module:zrender/graphic/Group}\n\t     */\n\t    function PiePiece(data, idx) {\n\t\n\t        graphic.Group.call(this);\n\t\n\t        var sector = new graphic.Sector({\n\t            z2: 2\n\t        });\n\t        var polyline = new graphic.Polyline();\n\t        var text = new graphic.Text();\n\t        this.add(sector);\n\t        this.add(polyline);\n\t        this.add(text);\n\t\n\t        this.updateData(data, idx, true);\n\t\n\t        // Hover to change label and labelLine\n\t        function onEmphasis() {\n\t            polyline.ignore = polyline.hoverIgnore;\n\t            text.ignore = text.hoverIgnore;\n\t        }\n\t        function onNormal() {\n\t            polyline.ignore = polyline.normalIgnore;\n\t            text.ignore = text.normalIgnore;\n\t        }\n\t        this.on('emphasis', onEmphasis)\n\t            .on('normal', onNormal)\n\t            .on('mouseover', onEmphasis)\n\t            .on('mouseout', onNormal);\n\t    }\n\t\n\t    var piePieceProto = PiePiece.prototype;\n\t\n\t    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t        return {\n\t            fill: textStyleModel.getTextColor()\n\t                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n\t            opacity: data.getItemVisual(idx, 'opacity'),\n\t            textFont: textStyleModel.getFont(),\n\t            text: zrUtil.retrieve(\n\t                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)\n\t            )\n\t        };\n\t    }\n\t\n\t    piePieceProto.updateData = function (data, idx, firstCreate) {\n\t\n\t        var sector = this.childAt(0);\n\t\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var sectorShape = zrUtil.extend({}, layout);\n\t        sectorShape.label = null;\n\t        if (firstCreate) {\n\t            sector.setShape(sectorShape);\n\t            sector.shape.endAngle = layout.startAngle;\n\t            graphic.updateProps(sector, {\n\t                shape: {\n\t                    endAngle: layout.endAngle\n\t                }\n\t            }, seriesModel, idx);\n\t        }\n\t        else {\n\t            graphic.updateProps(sector, {\n\t                shape: sectorShape\n\t            }, seriesModel, idx);\n\t        }\n\t\n\t        // Update common style\n\t        var itemStyleModel = itemModel.getModel('itemStyle');\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t\n\t        sector.useStyle(\n\t            zrUtil.defaults(\n\t                {\n\t                    lineJoin: 'bevel',\n\t                    fill: visualColor\n\t                },\n\t                itemStyleModel.getModel('normal').getItemStyle()\n\t            )\n\t        );\n\t        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\t\n\t        // Toggle selected\n\t        toggleItemSelected(\n\t            this,\n\t            data.getItemLayout(idx),\n\t            itemModel.get('selected'),\n\t            seriesModel.get('selectedOffset'),\n\t            seriesModel.get('animation')\n\t        );\n\t\n\t        function onEmphasis() {\n\t            // Sector may has animation of updating data. Force to move to the last frame\n\t            // Or it may stopped on the wrong shape\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({\n\t                shape: {\n\t                    r: layout.r + 10\n\t                }\n\t            }, 300, 'elasticOut');\n\t        }\n\t        function onNormal() {\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({\n\t                shape: {\n\t                    r: layout.r\n\t                }\n\t            }, 300, 'elasticOut');\n\t        }\n\t        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\t        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n\t            sector\n\t                .on('mouseover', onEmphasis)\n\t                .on('mouseout', onNormal)\n\t                .on('emphasis', onEmphasis)\n\t                .on('normal', onNormal);\n\t        }\n\t\n\t        this._updateLabel(data, idx);\n\t\n\t        graphic.setHoverStyle(this);\n\t    };\n\t\n\t    piePieceProto._updateLabel = function (data, idx) {\n\t\n\t        var labelLine = this.childAt(1);\n\t        var labelText = this.childAt(2);\n\t\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var labelLayout = layout.label;\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t\n\t        graphic.updateProps(labelLine, {\n\t            shape: {\n\t                points: labelLayout.linePoints || [\n\t                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n\t                ]\n\t            }\n\t        }, seriesModel, idx);\n\t\n\t        graphic.updateProps(labelText, {\n\t            style: {\n\t                x: labelLayout.x,\n\t                y: labelLayout.y\n\t            }\n\t        }, seriesModel, idx);\n\t        labelText.attr({\n\t            style: {\n\t                textVerticalAlign: labelLayout.verticalAlign,\n\t                textAlign: labelLayout.textAlign,\n\t                textFont: labelLayout.font\n\t            },\n\t            rotation: labelLayout.rotation,\n\t            origin: [labelLayout.x, labelLayout.y],\n\t            z2: 10\n\t        });\n\t\n\t        var labelModel = itemModel.getModel('label.normal');\n\t        var labelHoverModel = itemModel.getModel('label.emphasis');\n\t        var labelLineModel = itemModel.getModel('labelLine.normal');\n\t        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n\t        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\t\n\t        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\t\n\t        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n\t        labelText.hoverIgnore = !labelHoverModel.get('show');\n\t\n\t        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n\t        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\t\n\t        // Default use item visual color\n\t        labelLine.setStyle({\n\t            stroke: visualColor,\n\t            opacity: data.getItemVisual(idx, 'opacity')\n\t        });\n\t        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\t\n\t        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n\t        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\t\n\t        var smooth = labelLineModel.get('smooth');\n\t        if (smooth && smooth === true) {\n\t            smooth = 0.4;\n\t        }\n\t        labelLine.setShape({\n\t            smooth: smooth\n\t        });\n\t    };\n\t\n\t    zrUtil.inherits(PiePiece, graphic.Group);\n\t\n\t\n\t    // Pie view\n\t    var Pie = __webpack_require__(90).extend({\n\t\n\t        type: 'pie',\n\t\n\t        init: function () {\n\t            var sectorGroup = new graphic.Group();\n\t            this._sectorGroup = sectorGroup;\n\t        },\n\t\n\t        render: function (seriesModel, ecModel, api, payload) {\n\t            if (payload && (payload.from === this.uid)) {\n\t                return;\n\t            }\n\t\n\t            var data = seriesModel.getData();\n\t            var oldData = this._data;\n\t            var group = this.group;\n\t\n\t            var hasAnimation = ecModel.get('animation');\n\t            var isFirstRender = !oldData;\n\t\n\t            var onSectorClick = zrUtil.curry(\n\t                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n\t            );\n\t\n\t            var selectedMode = seriesModel.get('selectedMode');\n\t\n\t            data.diff(oldData)\n\t                .add(function (idx) {\n\t                    var piePiece = new PiePiece(data, idx);\n\t                    if (isFirstRender) {\n\t                        piePiece.eachChild(function (child) {\n\t                            child.stopAnimation(true);\n\t                        });\n\t                    }\n\t\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t\n\t                    data.setItemGraphicEl(idx, piePiece);\n\t\n\t                    group.add(piePiece);\n\t                })\n\t                .update(function (newIdx, oldIdx) {\n\t                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\t\n\t                    piePiece.updateData(data, newIdx);\n\t\n\t                    piePiece.off('click');\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t                    group.add(piePiece);\n\t                    data.setItemGraphicEl(newIdx, piePiece);\n\t                })\n\t                .remove(function (idx) {\n\t                    var piePiece = oldData.getItemGraphicEl(idx);\n\t                    group.remove(piePiece);\n\t                })\n\t                .execute();\n\t\n\t            if (hasAnimation && isFirstRender && data.count() > 0) {\n\t                var shape = data.getItemLayout(0);\n\t                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\t\n\t                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n\t                group.setClipPath(this._createClipPath(\n\t                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n\t                ));\n\t            }\n\t\n\t            this._data = data;\n\t        },\n\t\n\t        dispose: function () {},\n\t\n\t        _createClipPath: function (\n\t            cx, cy, r, startAngle, clockwise, cb, seriesModel\n\t        ) {\n\t            var clipPath = new graphic.Sector({\n\t                shape: {\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r0: 0,\n\t                    r: r,\n\t                    startAngle: startAngle,\n\t                    endAngle: startAngle,\n\t                    clockwise: clockwise\n\t                }\n\t            });\n\t\n\t            graphic.initProps(clipPath, {\n\t                shape: {\n\t                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n\t                }\n\t            }, seriesModel, cb);\n\t\n\t            return clipPath;\n\t        },\n\t\n\t        /**\n\t         * @implement\n\t         */\n\t        containPoint: function (point, seriesModel) {\n\t            var data = seriesModel.getData();\n\t            var itemLayout = data.getItemLayout(0);\n\t            if (itemLayout) {\n\t                var dx = point[0] - itemLayout.cx;\n\t                var dy = point[1] - itemLayout.cy;\n\t                var radius = Math.sqrt(dx * dx + dy * dy);\n\t                return radius <= itemLayout.r && radius >= itemLayout.r0;\n\t            }\n\t        }\n\t\n\t    });\n\t\n\t    module.exports = Pie;\n\n\n/***/ },\n/* 429 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// FIXME emphasis label position is not same with normal label position\n\t\n\t\n\t    var textContain = __webpack_require__(26);\n\t\n\t    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n\t        list.sort(function (a, b) {\n\t            return a.y - b.y;\n\t        });\n\t\n\t        // 压\n\t        function shiftDown(start, end, delta, dir) {\n\t            for (var j = start; j < end; j++) {\n\t                list[j].y += delta;\n\t                if (j > start\n\t                    && j + 1 < end\n\t                    && list[j + 1].y > list[j].y + list[j].height\n\t                ) {\n\t                    shiftUp(j, delta / 2);\n\t                    return;\n\t                }\n\t            }\n\t\n\t            shiftUp(end - 1, delta / 2);\n\t        }\n\t\n\t        // 弹\n\t        function shiftUp(end, delta) {\n\t            for (var j = end; j >= 0; j--) {\n\t                list[j].y -= delta;\n\t                if (j > 0\n\t                    && list[j].y > list[j - 1].y + list[j - 1].height\n\t                ) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t\n\t        function changeX(list, isDownList, cx, cy, r, dir) {\n\t            var lastDeltaX = dir > 0\n\t                ? isDownList                // 右侧\n\t                    ? Number.MAX_VALUE      // 下\n\t                    : 0                     // 上\n\t                : isDownList                // 左侧\n\t                    ? Number.MAX_VALUE      // 下\n\t                    : 0;                    // 上\n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                // Not change x for center label\n\t                if (list[i].position === 'center') {\n\t                    continue;\n\t                }\n\t                var deltaY = Math.abs(list[i].y - cy);\n\t                var length = list[i].len;\n\t                var length2 = list[i].len2;\n\t                var deltaX = (deltaY < r + length)\n\t                    ? Math.sqrt(\n\t                          (r + length + length2) * (r + length + length2)\n\t                          - deltaY * deltaY\n\t                      )\n\t                    : Math.abs(list[i].x - cx);\n\t                if (isDownList && deltaX >= lastDeltaX) {\n\t                    // 右下，左下\n\t                    deltaX = lastDeltaX - 10;\n\t                }\n\t                if (!isDownList && deltaX <= lastDeltaX) {\n\t                    // 右上，左上\n\t                    deltaX = lastDeltaX + 10;\n\t                }\n\t\n\t                list[i].x = cx + deltaX * dir;\n\t                lastDeltaX = deltaX;\n\t            }\n\t        }\n\t\n\t        var lastY = 0;\n\t        var delta;\n\t        var len = list.length;\n\t        var upList = [];\n\t        var downList = [];\n\t        for (var i = 0; i < len; i++) {\n\t            delta = list[i].y - lastY;\n\t            if (delta < 0) {\n\t                shiftDown(i, len, -delta, dir);\n\t            }\n\t            lastY = list[i].y + list[i].height;\n\t        }\n\t        if (viewHeight - lastY < 0) {\n\t            shiftUp(len - 1, lastY - viewHeight);\n\t        }\n\t        for (var i = 0; i < len; i++) {\n\t            if (list[i].y >= cy) {\n\t                downList.push(list[i]);\n\t            }\n\t            else {\n\t                upList.push(list[i]);\n\t            }\n\t        }\n\t        changeX(upList, false, cx, cy, r, dir);\n\t        changeX(downList, true, cx, cy, r, dir);\n\t    }\n\t\n\t    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n\t        var leftList = [];\n\t        var rightList = [];\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            if (labelLayoutList[i].x < cx) {\n\t                leftList.push(labelLayoutList[i]);\n\t            }\n\t            else {\n\t                rightList.push(labelLayoutList[i]);\n\t            }\n\t        }\n\t\n\t        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n\t        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\t\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            var linePoints = labelLayoutList[i].linePoints;\n\t            if (linePoints) {\n\t                var dist = linePoints[1][0] - linePoints[2][0];\n\t                if (labelLayoutList[i].x < cx) {\n\t                    linePoints[2][0] = labelLayoutList[i].x + 3;\n\t                }\n\t                else {\n\t                    linePoints[2][0] = labelLayoutList[i].x - 3;\n\t                }\n\t                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n\t                linePoints[1][0] = linePoints[2][0] + dist;\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n\t        var data = seriesModel.getData();\n\t        var labelLayoutList = [];\n\t        var cx;\n\t        var cy;\n\t        var hasLabelRotate = false;\n\t\n\t        data.each(function (idx) {\n\t            var layout = data.getItemLayout(idx);\n\t\n\t            var itemModel = data.getItemModel(idx);\n\t            var labelModel = itemModel.getModel('label.normal');\n\t            // Use position in normal or emphasis\n\t            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\t\n\t            var labelLineModel = itemModel.getModel('labelLine.normal');\n\t            var labelLineLen = labelLineModel.get('length');\n\t            var labelLineLen2 = labelLineModel.get('length2');\n\t\n\t            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t            var dx = Math.cos(midAngle);\n\t            var dy = Math.sin(midAngle);\n\t\n\t            var textX;\n\t            var textY;\n\t            var linePoints;\n\t            var textAlign;\n\t\n\t            cx = layout.cx;\n\t            cy = layout.cy;\n\t\n\t            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t            if (labelPosition === 'center') {\n\t                textX = layout.cx;\n\t                textY = layout.cy;\n\t                textAlign = 'center';\n\t            }\n\t            else {\n\t                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n\t                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\t\n\t                textX = x1 + dx * 3;\n\t                textY = y1 + dy * 3;\n\t\n\t                if (!isLabelInside) {\n\t                    // For roseType\n\t                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n\t                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n\t                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n\t                    var y3 = y2;\n\t\n\t                    textX = x3 + (dx < 0 ? -5 : 5);\n\t                    textY = y3;\n\t                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n\t                }\n\t\n\t                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n\t            }\n\t            var font = labelModel.getModel('textStyle').getFont();\n\t\n\t            var labelRotate = labelModel.get('rotate')\n\t                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n\t            var text = seriesModel.getFormattedLabel(idx, 'normal')\n\t                        || data.getName(idx);\n\t            var textRect = textContain.getBoundingRect(\n\t                text, font, textAlign, 'top'\n\t            );\n\t            hasLabelRotate = !!labelRotate;\n\t            layout.label = {\n\t                x: textX,\n\t                y: textY,\n\t                position: labelPosition,\n\t                height: textRect.height,\n\t                len: labelLineLen,\n\t                len2: labelLineLen2,\n\t                linePoints: linePoints,\n\t                textAlign: textAlign,\n\t                verticalAlign: 'middle',\n\t                font: font,\n\t                rotation: labelRotate\n\t            };\n\t\n\t            // Not layout the inside label\n\t            if (!isLabelInside) {\n\t                labelLayoutList.push(layout.label);\n\t            }\n\t        });\n\t        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n\t            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n\t        }\n\t    };\n\n\n/***/ },\n/* 430 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// TODO minAngle\n\t\n\t\n\t\n\t    var numberUtil = __webpack_require__(12);\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var labelLayout = __webpack_require__(429);\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var PI2 = Math.PI * 2;\n\t    var RADIAN = Math.PI / 180;\n\t\n\t    module.exports = function (seriesType, ecModel, api, payload) {\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var center = seriesModel.get('center');\n\t            var radius = seriesModel.get('radius');\n\t\n\t            if (!zrUtil.isArray(radius)) {\n\t                radius = [0, radius];\n\t            }\n\t            if (!zrUtil.isArray(center)) {\n\t                center = [center, center];\n\t            }\n\t\n\t            var width = api.getWidth();\n\t            var height = api.getHeight();\n\t            var size = Math.min(width, height);\n\t            var cx = parsePercent(center[0], width);\n\t            var cy = parsePercent(center[1], height);\n\t            var r0 = parsePercent(radius[0], size / 2);\n\t            var r = parsePercent(radius[1], size / 2);\n\t\n\t            var data = seriesModel.getData();\n\t\n\t            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\t\n\t            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\t\n\t            var sum = data.getSum('value');\n\t            // Sum may be 0\n\t            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\t\n\t            var clockwise = seriesModel.get('clockwise');\n\t\n\t            var roseType = seriesModel.get('roseType');\n\t\n\t            // [0...max]\n\t            var extent = data.getDataExtent('value');\n\t            extent[0] = 0;\n\t\n\t            // In the case some sector angle is smaller than minAngle\n\t            var restAngle = PI2;\n\t            var valueSumLargerThanMinAngle = 0;\n\t\n\t            var currentAngle = startAngle;\n\t\n\t            var dir = clockwise ? 1 : -1;\n\t            data.each('value', function (value, idx) {\n\t                var angle;\n\t                // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n\t                if (roseType !== 'area') {\n\t                    angle = sum === 0 ? unitRadian : (value * unitRadian);\n\t                }\n\t                else {\n\t                    angle = PI2 / (data.count() || 1);\n\t                }\n\t\n\t                if (angle < minAngle) {\n\t                    angle = minAngle;\n\t                    restAngle -= minAngle;\n\t                }\n\t                else {\n\t                    valueSumLargerThanMinAngle += value;\n\t                }\n\t\n\t                var endAngle = currentAngle + dir * angle;\n\t                data.setItemLayout(idx, {\n\t                    angle: angle,\n\t                    startAngle: currentAngle,\n\t                    endAngle: endAngle,\n\t                    clockwise: clockwise,\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r0: r0,\n\t                    r: roseType\n\t                        ? numberUtil.linearMap(value, extent, [r0, r])\n\t                        : r\n\t                });\n\t\n\t                currentAngle = endAngle;\n\t            }, true);\n\t\n\t            // Some sector is constrained by minAngle\n\t            // Rest sectors needs recalculate angle\n\t            if (restAngle < PI2) {\n\t                // Average the angle if rest angle is not enough after all angles is\n\t                // Constrained by minAngle\n\t                if (restAngle <= 1e-3) {\n\t                    var angle = PI2 / data.count();\n\t                    data.each(function (idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        layout.startAngle = startAngle + dir * idx * angle;\n\t                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n\t                    });\n\t                }\n\t                else {\n\t                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n\t                    currentAngle = startAngle;\n\t                    data.each('value', function (value, idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        var angle = layout.angle === minAngle\n\t                            ? minAngle : value * unitRadian;\n\t                        layout.startAngle = currentAngle;\n\t                        layout.endAngle = currentAngle + dir * angle;\n\t                        currentAngle += dir * angle;\n\t                    });\n\t                }\n\t            }\n\t\n\t            labelLayout(seriesModel, r, width, height);\n\t        });\n\t    };\n\n\n/***/ },\n/* 431 */,\n/* 432 */,\n/* 433 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Data selectable mixin for chart series.\n\t * To eanble data select, option of series must have `selectedMode`.\n\t * And each data item will use `selected` to toggle itself selected status\n\t *\n\t * @module echarts/chart/helper/DataSelectable\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    module.exports = {\n\t\n\t        updateSelectedMap: function (targetList) {\n\t            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n\t                targetMap[target.name] = target;\n\t                return targetMap;\n\t            }, {});\n\t        },\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        // PENGING If selectedMode is null ?\n\t        select: function (name) {\n\t            var targetMap = this._selectTargetMap;\n\t            var target = targetMap[name];\n\t            var selectedMode = this.get('selectedMode');\n\t            if (selectedMode === 'single') {\n\t                zrUtil.each(targetMap, function (target) {\n\t                    target.selected = false;\n\t                });\n\t            }\n\t            target && (target.selected = true);\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        unSelect: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            // var selectedMode = this.get('selectedMode');\n\t            // selectedMode !== 'single' && target && (target.selected = false);\n\t            target && (target.selected = false);\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        toggleSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            if (target != null) {\n\t                this[target.selected ? 'unSelect' : 'select'](name);\n\t                return target.selected;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        isSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            return target && target.selected;\n\t        }\n\t    };\n\n\n/***/ },\n/* 434 */,\n/* 435 */,\n/* 436 */,\n/* 437 */,\n/* 438 */,\n/* 439 */,\n/* 440 */,\n/* 441 */,\n/* 442 */,\n/* 443 */,\n/* 444 */,\n/* 445 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = function (seriesType, ecModel) {\n\t        var legendModels = ecModel.findComponents({\n\t            mainType: 'legend'\n\t        });\n\t        if (!legendModels || !legendModels.length) {\n\t            return;\n\t        }\n\t        ecModel.eachSeriesByType(seriesType, function (series) {\n\t            var data = series.getData();\n\t            data.filterSelf(function (idx) {\n\t                var name = data.getName(idx);\n\t                // If in any legend component the status is not selected.\n\t                for (var i = 0; i < legendModels.length; i++) {\n\t                    if (!legendModels[i].isSelected(name)) {\n\t                        return false;\n\t                    }\n\t                }\n\t                return true;\n\t            }, this);\n\t        }, this);\n\t    };\n\n\n/***/ },\n/* 446 */,\n/* 447 */,\n/* 448 */,\n/* 449 */\n/***/ function(module, exports) {\n\n\t// Pick color from palette for each data item\n\t\n\t\n\t    module.exports = function (seriesType, ecModel) {\n\t        // Pie and funnel may use diferrent scope\n\t        var paletteScope = {};\n\t        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n\t            var dataAll = seriesModel.getRawData();\n\t            var idxMap = {};\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                var data = seriesModel.getData();\n\t                data.each(function (idx) {\n\t                    var rawIdx = data.getRawIndex(idx);\n\t                    idxMap[rawIdx] = idx;\n\t                });\n\t                dataAll.each(function (rawIdx) {\n\t                    // FIXME Performance\n\t                    var itemModel = dataAll.getItemModel(rawIdx);\n\t                    var filteredIdx = idxMap[rawIdx];\n\t\n\t                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\t                    var singleDataColor = filteredIdx != null\n\t                        && data.getItemVisual(filteredIdx, 'color', true);\n\t\n\t                    if (!singleDataColor) {\n\t                        var color = itemModel.get('itemStyle.normal.color')\n\t                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n\t                        // Legend may use the visual info in data before processed\n\t                        dataAll.setItemVisual(rawIdx, 'color', color);\n\t\n\t                        // Data is not filtered\n\t                        if (filteredIdx != null) {\n\t                            data.setItemVisual(filteredIdx, 'color', color);\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Set data all color for legend\n\t                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n\t                    }\n\t                });\n\t            }\n\t        });\n\t    };\n\n\n/***/ },\n/* 450 */,\n/* 451 */,\n/* 452 */,\n/* 453 */,\n/* 454 */,\n/* 455 */,\n/* 456 */,\n/* 457 */,\n/* 458 */,\n/* 459 */,\n/* 460 */,\n/* 461 */,\n/* 462 */,\n/* 463 */,\n/* 464 */,\n/* 465 */,\n/* 466 */,\n/* 467 */,\n/* 468 */,\n/* 469 */,\n/* 470 */,\n/* 471 */,\n/* 472 */,\n/* 473 */,\n/* 474 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(410);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(4)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../node_modules/css-loader/index.js?-autoprefixer&sourceMap!./../../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-1d47d409!./../../../node_modules/sass-loader/index.js?sourceMap!./../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./dashboard.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../node_modules/css-loader/index.js?-autoprefixer&sourceMap!./../../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-1d47d409!./../../../node_modules/sass-loader/index.js?sourceMap!./../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./dashboard.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 475 */,\n/* 476 */,\n/* 477 */,\n/* 478 */,\n/* 479 */,\n/* 480 */,\n/* 481 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(416);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(4)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js?-autoprefixer&sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-901a6116!./../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./kt-pie-echart.vue\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js?-autoprefixer&sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-901a6116!./../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./kt-pie-echart.vue\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 482 */,\n/* 483 */,\n/* 484 */,\n/* 485 */,\n/* 486 */,\n/* 487 */,\n/* 488 */,\n/* 489 */,\n/* 490 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_exports__, __vue_options__\n\tvar __vue_styles__ = {}\n\t\n\t/* styles */\n\t__webpack_require__(481)\n\t\n\t/* script */\n\t__vue_exports__ = __webpack_require__(356)\n\t\n\t/* template */\n\tvar __vue_template__ = __webpack_require__(509)\n\t__vue_options__ = __vue_exports__ = __vue_exports__ || {}\n\tif (\n\t  typeof __vue_exports__.default === \"object\" ||\n\t  typeof __vue_exports__.default === \"function\"\n\t) {\n\t__vue_options__ = __vue_exports__ = __vue_exports__.default\n\t}\n\tif (typeof __vue_options__ === \"function\") {\n\t  __vue_options__ = __vue_options__.options\n\t}\n\t\n\t__vue_options__.render = __vue_template__.render\n\t__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\t\n\tmodule.exports = __vue_exports__\n\n\n/***/ },\n/* 491 */,\n/* 492 */,\n/* 493 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_exports__, __vue_options__\n\tvar __vue_styles__ = {}\n\t\n\t/* styles */\n\t__webpack_require__(474)\n\t\n\t/* script */\n\t__vue_exports__ = __webpack_require__(359)\n\t\n\t/* template */\n\tvar __vue_template__ = __webpack_require__(502)\n\t__vue_options__ = __vue_exports__ = __vue_exports__ || {}\n\tif (\n\t  typeof __vue_exports__.default === \"object\" ||\n\t  typeof __vue_exports__.default === \"function\"\n\t) {\n\t__vue_options__ = __vue_exports__ = __vue_exports__.default\n\t}\n\tif (typeof __vue_options__ === \"function\") {\n\t  __vue_options__ = __vue_options__.options\n\t}\n\t\n\t__vue_options__.render = __vue_template__.render\n\t__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\t\n\tmodule.exports = __vue_exports__\n\n\n/***/ },\n/* 494 */,\n/* 495 */,\n/* 496 */,\n/* 497 */,\n/* 498 */,\n/* 499 */,\n/* 500 */,\n/* 501 */,\n/* 502 */\n/***/ function(module, exports) {\n\n\tmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._c;\n\t  return _c('div', {\n\t    staticClass: \"overview\"\n\t  }, [_c('div', {\n\t    staticClass: \"today-overview\"\n\t  }, [_c('h2', [_vm._v(\"今日总览\")]), _c('div', {\n\t    staticClass: \"overview-left fl\"\n\t  }, [_c('h3', [_vm._v(\"当前存续金额（元）\")]), _c('div', {\n\t    staticClass: \"overview-left-middle\"\n\t  }, [_c('i', {\n\t    staticClass: \"icon-icomoon icon-overview\"\n\t  }), _c('span', [_vm._v(_vm._s(_vm._f(\"ktCurrency\")(_vm.balance.total, '')))])]), _c('div', {\n\t    staticClass: \"overview-left-down\"\n\t  }, [_c('div', {\n\t    staticClass: \"Principal fl\"\n\t  }, [_c('span', [_vm._v(\"存续本金\"), _c('em', [_vm._v(_vm._s(_vm._f(\"ktCurrency\")(_vm.balance.principal, '')))])])]), _c('div', {\n\t    staticClass: \"Interest fr\"\n\t  }, [_c('span', [_vm._v(\"存续利息\"), _c('em', [_vm._v(_vm._s(_vm._f(\"ktCurrency\")(_vm.balance.interest, '')))])])])])]), _c('div', {\n\t    staticClass: \"overview-right fr\"\n\t  }, [_c('h3', [_vm._v(\"今日存量产品占比分析\")]), _c('div', {\n\t    staticClass: \"overview-right-middle\"\n\t  }, [_c('kt-pie-echart', {\n\t    attrs: {\n\t      \"chart-option\": _vm.pieChartOption\n\t    }\n\t  })])])]), _c('div', {\n\t    staticClass: \"today-square\"\n\t  }, [_c('h2', [_vm._v(\"今日清算\"), _c('el-tooltip', {\n\t    attrs: {\n\t      \"effect\": \"dark\",\n\t      \"placement\": \"right\"\n\t    }\n\t  }, [_c('div', {\n\t    staticClass: \"Prompt\",\n\t    slot: \"content\"\n\t  }, [_vm._v(\"展示今日需资金清算的所有产品，包括今日流入资金的入账确认以及今日流出资金的划款确认 \"), _c('br'), _vm._v(\" 待执行-清算数据正常可以进行清算执行操作确认 \"), _c('br'), _vm._v(\" 不可执行-清算数据尚未更新或者异常导致无法执行清算确认 \"), _c('br'), _vm._v(\" 已执行-已经进行过清算执行操作确认 \"), _c('br'), _vm._v(\" 已过期-当前时间已经晚于需确认清算执行的最晚时限\")]), _c('i', {\n\t    staticClass: \"icon-icomoon icon-explain\"\n\t  })]), _c('div', {\n\t    staticClass: \"information fr\"\n\t  }, [_c('span', [_vm._v(_vm._s(_vm.summary.executed))]), _c('em', [_vm._v(\"条 已执行，\")]), _c('span', [_vm._v(_vm._s(_vm.summary.pending_execute))]), _c('em', [_vm._v(\"条 待执行，\")]), _c('span', [_vm._v(_vm._s(_vm.summary.cant_execute))]), _c('em', [_vm._v(\"条 不可执行，\")]), _c('span', [_vm._v(_vm._s(_vm.summary.expired))]), _c('em', [_vm._v(\"条 已过期\")])])]), _c('div', {\n\t    staticClass: \"overview-table\"\n\t  }, _vm._l((_vm.virtualAssets), function(item, key) {\n\t    return _c('table', [_c('thead', [_c('tr', [_c('th', [_vm._v(_vm._s(key))])])]), _vm._l((item), function(product) {\n\t      return _c('tbody', [_c('tr', {\n\t        on: {\n\t          \"click\": function($event) {\n\t            _vm.toDetails(product)\n\t          }\n\t        }\n\t      }, [_c('td', [_c('span', [_vm._v(_vm._s(product.name))])]), _c('td', [(product.inflow_desc) ? _c('span', [_vm._v(_vm._s(product.inflow_desc)), _c('em', {\n\t        staticClass: \"red-color\"\n\t      }, [_vm._v(_vm._s(_vm._f(\"ktCurrency\")(product.inflow)))])]) : _vm._e()]), _c('td', [(product.outflow_desc) ? _c('span', [_vm._v(_vm._s(product.outflow_desc)), _c('em', {\n\t        staticClass: \"green-color\"\n\t      }, [_vm._v(_vm._s(_vm._f(\"ktCurrency\")(product.outflow)))])]) : _vm._e()]), _c('td', [_c('span', [_vm._v(_vm._s(product.inflow >= product.outflow ? '净流入' : '净流出')), _c('em', {\n\t        class: [product.inflow >= product.outflow ? 'red-color' : 'green-color']\n\t      }, [_vm._v(_vm._s(_vm._f(\"ktCurrency\")(product.net_cash_flow)))])])]), _c('td', [_c('span', {\n\t        staticClass: \"bg-color\"\n\t      }, [_vm._v(_vm._s(product.execute_method))])]), _c('td', {\n\t        staticClass: \"implement status-column\"\n\t      }, [_c('i', {\n\t        staticClass: \"icon-icomoon\",\n\t        class: _vm._f(\"excuteStatusIcon\")(product.execute_status)\n\t      }), _c('em', {\n\t        staticClass: \"em-implement\"\n\t      }, [_vm._v(_vm._s(product.execute_status))])]), _c('td', [_c('span', {\n\t        directives: [{\n\t          name: \"show\",\n\t          rawName: \"v-show\",\n\t          value: (product.execute_status === '待执行' ? true : false),\n\t          expression: \"product.execute_status === '待执行' ? true : false\"\n\t        }]\n\t      }, [_vm._v(\"结算时限:\"), _c('em', [_vm._v(_vm._s(product.due_at))])])])])])\n\t    })], true)\n\t  }))])])\n\t},staticRenderFns: []}\n\n/***/ },\n/* 503 */,\n/* 504 */,\n/* 505 */,\n/* 506 */,\n/* 507 */,\n/* 508 */,\n/* 509 */\n/***/ function(module, exports) {\n\n\tmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._c;\n\t  return _c('div', {\n\t    ref: \"echart\",\n\t    staticClass: \"pie-echarts\"\n\t  })\n\t},staticRenderFns: []}\n\n/***/ }\n]);\n\n\n// WEBPACK FOOTER //\n// static/js/1.5fdc2f1fcb39a44ae812.js","/**\n * @module zrender/core/util\n */\n\n\n    // 用于处理merge时无法遍历Date等对象的问题\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuildInObject(sourceProp)\n                    && !isBuildInObject(targetProp)\n                ) {\n                    // 如果需要递归覆盖，就递归调用merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * 查询数组中元素的index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 构造类继承关系\n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz 源类\n     * @param {Function} baseClazz 基类\n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * 数组或对象遍历\n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * 数组映射\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * 数组过滤\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * 数组项查找\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuildInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuildInObject: isBuildInObject,\n        isDom: isDom,\n        retrieve: retrieve,\n        assert: assert,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/util.js\n// module id = 1\n// module chunks = 0 1","// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (typeof __DEV__ === 'undefined') {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = require('zrender/lib/core/env');\n\n    var GlobalModel = require('./model/Global');\n    var ExtensionAPI = require('./ExtensionAPI');\n    var CoordinateSystemManager = require('./CoordinateSystem');\n    var OptionManager = require('./model/OptionManager');\n\n    var ComponentModel = require('./model/Component');\n    var SeriesModel = require('./model/Series');\n\n    var ComponentView = require('./view/Component');\n    var ChartView = require('./view/Chart');\n    var graphic = require('./util/graphic');\n    var modelUtil = require('./util/model');\n    var throttle = require('./util/throttle');\n\n    var zrender = require('zrender');\n    var zrUtil = require('zrender/lib/core/util');\n    var colorTool = require('zrender/lib/tool/color');\n    var Eventful = require('zrender/lib/mixin/Eventful');\n    var timsort = require('zrender/lib/core/timsort');\n\n    var each = zrUtil.each;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flagInMainProcess';\n    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n    var OPTION_UPDATED = '__optionUpdated';\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts (dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        var zr = this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * Expect 60 pfs.\n         * @type {Function}\n         * @private\n         */\n        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = new ExtensionAPI(this);\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        zr.animation.on('frame', this._onframe, this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * @param {Object} option\n     * @param {boolean} notMerge\n     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        // FIXME\n        // ugly\n        this.__lastOnlyGraphic = !!(option && option.graphic);\n        zrUtil.each(option, function (o, mainType) {\n            mainType !== 'graphic' && (this.__lastOnlyGraphic = false);\n        }, this);\n\n        this._model.setOption(option, optionPreprocessorFuncs);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = true;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            // Ensure zr refresh sychronously, and then pixel in canvas can be\n            // fetched after `setOption`.\n            this._zr.flush();\n            this[OPTION_UPDATED] = false;\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        flushPendingActions.call(this, false);\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     * @param {string} [opts.excludeComponents]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (__DEV__) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (__DEV__) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.time && console.time('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer？\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            // console.time && console.timeEnd('update');\n        },\n\n        // PENDING\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        highlight: function (payload) {\n            toggleHighlight.call(this, 'highlight', payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        downplay: function (payload) {\n            toggleHighlight.call(this, 'downplay', payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            // FIXME\n            // ugly\n            if (this.__lastOnlyGraphic) {\n                each(this._componentsViews, function (componentView) {\n                    var componentModel = componentView.__model;\n                    if (componentModel && componentModel.mainType === 'graphic') {\n                        componentView.render(componentModel, ecModel, this._api, payload);\n                        updateZ(componentModel, componentView);\n                    }\n                }, this);\n                this.__lastOnlyGraphic = false;\n            }\n            else {\n                updateMethods.update.call(this, payload);\n            }\n        }\n    };\n\n    /**\n     * @param {Object} payload\n     * @private\n     */\n    function toggleHighlight(method, payload) {\n        var ecModel = this._model;\n\n        // dispatchAction before setOption\n        if (!ecModel) {\n            return;\n        }\n\n        ecModel.eachComponent(\n            {mainType: 'series', query: payload},\n            function (seriesModel, index) {\n                var chartView = this._chartsMap[seriesModel.__viewId];\n                if (chartView && chartView.__alive) {\n                    chartView[method](\n                        seriesModel, ecModel, this._api, payload\n                    );\n                }\n            },\n            this\n        );\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    echartsProto.resize = function (opts) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        flushPendingActions.call(this);\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (__DEV__) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n     * @param {boolean} [opt.silent=false] Whether trigger events.\n     * @param {boolean} [opt.flush=undefined]\n     *                  true: Flush immediately, and then pixel in canvas can be fetched\n     *                      immediately. Caution: it might affect performance.\n     *                  false: Not not flush.\n     *                  undefined: Auto decide whether perform flush.\n     */\n    echartsProto.dispatchAction = function (payload, opt) {\n        if (!zrUtil.isObject(opt)) {\n            opt = {silent: !!opt};\n        }\n\n        if (!actions[payload.type]) {\n            return;\n        }\n\n        // if (__DEV__) {\n        //     zrUtil.assert(\n        //         !this[IN_MAIN_PROCESS],\n        //         '`dispatchAction` should not be called during main process.'\n        //         + 'unless updateMathod is \"none\".'\n        //     );\n        // }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        doDispatchAction.call(this, payload, opt.silent);\n\n        if (opt.flush) {\n            this._zr.flush(true);\n        }\n        else if (opt.flush !== false && env.browser.weChat) {\n            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n            // hang when sliding page (on touch event), which cause that zr does not\n            // refresh util user interaction finished, which is not expected.\n            // But `dispatchAction` may be called too frequently when pan on touch\n            // screen, which impacts performance if do not throttle them.\n            this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, opt.silent);\n    };\n\n    function doDispatchAction(payload, silent) {\n        var actionWrap = actions[payload.type];\n        var actionInfo = actionWrap.actionInfo;\n        var updateMethod = actionInfo.update || 'update';\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';\n        for (var i = 0; i < payloads.length; i++) {\n            var batchItem = payloads[i];\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // Highlight and downplay are special.\n            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);\n        }\n\n        if (updateMethod !== 'none' && !isHighlightOrDownplay) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payload.type,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n    }\n\n    function flushPendingActions(silent) {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            doDispatchAction.call(this, payload, silent);\n        }\n    }\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = ComponentModel.parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = viewId;\n            view.__alive = true;\n            view.__id = viewId;\n            view.__model = model;\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                if (previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (__DEV__) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (__DEV__) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var actions = [];\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.3.2',\n        dependencies: {\n            zrender: '3.2.2'\n        }\n    };\n\n    function enableConnect(chart) {\n\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n\n    }\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (__DEV__) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        dom.setAttribute &&\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (zrUtil.isDom(chart)) {\n            chart = echarts.getInstanceByDom(chart);\n        }\n        else if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        return instances[key];\n    };\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n\n    var parseClassType = ComponentModel.parseClassType;\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts, superClass) {\n        var Clazz = ComponentModel;\n        if (superClass) {\n            var classType = parseClassType(superClass);\n            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts, superClass) {\n        var Clazz = ComponentView;\n        if (superClass) {\n            var classType = parseClassType(superClass);\n            Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts, superClass) {\n        var Clazz = SeriesModel;\n        if (superClass) {\n            superClass = 'series.' + superClass.replace('series.', '');\n            var classType = parseClassType(superClass);\n            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts, superClass) {\n        var Clazz = ChartView;\n        if (superClass) {\n            superClass.replace('series.', '');\n            var classType = parseClassType(superClass);\n            Clazz = ChartView.getClass(classType.main, true);\n        }\n        return Clazz.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n    echarts.registerLoading('default', require('./loading/default'));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n\n    // --------\n    // Exports\n    // --------\n    //\n    echarts.List = require('./data/List');\n    echarts.Model = require('./model/Model');\n\n    echarts.graphic = require('./util/graphic');\n    echarts.number = require('./util/number');\n    echarts.format = require('./util/format');\n    echarts.matrix = require('zrender/lib/core/matrix');\n    echarts.vector = require('zrender/lib/core/vector');\n    echarts.color = require('zrender/lib/tool/color');\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n            'extend', 'defaults', 'clone'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/echarts.js\n// module id = 5\n// module chunks = 0 1","/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || (\n                lineDash && !ctxLineDash && hasStroke\n            )) {\n                path = this.path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     * 扩展一个 Path element, 比如星形，圆等。\n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME 不能 extend position, rotation 等引用对象\n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Path.js\n// module id = 6\n// module chunks = 0 1","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * 二维向量类\n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * 创建一个向量\n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * 复制向量数据\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 克隆一个向量\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 设置向量的两个项\n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} 结果\n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * 向量相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * 向量缩放后相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * 向量相减\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * 向量长度\n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * 向量长度平方\n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * 向量乘法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * 向量除法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * 向量点乘\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * 向量缩放\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * 向量归一化\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * 计算向量间距离\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * 向量距离平方\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * 求负向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * 插值两个点\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * 矩阵左乘向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * 求两个向量最小值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * 求两个向量最大值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/vector.js\n// module id = 7\n// module chunks = 0 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('./number');\n    var textContain = require('zrender/lib/contain/text');\n\n    var formatUtil = {};\n    /**\n     * 每三位默认加,格式化\n     * @type {string|number} x\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @param {boolean} [upperCaseFirst=false]\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n\n        if (upperCaseFirst && str) {\n            str = str.charAt(0).toUpperCase() + str.slice(1);\n        }\n\n        return str;\n    };\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        else if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    };\n\n    formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param  {string} tpl\n     * @param  {Array.<Object>|Object} paramsList\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            tpl = tpl.replace(wrapVar(alias),  wrapVar(alias, 0));\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    paramsList[seriesIdx][$vars[k]]\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var y = date.getFullYear();\n        var M = date.getMonth() + 1;\n        var d = date.getDate();\n        var h = date.getHours();\n        var m = date.getMinutes();\n        var s = date.getSeconds();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .toLowerCase()\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    module.exports = formatUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/format.js\n// module id = 9\n// module chunks = 0 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var pathTool = require('zrender/lib/tool/path');\n    var round = Math.round;\n    var Path = require('zrender/lib/graphic/Path');\n    var colorTool = require('zrender/lib/tool/color');\n    var matrix = require('zrender/lib/core/matrix');\n    var vector = require('zrender/lib/core/vector');\n\n    var graphic = {};\n\n    graphic.Group = require('zrender/lib/container/Group');\n\n    graphic.Image = require('zrender/lib/graphic/Image');\n\n    graphic.Text = require('zrender/lib/graphic/Text');\n\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\n\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\n\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\n\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\n\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\n\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\n\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\n\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\n\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\n\n    graphic.CompoundPath = require('zrender/lib/graphic/CompoundPath');\n\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\n\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\n\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            this.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     * @param {Object} [opt]\n     * @param {boolean} [opt.hoverSilentOnTouch=false]\n     *        In touch device, mouseover event will be trigger on touchstart event\n     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n     *        conviniently use hoverStyle when tap on touch screen without additional\n     *        code for compatibility.\n     *        But if the chart/component has select feature, which usually also use\n     *        hoverStyle, there might be conflict between 'select-highlight' and\n     *        'hover-highlight' especially when roam is enabled (see geo for example).\n     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n     *        on touch device.\n     */\n    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n\n        // Duplicated function will be auto-ignored, see Eventful.js.\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        var animationEnabled = animatableModel\n            && (\n                animatableModel.ifEnableAnimation\n                ? animatableModel.ifEnableAnimation()\n                // Directly use animation property\n                : animatableModel.getShallow('animation')\n            );\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel\n                && animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel\n                && animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel\n                && animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(dataIndex);\n            }\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n                : (el.attr(props), cb && cb());\n        }\n        else {\n            el.attr(props);\n            cb && cb();\n        }\n    }\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} vertex [x, y]\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (vertex, transform, invert) {\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], vertex, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    module.exports = graphic;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/graphic.js\n// module id = 10\n// module chunks = 0 1","\n\n    var formatUtil = require('./format');\n    var nubmerUtil = require('./number');\n    var Model = require('../model/Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n\n    modelUtil.LABEL_OPTIONS = ['position', 'show', 'textStyle', 'distance', 'formatter'];\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n\n            var seriesIndex = this.seriesIndex;\n            var seriesName = this.name;\n\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: seriesIndex,\n                seriesName: seriesName,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: data.getItemVisual(dataIndex, 'color'),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get(['label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          index of which is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    // Existing model that already has id should be able to\n                    // mapped to (because after mapping performed model may\n                    // be assigned with a id, whish should not affect next\n                    // mapping), except those has inner id.\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * Make id and name for mapping result (result of mappingToExists)\n     * into `keyInfo` field.\n     *\n     * @public\n     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     * @return {Array.<Object>} The input.\n     */\n    modelUtil.makeIdAndName = function (mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = {};\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && (idMap[existCpt.id] = item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && (idMap[opt.id] = item);\n            !item.keyInfo && (item.keyInfo = {});\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-';\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap[keyInfo.id]);\n            }\n\n            idMap[keyInfo.id] = item;\n        });\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, goeName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = parsedKey[2];\n\n            if (!mainType || !queryType) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            queryParam[queryType.toLowerCase()] = value;\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/model.js\n// module id = 11\n// module chunks = 0 1","/**\n * 数值处理模块\n * @module echarts/util/number\n */\n\n\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * Fix rounding error of float numbers\n     * @param {number} x\n     * @return {number}\n     */\n    number.round = function (x, precision) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        return +(+x).toFixed(precision);\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n        var dotIndex = str.indexOf('.');\n        if (dotIndex < 0) {\n            return 0;\n        }\n        return str.length - 1 - dotIndex;\n    };\n\n    /**\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number}  precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        return Math.max(\n            -dataQuantity + sizeQuantity,\n            0\n        );\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    /**\n     * @param {string|Date|number} value\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Treat as ISO format. See issue #3623\n            var ret = new Date(value);\n            if (isNaN(+ret)) {\n                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n            }\n            return ret;\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n    };\n\n    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n    /**\n     * find a “nice” number approximately equal to x. Round the number if round = true, take ceiling if round = false\n     * The primary observation is that the “nicest” numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     * @param  {number} val\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exp10 = number.quantity(val);\n        var f = val / exp10; // between 1 and 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        return nf * exp10;\n    };\n\n    /**\n     * Order intervals asc, and split them when overlap.\n     * expect(numberUtil.reformIntervals([\n     *     {interval: [18, 62], close: [1, 1]},\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [1, 1]},\n     *     {interval: [62, 150], close: [1, 1]},\n     *     {interval: [106, 150], close: [1, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ])).toEqual([\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [0, 1]},\n     *     {interval: [18, 62], close: [0, 1]},\n     *     {interval: [62, 150], close: [0, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ]);\n     * @param {Array.<Object>} list, where `close` mean open or close\n     *        of the interval, and Infinity can be used.\n     * @return {Array.<Object>} The origin list, which has been reformed.\n     */\n    number.reformIntervals = function (list) {\n        list.sort(function (a, b) {\n            return littleThan(a, b, 0) ? -1 : 1;\n        });\n\n        var curr = -Infinity;\n        var currClose = 1;\n        for (var i = 0; i < list.length;) {\n            var interval = list[i].interval;\n            var close = list[i].close;\n\n            for (var lg = 0; lg < 2; lg++) {\n                if (interval[lg] <= curr) {\n                    interval[lg] = curr;\n                    close[lg] = !lg ? 1 - currClose : 1;\n                }\n                curr = interval[lg];\n                currClose = close[lg];\n            }\n\n            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n                list.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n\n        return list;\n\n        function littleThan(a, b, lg) {\n            return a.interval[lg] < b.interval[lg]\n                || (\n                    a.interval[lg] === b.interval[lg]\n                    && (\n                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n                        || (!lg && littleThan(a, b, 1))\n                    )\n                );\n        }\n    };\n\n    module.exports = number;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/number.js\n// module id = 12\n// module chunks = 0 1","'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // 矩阵右乘\n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/BoundingRect.js\n// module id = 13\n// module chunks = 0 1","/**\n * echarts设备环境识别\n *\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // 原生canvas支持，改极端点了\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default,\n                // only MS browsers are reliable on pointer events currently.\n                && (browser.edge || (browser.ie && browser.version >= 10))\n        };\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/env.js\n// module id = 14\n// module chunks = 0 1","/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazzUtil = require('../util/clazz');\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model 的初始化函数\n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         * 从新的 Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (!path) {\n                return this.option;\n            }\n\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n\n            var obj = this.option;\n            var parentModel = this.parentModel;\n            for (var i = 0; i < path.length; i++) {\n                // Ignore empty\n                if (!path[i]) {\n                    continue;\n                }\n                // obj could be number/string/... (like 0)\n                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\n                if (obj == null) {\n                    break;\n                }\n            }\n            if (obj == null && parentModel && !ignoreParent) {\n                obj = parentModel.get(path);\n            }\n            return obj;\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = this.parentModel;\n            if (val == null && parentModel && !ignoreParent) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string} path\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = this.get(path, true);\n            var thisParentModel = this.parentModel;\n            var model = new Model(\n                obj, parentModel || (thisParentModel && thisParentModel.getModel(path)),\n                this.ecModel\n            );\n            return model;\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        }\n    };\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, require('./mixin/lineStyle'));\n    mixin(Model, require('./mixin/areaStyle'));\n    mixin(Model, require('./mixin/textStyle'));\n    mixin(Model, require('./mixin/itemStyle'));\n\n    module.exports = Model;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Model.js\n// module id = 15\n// module chunks = 0 1","/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = require('./Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var arrayPush = Array.prototype.push;\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var layout = require('../util/layout');\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!this.hasOwnProperty('__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                this.__defaultOption = defaultOption;\n            }\n            return this.__defaultOption;\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n\n    module.exports = ComponentModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Component.js\n// module id = 18\n// module chunks = 0 1","'use strict';\n/**\n * 曲线辅助模块\n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // 临时变量\n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * 计算三次贝塞尔值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * 计算三次贝塞尔导数值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * 计算三次贝塞尔方程根，使用盛金公式\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算三次贝塞尔方程极限值的位置\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} 有效数目\n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 细分三次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * 投射点到三次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] 投射点\n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * 计算二次方贝塞尔值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * 计算二次方贝塞尔导数值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * 计算二次方贝塞尔方程根\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算二次贝塞尔方程极限值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * 细分二次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * 投射点到二次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out 投射点\n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/curve.js\n// module id = 20\n// module chunks = 0 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    /**\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (__DEV__) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (__DEV__) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\n            var Clazz = storage[componentTypeMain];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/clazz.js\n// module id = 21\n// module chunks = 0 1","'use strict';\n// Layout helpers for each component positioning\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n    var numberUtil = require('./number');\n    var formatUtil = require('./format');\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n        'left', 'right', 'top', 'bottom', 'width', 'height'\n    ];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            }\n            else {\n                height = containerHeight * 0.8;\n            }\n        }\n\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n\n    /**\n     * Position a zr element in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * Logic:\n     *     1. Scale (against origin point in parent coord)\n     *     2. Rotate (against origin point in parent coord)\n     *     3. Traslate (with el.position by this method)\n     * So this method only fixes the last step 'Traslate', which does not affect\n     * scaling and rotating.\n     *\n     * If be called repeatly with the same input el, the same result will be gotten.\n     *\n     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @param {Object} [opt]\n     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n     * @param {Array.<number>} [opt.boundingMode='all']\n     *        Specify how to calculate boundingRect when locating.\n     *        'all': Position the boundingRect that is transformed and uioned\n     *               both itself and its descendants.\n     *               This mode simplies confine the elements in the bounding\n     *               of their container (e.g., using 'right: 0').\n     *        'raw': Position the boundingRect that is not transformed and only itself.\n     *               This mode is useful when you want a element can overflow its\n     *               container. (Consider a rotated circle needs to be located in a corner.)\n     *               In this mode positionInfo.width/height can only be number.\n     */\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n        var h = !opt || !opt.hv || opt.hv[0];\n        var v = !opt || !opt.hv || opt.hv[1];\n        var boundingMode = opt && opt.boundingMode || 'all';\n\n        if (!h && !v) {\n            return;\n        }\n\n        var rect;\n        if (boundingMode === 'raw') {\n            rect = el.type === 'group'\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n                : el.getBoundingRect();\n        }\n        else {\n            rect = el.getBoundingRect();\n            if (el.needLocalTransform()) {\n                var transform = el.getLocalTransform();\n                // Notice: raw rect may be inner object of el,\n                // which should not be modified.\n                rect = rect.clone();\n                rect.applyTransform(transform);\n            }\n        }\n\n        positionInfo = layout.getLayoutRect(\n            zrUtil.defaults(\n                {width: rect.width, height: rect.height},\n                positionInfo\n            ),\n            containerRect,\n            margin\n        );\n\n        // Because 'tranlate' is the last step in transform\n        // (see zrender/core/Transformable#getLocalTransfrom),\n        // we can just only modify el.position to get final result.\n        var elPos = el.position;\n        var dx = h ? positionInfo.x - rect.x : 0;\n        var dy = v ? positionInfo.y - rect.y : 0;\n\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n        var hNames = ['width', 'left', 'right']; // Order by priority.\n        var vNames = ['height', 'top', 'bottom']; // Order by priority.\n        var hResult = merge(hNames);\n        var vResult = merge(vNames);\n\n        copy(hNames, targetOption, hResult);\n        copy(vNames, targetOption, vResult);\n\n        function merge(names) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/layout.js\n// module id = 25\n// module chunks = 0 1","\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME 高度计算比较粗暴\n        var lineHeight = getTextWidth('国', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var halfHeight = height / 2 - textHeight / 2;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('国', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/text.js\n// module id = 26\n// module chunks = 0 1","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2矩阵操作类\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * 创建一个单位矩阵\n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * 设置矩阵为单位矩阵\n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * 复制矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * 矩阵相乘\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * 平移变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * 旋转变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * 缩放变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * 求逆矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/matrix.js\n// module id = 27\n// module chunks = 0 1","/**\n * 事件扩展\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * 事件分发器\n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * 单次触发绑定，trigger后销毁\n         *\n         * @param {string} event 事件名\n         * @param {Function} handler 响应函数\n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 绑定事件\n         * @param {string} event 事件名\n         * @param {Function} handler 事件处理函数\n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 是否绑定了事件\n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * 解绑事件\n         * @param {string} event 事件名\n         * @param {Function} [handler] 事件处理函数\n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * 事件分发\n         *\n         * @param {string} type 事件类型\n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * 带有context的事件分发, 最后一个参数是事件回调的context\n         * @param {string} type 事件类型\n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    // 对象可以通过 onxxxx 绑定事件\n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Eventful.js\n// module id = 28\n// module chunks = 0 1","/**\n * @module zrender/tool/color\n */\n\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    /**\n     * @param {string} colorStr\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr) {\n        if (!colorStr) {\n            return;\n        }\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            return kCSSColorTable[str].slice();  // dup.\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                ];\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                ];\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return [\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    ];\n                case 'hsla':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    return hsla2rgba(params);\n                case 'hsl':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return hsla2rgba(params);\n                default:\n                    return;\n            }\n        }\n\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        var rgba = [\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n        ];\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n        out = out || [0, 0, 0, 0];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color.\n     */\n    function stringify(arrColor, type) {\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/color.js\n// module id = 29\n// module chunks = 0 1","exports = module.exports = require(\"./../../../css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".el-loading-mask{position:absolute;z-index:10000;background-color:hsla(0,0%,100%,.9);margin:0;top:0;right:0;bottom:0;left:0}.el-loading-mask.is-fullscreen{position:fixed}.el-loading-mask.is-fullscreen .el-loading-spinner{margin-top:-25px}.el-loading-mask.is-fullscreen .el-loading-spinner .circular{width:50px}.el-loading-spinner{top:50%;margin-top:-21px;width:100%;text-align:center;position:absolute}.el-loading-spinner .el-loading-text{color:#20a0ff;margin:3px 0;font-size:14px}.el-loading-spinner .circular{width:42px;-webkit-animation:rotate 2s linear infinite;animation:rotate 2s linear infinite}.el-loading-spinner .path{-webkit-animation:dash 1.5s ease-in-out infinite;animation:dash 1.5s ease-in-out infinite;stroke-dasharray:1,100;stroke-dashoffset:0;stroke-width:2;stroke:#20a0ff;stroke-linecap:round}@-webkit-keyframes rotate{to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes rotate{to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@-webkit-keyframes dash{0%{stroke-dasharray:1,100;stroke-dashoffset:0}50%{stroke-dasharray:45,100;stroke-dashoffset:-35px}to{stroke-dasharray:45,100;stroke-dashoffset:-124px}}@keyframes dash{0%{stroke-dasharray:1,100;stroke-dashoffset:0}50%{stroke-dasharray:45,100;stroke-dashoffset:-35px}to{stroke-dasharray:45,100;stroke-dashoffset:-124px}}\", \"\", {\"version\":3,\"sources\":[\"/./node_modules/element-ui/lib/theme-default/loading.css\"],\"names\":[],\"mappings\":\"AAAiB,iBAAiB,kBAAkB,cAAc,oCAAsC,SAAS,MAAM,QAAQ,SAAS,MAAM,CAAC,+BAA+B,cAAc,CAAC,mDAAmD,gBAAgB,CAAC,6DAA6D,UAAU,CAAC,oBAAoB,QAAQ,iBAAiB,WAAW,kBAAkB,iBAAiB,CAAC,qCAAqC,cAAc,aAAa,cAAc,CAAC,8BAA8B,WAAW,4CAAA,mCAAmC,CAAC,0BAA0B,iDAAA,yCAAyC,uBAAuB,oBAAoB,eAAe,eAAe,oBAAoB,CAAC,0BAAkB,GAAK,gCAAA,uBAAwB,CAAC,CAAhD,kBAAkB,GAAK,gCAAA,uBAAwB,CAAC,CAAC,wBAAgB,GAAG,uBAAuB,mBAAmB,CAAC,IAAI,wBAAwB,uBAAuB,CAAC,GAAK,wBAAwB,wBAAwB,CAAC,CAAxK,gBAAgB,GAAG,uBAAuB,mBAAmB,CAAC,IAAI,wBAAwB,uBAAuB,CAAC,GAAK,wBAAwB,wBAAwB,CAAC,CAAC\",\"file\":\"loading.css\",\"sourcesContent\":[\"@charset \\\"UTF-8\\\";.el-loading-mask{position:absolute;z-index:10000;background-color:rgba(255,255,255,.9);margin:0;top:0;right:0;bottom:0;left:0}.el-loading-mask.is-fullscreen{position:fixed}.el-loading-mask.is-fullscreen .el-loading-spinner{margin-top:-25px}.el-loading-mask.is-fullscreen .el-loading-spinner .circular{width:50px}.el-loading-spinner{top:50%;margin-top:-21px;width:100%;text-align:center;position:absolute}.el-loading-spinner .el-loading-text{color:#20a0ff;margin:3px 0;font-size:14px}.el-loading-spinner .circular{width:42px;animation:rotate 2s linear infinite}.el-loading-spinner .path{animation:dash 1.5s ease-in-out infinite;stroke-dasharray:1,100;stroke-dashoffset:0;stroke-width:2;stroke:#20a0ff;stroke-linecap:round}@keyframes rotate{100%{transform:rotate(360deg)}}@keyframes dash{0%{stroke-dasharray:1,100;stroke-dashoffset:0}50%{stroke-dasharray:45,100;stroke-dashoffset:-35px}100%{stroke-dasharray:45,100;stroke-dashoffset:-124px}}\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?-autoprefixer&sourceMap!./~/postcss-loader!./~/element-ui/lib/theme-default/loading.css\n// module id = 36\n// module chunks = 0 1 2 3 4","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(117);\n\n\n/***/ },\n\n/***/ 50:\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"vue\");\n\n/***/ },\n\n/***/ 66:\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"wind-dom/src/class\");\n\n/***/ },\n\n/***/ 117:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _directive = __webpack_require__(118);\n\n\tvar _directive2 = _interopRequireDefault(_directive);\n\n\tvar _index = __webpack_require__(122);\n\n\tvar _index2 = _interopRequireDefault(_index);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = {\n\t  install: function install(Vue) {\n\t    Vue.use(_directive2.default);\n\t    Vue.prototype.$loading = _index2.default;\n\t  },\n\n\t  directive: _directive2.default,\n\t  service: _index2.default\n\t};\n\n/***/ },\n\n/***/ 118:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _vue = __webpack_require__(50);\n\n\tvar _vue2 = _interopRequireDefault(_vue);\n\n\tvar _class = __webpack_require__(66);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar Mask = _vue2.default.extend(__webpack_require__(119));\n\n\texports.install = function (Vue) {\n\t  var toggleLoading = function toggleLoading(el, binding) {\n\t    if (binding.value) {\n\t      Vue.nextTick(function () {\n\t        if (binding.modifiers.fullscreen) {\n\t          el.originalPosition = document.body.style.position;\n\t          el.originalOverflow = document.body.style.overflow;\n\n\t          (0, _class.addClass)(el.mask, 'is-fullscreen');\n\t          insertDom(document.body, el, binding);\n\t        } else {\n\t          (0, _class.removeClass)(el.mask, 'is-fullscreen');\n\n\t          if (binding.modifiers.body) {\n\t            el.originalPosition = document.body.style.position;\n\n\t            ['top', 'left'].forEach(function (property) {\n\t              var scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';\n\t              el.maskStyle[property] = el.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] + 'px';\n\t            });\n\t            ['height', 'width'].forEach(function (property) {\n\t              el.maskStyle[property] = el.getBoundingClientRect()[property] + 'px';\n\t            });\n\n\t            insertDom(document.body, el, binding);\n\t          } else {\n\t            el.originalPosition = el.style.position;\n\t            insertDom(el, el, binding);\n\t          }\n\t        }\n\t      });\n\t    } else {\n\t      if (el.domVisible) {\n\t        el.mask.style.display = 'none';\n\t        el.domVisible = false;\n\n\t        if (binding.modifiers.fullscreen && el.originalOverflow !== 'hidden') {\n\t          document.body.style.overflow = el.originalOverflow;\n\t        }\n\t        if (binding.modifiers.fullscreen || binding.modifiers.body) {\n\t          document.body.style.position = el.originalPosition;\n\t        } else {\n\t          el.style.position = el.originalPosition;\n\t        }\n\t      }\n\t    }\n\t  };\n\t  var insertDom = function insertDom(parent, directive, binding) {\n\t    if (!directive.domVisible) {\n\t      Object.keys(directive.maskStyle).forEach(function (property) {\n\t        directive.mask.style[property] = directive.maskStyle[property];\n\t      });\n\n\t      if (directive.originalPosition !== 'absolute') {\n\t        parent.style.position = 'relative';\n\t      }\n\t      if (binding.modifiers.fullscreen && binding.modifiers.lock) {\n\t        parent.style.overflow = 'hidden';\n\t      }\n\t      directive.mask.style.display = 'block';\n\t      directive.domVisible = true;\n\n\t      parent.appendChild(directive.mask);\n\t      directive.domInserted = true;\n\t    }\n\t  };\n\n\t  Vue.directive('loading', {\n\t    bind: function bind(el, binding) {\n\t      var mask = new Mask({\n\t        el: document.createElement('div'),\n\t        data: {\n\t          text: el.getAttribute('element-loading-text'),\n\t          fullscreen: !!binding.modifiers.fullscreen\n\t        }\n\t      });\n\t      el.mask = mask.$el;\n\t      el.maskStyle = {};\n\n\t      toggleLoading(el, binding);\n\t    },\n\n\t    update: function update(el, binding) {\n\t      if (binding.oldValue !== binding.value) {\n\t        toggleLoading(el, binding);\n\t      }\n\t    },\n\n\t    unbind: function unbind(el, binding) {\n\t      if (el.domInserted) {\n\t        if (binding.modifiers.fullscreen || binding.modifiers.body) {\n\t          document.body.removeChild(el.mask);\n\t        } else {\n\t          el.mask && el.mask.parentNode && el.mask.parentNode.removeChild(el.mask);\n\t        }\n\t      }\n\t    }\n\t  });\n\t};\n\n/***/ },\n\n/***/ 119:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_exports__, __vue_options__\n\tvar __vue_styles__ = {}\n\n\t/* script */\n\t__vue_exports__ = __webpack_require__(120)\n\n\t/* template */\n\tvar __vue_template__ = __webpack_require__(121)\n\t__vue_options__ = __vue_exports__ = __vue_exports__ || {}\n\tif (\n\t  typeof __vue_exports__.default === \"object\" ||\n\t  typeof __vue_exports__.default === \"function\"\n\t) {\n\t__vue_options__ = __vue_exports__ = __vue_exports__.default\n\t}\n\tif (typeof __vue_options__ === \"function\") {\n\t  __vue_options__ = __vue_options__.options\n\t}\n\n\t__vue_options__.render = __vue_template__.render\n\t__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\n\tmodule.exports = __vue_exports__\n\n\n/***/ },\n\n/***/ 120:\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\n\texports.default = {\n\t  data: function data() {\n\t    return {\n\t      text: null,\n\t      fullscreen: true,\n\t      customClass: ''\n\t    };\n\t  }\n\t};\n\n/***/ },\n\n/***/ 121:\n/***/ function(module, exports) {\n\n\tmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._c;\n\t  return _h('div', {\n\t    staticClass: \"el-loading-mask\",\n\t    class: [_vm.customClass, {\n\t      'is-fullscreen': _vm.fullscreen\n\t    }]\n\t  }, [_h('div', {\n\t    staticClass: \"el-loading-spinner\"\n\t  }, [_h('svg', {\n\t    staticClass: \"circular\",\n\t    attrs: {\n\t      \"viewBox\": \"25 25 50 50\"\n\t    }\n\t  }, [_h('circle', {\n\t    staticClass: \"path\",\n\t    attrs: {\n\t      \"cx\": \"50\",\n\t      \"cy\": \"50\",\n\t      \"r\": \"20\",\n\t      \"fill\": \"none\"\n\t    }\n\t  })]), (_vm.text) ? _h('p', {\n\t    staticClass: \"el-loading-text\"\n\t  }, [_vm._s(_vm.text)]) : _vm._e()])])\n\t},staticRenderFns: []}\n\n/***/ },\n\n/***/ 122:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _vue = __webpack_require__(50);\n\n\tvar _vue2 = _interopRequireDefault(_vue);\n\n\tvar _loading = __webpack_require__(119);\n\n\tvar _loading2 = _interopRequireDefault(_loading);\n\n\tvar _merge = __webpack_require__(123);\n\n\tvar _merge2 = _interopRequireDefault(_merge);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar LoadingConstructor = _vue2.default.extend(_loading2.default);\n\n\tvar defaults = {\n\t  text: null,\n\t  fullscreen: true,\n\t  body: false,\n\t  lock: false,\n\t  customClass: ''\n\t};\n\n\tvar fullscreenLoading = void 0;\n\n\tLoadingConstructor.prototype.originalPosition = '';\n\tLoadingConstructor.prototype.originalOverflow = '';\n\n\tLoadingConstructor.prototype.close = function () {\n\t  if (this.fullscreen && this.originalOverflow !== 'hidden') {\n\t    document.body.style.overflow = this.originalOverflow;\n\t  }\n\t  if (this.fullscreen || this.body) {\n\t    document.body.style.position = this.originalPosition;\n\t  } else {\n\t    this.target.style.position = this.originalPosition;\n\t  }\n\t  if (this.fullscreen) {\n\t    fullscreenLoading = undefined;\n\t  }\n\t  this.$el && this.$el.parentNode && this.$el.parentNode.removeChild(this.$el);\n\t  this.$destroy();\n\t};\n\n\tvar addStyle = function addStyle(options, parent, instance) {\n\t  var maskStyle = {};\n\t  if (options.fullscreen) {\n\t    instance.originalPosition = document.body.style.position;\n\t    instance.originalOverflow = document.body.style.overflow;\n\t  } else if (options.body) {\n\t    instance.originalPosition = document.body.style.position;\n\t    ['top', 'left'].forEach(function (property) {\n\t      var scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';\n\t      maskStyle[property] = options.target.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] + 'px';\n\t    });\n\t    ['height', 'width'].forEach(function (property) {\n\t      maskStyle[property] = options.target.getBoundingClientRect()[property] + 'px';\n\t    });\n\t  } else {\n\t    instance.originalPosition = parent.style.position;\n\t  }\n\t  Object.keys(maskStyle).forEach(function (property) {\n\t    instance.$el.style[property] = maskStyle[property];\n\t  });\n\t};\n\n\tvar Loading = function Loading() {\n\t  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t  options = (0, _merge2.default)({}, defaults, options);\n\t  if (typeof options.target === 'string') {\n\t    options.target = document.querySelector(options.target);\n\t  }\n\t  options.target = options.target || document.body;\n\t  if (options.target !== document.body) {\n\t    options.fullscreen = false;\n\t  } else {\n\t    options.body = true;\n\t  }\n\t  if (options.fullscreen && fullscreenLoading) {\n\t    return fullscreenLoading;\n\t  }\n\n\t  var parent = options.body ? document.body : options.target;\n\t  var instance = new LoadingConstructor({\n\t    el: document.createElement('div'),\n\t    data: options\n\t  });\n\n\t  addStyle(options, parent, instance);\n\t  if (instance.originalPosition !== 'absolute') {\n\t    parent.style.position = 'relative';\n\t  }\n\t  if (options.fullscreen && options.lock) {\n\t    parent.style.overflow = 'hidden';\n\t  }\n\t  parent.appendChild(instance.$el);\n\t  if (options.fullscreen) {\n\t    fullscreenLoading = instance;\n\t  }\n\t  return instance;\n\t};\n\n\texports.default = Loading;\n\n/***/ },\n\n/***/ 123:\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"element-ui/lib/utils/merge\");\n\n/***/ }\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/element-ui/lib/loading.js\n// module id = 37\n// module chunks = 0 1 2 3 4","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../css-loader/index.js?-autoprefixer&sourceMap!./../../../postcss-loader/index.js!./loading.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../css-loader/index.js?-autoprefixer&sourceMap!./../../../postcss-loader/index.js!./loading.css\", function() {\n\t\t\tvar newContent = require(\"!!./../../../css-loader/index.js?-autoprefixer&sourceMap!./../../../postcss-loader/index.js!./loading.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/element-ui/lib/theme-default/loading.css\n// module id = 38\n// module chunks = 0 1 2 3 4","\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config默认配置项\n     * @exports zrender/config\n     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debug日志选项：catchBrushException为true下有效\n         * 0 : 不生成debug数据，发布用\n         * 1 : 异常抛出，调试用\n         * 2 : 控制台输出，调试用\n         */\n        debugMode: 0,\n\n        // retina 屏幕优化\n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/config.js\n// module id = 39\n// module chunks = 0 1","/**\n * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * 所有子孙元素是否响应鼠标事件\n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         * 获取指定 index 的儿子节点\n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * 获取指定名字的儿子节点\n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * 添加子节点到最后\n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         * 添加子节点在 nextSibling 之前\n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToMap(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * 移除子节点\n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromMap(child.id);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * 移除所有子节点\n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * 遍历所有子节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * 深度优先遍历所有子孙节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/container/Group.js\n// module id = 40\n// module chunks = 0 1","'use strict';\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n\n        this._len = 0;\n\n        this._ctx = null;\n\n        this._xi = 0;\n        this._yi = 0;\n\n        this._x0 = 0;\n        this._y0 = 0;\n\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n\n    /**\n     * 快速计算Path包围盒（并不是最小包围盒）\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            this._len = 0;\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._xi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n         * stroke 同样\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         * 直接设置 Path 数据\n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * 添加子路径\n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         * 填充 Path 数据。\n         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n         */\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                // 因为之前的数组已经转换成静态的 Float32Array\n                // 所以不够用时需要扩展一个新的动态数组\n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         * 转成静态的 Float32Array 减少堆内存占用\n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                        // 在 closePath 的时候使用\n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc 判断的开销比较大\n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc 旋转\n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/PathProxy.js\n// module id = 41\n// module chunks = 0 1","'use strict';\n/**\n * 事件辅助类\n * @module zrender/core/event\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');\n    var env = require('./env');\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * 停止冒泡和阻止默认行为\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event对象\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // 做向上兼容\n        Dispatcher: Eventful\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/event.js\n// module id = 42\n// module chunks = 0 1","// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/makeStyleMapper.js\n// module id = 43\n// module chunks = 0 1","\n    module.exports = {\n        clearColorPalette: function () {\n            this._colorIdx = 0;\n            this._colorNameMap = {};\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = scope._colorIdx || 0;\n            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});\n            if (colorNameMap[name]) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            scope._colorIdx = (colorIdx + 1) % colorPalette.length;\n\n            return color;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/colorPalette.js\n// module id = 47\n// module chunks = 0 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazz = require('./clazz');\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/component.js\n// module id = 48\n// module chunks = 0 1","'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version {{version}}\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n//\n// Cross module loader\n// Supported: Node, AMD, Browser globals\n//\n;(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(factory);\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.Popper = factory();\n    }\n})(undefined, function () {\n\n    'use strict';\n\n    var root = window;\n\n    // default options\n    var DEFAULTS = {\n        // placement of the popper\n        placement: 'bottom',\n\n        gpuAcceleration: true,\n\n        // shift popper from its origin by the given amount of pixels (can be negative)\n        offset: 0,\n\n        // the element which will act as boundary of the popper\n        boundariesElement: 'viewport',\n\n        // amount of pixel used to define a minimum distance between the boundaries and the popper\n        boundariesPadding: 5,\n\n        // popper will try to prevent overflow following this order,\n        // by default, then, it could overflow on the left and on top of the boundariesElement\n        preventOverflowOrder: ['left', 'right', 'top', 'bottom'],\n\n        // the behavior used by flip to change the placement of the popper\n        flipBehavior: 'flip',\n\n        arrowElement: '[x-arrow]',\n\n        // list of functions used to modify the offsets before they are applied to the popper\n        modifiers: ['shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle'],\n\n        modifiersIgnored: [],\n\n        forceAbsolute: false\n    };\n\n    /**\n     * Create a new Popper.js instance\n     * @constructor Popper\n     * @param {HTMLElement} reference - The reference element used to position the popper\n     * @param {HTMLElement|Object} popper\n     *      The HTML element used as popper, or a configuration used to generate the popper.\n     * @param {String} [popper.tagName='div'] The tag name of the generated popper.\n     * @param {Array} [popper.classNames=['popper']] Array of classes to apply to the generated popper.\n     * @param {Array} [popper.attributes] Array of attributes to apply, specify `attr:value` to assign a value to it.\n     * @param {HTMLElement|String} [popper.parent=window.document.body] The parent element, given as HTMLElement or as query string.\n     * @param {String} [popper.content=''] The content of the popper, it can be text, html, or node; if it is not text, set `contentType` to `html` or `node`.\n     * @param {String} [popper.contentType='text'] If `html`, the `content` will be parsed as HTML. If `node`, it will be appended as-is.\n     * @param {String} [popper.arrowTagName='div'] Same as `popper.tagName` but for the arrow element.\n     * @param {Array} [popper.arrowClassNames='popper__arrow'] Same as `popper.classNames` but for the arrow element.\n     * @param {String} [popper.arrowAttributes=['x-arrow']] Same as `popper.attributes` but for the arrow element.\n     * @param {Object} options\n     * @param {String} [options.placement=bottom]\n     *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -right),\n     *      left(-start, -end)`\n     *\n     * @param {HTMLElement|String} [options.arrowElement='[x-arrow]']\n     *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of\n     *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its\n     *      reference element.\n     *      By default, it will look for a child node of the popper with the `x-arrow` attribute.\n     *\n     * @param {Boolean} [options.gpuAcceleration=true]\n     *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the\n     *      browser to use the GPU to accelerate the rendering.\n     *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.\n     *\n     * @param {Number} [options.offset=0]\n     *      Amount of pixels the popper will be shifted (can be negative).\n     *\n     * @param {String|Element} [options.boundariesElement='viewport']\n     *      The element which will define the boundaries of the popper position, the popper will never be placed outside\n     *      of the defined boundaries (except if `keepTogether` is enabled)\n     *\n     * @param {Number} [options.boundariesPadding=5]\n     *      Additional padding for the boundaries\n     *\n     * @param {Array} [options.preventOverflowOrder=['left', 'right', 'top', 'bottom']]\n     *      Order used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,\n     *      this means that the last ones will never overflow\n     *\n     * @param {String|Array} [options.flipBehavior='flip']\n     *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to\n     *      overlap its reference element. Defining `flip` as value, the placement will be flipped on\n     *      its axis (`right - left`, `top - bottom`).\n     *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify\n     *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,\n     *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)\n     *\n     * @param {Array} [options.modifiers=[ 'shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle']]\n     *      List of functions used to modify the data before they are applied to the popper, add your custom functions\n     *      to this array to edit the offsets and placement.\n     *      The function should reflect the @params and @returns of preventOverflow\n     *\n     * @param {Array} [options.modifiersIgnored=[]]\n     *      Put here any built-in modifier name you want to exclude from the modifiers list\n     *      The function should reflect the @params and @returns of preventOverflow\n     *\n     * @param {Boolean} [options.removeOnDestroy=false]\n     *      Set to true if you want to automatically remove the popper when you call the `destroy` method.\n     */\n    function Popper(reference, popper, options) {\n        this._reference = reference.jquery ? reference[0] : reference;\n        this.state = {};\n\n        // if the popper variable is a configuration object, parse it to generate an HTMLElement\n        // generate a default popper if is not defined\n        var isNotDefined = typeof popper === 'undefined' || popper === null;\n        var isConfig = popper && Object.prototype.toString.call(popper) === '[object Object]';\n        if (isNotDefined || isConfig) {\n            this._popper = this.parse(isConfig ? popper : {});\n        }\n        // otherwise, use the given HTMLElement as popper\n        else {\n                this._popper = popper.jquery ? popper[0] : popper;\n            }\n\n        // with {} we create a new object with the options inside it\n        this._options = Object.assign({}, DEFAULTS, options);\n\n        // refactoring modifiers' list\n        this._options.modifiers = this._options.modifiers.map(function (modifier) {\n            // remove ignored modifiers\n            if (this._options.modifiersIgnored.indexOf(modifier) !== -1) return;\n\n            // set the x-placement attribute before everything else because it could be used to add margins to the popper\n            // margins needs to be calculated to get the correct popper offsets\n            if (modifier === 'applyStyle') {\n                this._popper.setAttribute('x-placement', this._options.placement);\n            }\n\n            // return predefined modifier identified by string or keep the custom one\n            return this.modifiers[modifier] || modifier;\n        }.bind(this));\n\n        // make sure to apply the popper position before any computation\n        this.state.position = this._getPosition(this._popper, this._reference);\n        setStyle(this._popper, { position: this.state.position });\n\n        // fire the first update to position the popper in the right place\n        this.update();\n\n        // setup event listeners, they will take care of update the position in specific situations\n        this._setupEventListeners();\n        return this;\n    }\n\n    //\n    // Methods\n    //\n    /**\n     * Destroy the popper\n     * @method\n     * @memberof Popper\n     */\n    Popper.prototype.destroy = function () {\n        this._popper.removeAttribute('x-placement');\n        this._popper.style.left = '';\n        this._popper.style.position = '';\n        this._popper.style.top = '';\n        this._popper.style[getSupportedPropertyName('transform')] = '';\n        this._removeEventListeners();\n\n        // remove the popper if user explicity asked for the deletion on destroy\n        if (this._options.removeOnDestroy) {\n            this._popper.remove();\n        }\n        return this;\n    };\n\n    /**\n     * Updates the position of the popper, computing the new offsets and applying the new style\n     * @method\n     * @memberof Popper\n     */\n    Popper.prototype.update = function () {\n        var data = { instance: this, styles: {} };\n\n        // store placement inside the data object, modifiers will be able to edit `placement` if needed\n        // and refer to _originalPlacement to know the original value\n        data.placement = this._options.placement;\n        data._originalPlacement = this._options.placement;\n\n        // compute the popper and reference offsets and put them inside data.offsets\n        data.offsets = this._getOffsets(this._popper, this._reference, data.placement);\n\n        // get boundaries\n        data.boundaries = this._getBoundaries(data, this._options.boundariesPadding, this._options.boundariesElement);\n\n        data = this.runModifiers(data, this._options.modifiers);\n\n        if (typeof this.state.updateCallback === 'function') {\n            this.state.updateCallback(data);\n        }\n    };\n\n    /**\n     * If a function is passed, it will be executed after the initialization of popper with as first argument the Popper instance.\n     * @method\n     * @memberof Popper\n     * @param {Function} callback\n     */\n    Popper.prototype.onCreate = function (callback) {\n        // the createCallbacks return as first argument the popper instance\n        callback(this);\n        return this;\n    };\n\n    /**\n     * If a function is passed, it will be executed after each update of popper with as first argument the set of coordinates and informations\n     * used to style popper and its arrow.\n     * NOTE: it doesn't get fired on the first call of the `Popper.update()` method inside the `Popper` constructor!\n     * @method\n     * @memberof Popper\n     * @param {Function} callback\n     */\n    Popper.prototype.onUpdate = function (callback) {\n        this.state.updateCallback = callback;\n        return this;\n    };\n\n    /**\n     * Helper used to generate poppers from a configuration file\n     * @method\n     * @memberof Popper\n     * @param config {Object} configuration\n     * @returns {HTMLElement} popper\n     */\n    Popper.prototype.parse = function (config) {\n        var defaultConfig = {\n            tagName: 'div',\n            classNames: ['popper'],\n            attributes: [],\n            parent: root.document.body,\n            content: '',\n            contentType: 'text',\n            arrowTagName: 'div',\n            arrowClassNames: ['popper__arrow'],\n            arrowAttributes: ['x-arrow']\n        };\n        config = Object.assign({}, defaultConfig, config);\n\n        var d = root.document;\n\n        var popper = d.createElement(config.tagName);\n        addClassNames(popper, config.classNames);\n        addAttributes(popper, config.attributes);\n        if (config.contentType === 'node') {\n            popper.appendChild(config.content.jquery ? config.content[0] : config.content);\n        } else if (config.contentType === 'html') {\n            popper.innerHTML = config.content;\n        } else {\n            popper.textContent = config.content;\n        }\n\n        if (config.arrowTagName) {\n            var arrow = d.createElement(config.arrowTagName);\n            addClassNames(arrow, config.arrowClassNames);\n            addAttributes(arrow, config.arrowAttributes);\n            popper.appendChild(arrow);\n        }\n\n        var parent = config.parent.jquery ? config.parent[0] : config.parent;\n\n        // if the given parent is a string, use it to match an element\n        // if more than one element is matched, the first one will be used as parent\n        // if no elements are matched, the script will throw an error\n        if (typeof parent === 'string') {\n            parent = d.querySelectorAll(config.parent);\n            if (parent.length > 1) {\n                console.warn('WARNING: the given `parent` query(' + config.parent + ') matched more than one element, the first one will be used');\n            }\n            if (parent.length === 0) {\n                throw 'ERROR: the given `parent` doesn\\'t exists!';\n            }\n            parent = parent[0];\n        }\n        // if the given parent is a DOM nodes list or an array of nodes with more than one element,\n        // the first one will be used as parent\n        if (parent.length > 1 && parent instanceof Element === false) {\n            console.warn('WARNING: you have passed as parent a list of elements, the first one will be used');\n            parent = parent[0];\n        }\n\n        // append the generated popper to its parent\n        parent.appendChild(popper);\n\n        return popper;\n\n        /**\n         * Adds class names to the given element\n         * @function\n         * @ignore\n         * @param {HTMLElement} target\n         * @param {Array} classes\n         */\n        function addClassNames(element, classNames) {\n            classNames.forEach(function (className) {\n                element.classList.add(className);\n            });\n        }\n\n        /**\n         * Adds attributes to the given element\n         * @function\n         * @ignore\n         * @param {HTMLElement} target\n         * @param {Array} attributes\n         * @example\n         * addAttributes(element, [ 'data-info:foobar' ]);\n         */\n        function addAttributes(element, attributes) {\n            attributes.forEach(function (attribute) {\n                element.setAttribute(attribute.split(':')[0], attribute.split(':')[1] || '');\n            });\n        }\n    };\n\n    /**\n     * Helper used to get the position which will be applied to the popper\n     * @method\n     * @memberof Popper\n     * @param config {HTMLElement} popper element\n     * @returns {HTMLElement} reference element\n     */\n    Popper.prototype._getPosition = function (popper, reference) {\n        var container = getOffsetParent(reference);\n\n        if (this._options.forceAbsolute) {\n            return 'absolute';\n        }\n\n        // Decide if the popper will be fixed\n        // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together\n        var isParentFixed = isFixed(reference, container);\n        return isParentFixed ? 'fixed' : 'absolute';\n    };\n\n    /**\n     * Get offsets to the popper\n     * @method\n     * @memberof Popper\n     * @access private\n     * @param {Element} popper - the popper element\n     * @param {Element} reference - the reference element (the popper will be relative to this)\n     * @returns {Object} An object containing the offsets which will be applied to the popper\n     */\n    Popper.prototype._getOffsets = function (popper, reference, placement) {\n        placement = placement.split('-')[0];\n        var popperOffsets = {};\n\n        popperOffsets.position = this.state.position;\n        var isParentFixed = popperOffsets.position === 'fixed';\n\n        //\n        // Get reference element position\n        //\n        var referenceOffsets = getOffsetRectRelativeToCustomParent(reference, getOffsetParent(popper), isParentFixed);\n\n        //\n        // Get popper sizes\n        //\n        var popperRect = getOuterSizes(popper);\n\n        //\n        // Compute offsets of popper\n        //\n\n        // depending by the popper placement we have to compute its offsets slightly differently\n        if (['right', 'left'].indexOf(placement) !== -1) {\n            popperOffsets.top = referenceOffsets.top + referenceOffsets.height / 2 - popperRect.height / 2;\n            if (placement === 'left') {\n                popperOffsets.left = referenceOffsets.left - popperRect.width;\n            } else {\n                popperOffsets.left = referenceOffsets.right;\n            }\n        } else {\n            popperOffsets.left = referenceOffsets.left + referenceOffsets.width / 2 - popperRect.width / 2;\n            if (placement === 'top') {\n                popperOffsets.top = referenceOffsets.top - popperRect.height;\n            } else {\n                popperOffsets.top = referenceOffsets.bottom;\n            }\n        }\n\n        // Add width and height to our offsets object\n        popperOffsets.width = popperRect.width;\n        popperOffsets.height = popperRect.height;\n\n        return {\n            popper: popperOffsets,\n            reference: referenceOffsets\n        };\n    };\n\n    /**\n     * Setup needed event listeners used to update the popper position\n     * @method\n     * @memberof Popper\n     * @access private\n     */\n    Popper.prototype._setupEventListeners = function () {\n        // NOTE: 1 DOM access here\n        this.state.updateBound = this.update.bind(this);\n        root.addEventListener('resize', this.state.updateBound);\n        // if the boundariesElement is window we don't need to listen for the scroll event\n        if (this._options.boundariesElement !== 'window') {\n            var target = getScrollParent(this._reference);\n            // here it could be both `body` or `documentElement` thanks to Firefox, we then check both\n            if (target === root.document.body || target === root.document.documentElement) {\n                target = root;\n            }\n            target.addEventListener('scroll', this.state.updateBound);\n        }\n    };\n\n    /**\n     * Remove event listeners used to update the popper position\n     * @method\n     * @memberof Popper\n     * @access private\n     */\n    Popper.prototype._removeEventListeners = function () {\n        // NOTE: 1 DOM access here\n        root.removeEventListener('resize', this.state.updateBound);\n        if (this._options.boundariesElement !== 'window') {\n            var target = getScrollParent(this._reference);\n            // here it could be both `body` or `documentElement` thanks to Firefox, we then check both\n            if (target === root.document.body || target === root.document.documentElement) {\n                target = root;\n            }\n            target.removeEventListener('scroll', this.state.updateBound);\n        }\n        this.state.updateBound = null;\n    };\n\n    /**\n     * Computed the boundaries limits and return them\n     * @method\n     * @memberof Popper\n     * @access private\n     * @param {Object} data - Object containing the property \"offsets\" generated by `_getOffsets`\n     * @param {Number} padding - Boundaries padding\n     * @param {Element} boundariesElement - Element used to define the boundaries\n     * @returns {Object} Coordinates of the boundaries\n     */\n    Popper.prototype._getBoundaries = function (data, padding, boundariesElement) {\n        // NOTE: 1 DOM access here\n        var boundaries = {};\n        var width, height;\n        if (boundariesElement === 'window') {\n            var body = root.document.body,\n                html = root.document.documentElement;\n\n            height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n            width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);\n\n            boundaries = {\n                top: 0,\n                right: width,\n                bottom: height,\n                left: 0\n            };\n        } else if (boundariesElement === 'viewport') {\n            var offsetParent = getOffsetParent(this._popper);\n            var scrollParent = getScrollParent(this._popper);\n            var offsetParentRect = getOffsetRect(offsetParent);\n\n            // if the popper is fixed we don't have to substract scrolling from the boundaries\n            var scrollTop = data.offsets.popper.position === 'fixed' ? 0 : scrollParent.scrollTop;\n            var scrollLeft = data.offsets.popper.position === 'fixed' ? 0 : scrollParent.scrollLeft;\n\n            boundaries = {\n                top: 0 - (offsetParentRect.top - scrollTop),\n                right: root.document.documentElement.clientWidth - (offsetParentRect.left - scrollLeft),\n                bottom: root.document.documentElement.clientHeight - (offsetParentRect.top - scrollTop),\n                left: 0 - (offsetParentRect.left - scrollLeft)\n            };\n        } else {\n            if (getOffsetParent(this._popper) === boundariesElement) {\n                boundaries = {\n                    top: 0,\n                    left: 0,\n                    right: boundariesElement.clientWidth,\n                    bottom: boundariesElement.clientHeight\n                };\n            } else {\n                boundaries = getOffsetRect(boundariesElement);\n            }\n        }\n        boundaries.left += padding;\n        boundaries.right -= padding;\n        boundaries.top = boundaries.top + padding;\n        boundaries.bottom = boundaries.bottom - padding;\n        return boundaries;\n    };\n\n    /**\n     * Loop trough the list of modifiers and run them in order, each of them will then edit the data object\n     * @method\n     * @memberof Popper\n     * @access public\n     * @param {Object} data\n     * @param {Array} modifiers\n     * @param {Function} ends\n     */\n    Popper.prototype.runModifiers = function (data, modifiers, ends) {\n        var modifiersToRun = modifiers.slice();\n        if (ends !== undefined) {\n            modifiersToRun = this._options.modifiers.slice(0, getArrayKeyIndex(this._options.modifiers, ends));\n        }\n\n        modifiersToRun.forEach(function (modifier) {\n            if (isFunction(modifier)) {\n                data = modifier.call(this, data);\n            }\n        }.bind(this));\n\n        return data;\n    };\n\n    /**\n     * Helper used to know if the given modifier depends from another one.\n     * @method\n     * @memberof Popper\n     * @returns {Boolean}\n     */\n\n    Popper.prototype.isModifierRequired = function (requesting, requested) {\n        var index = getArrayKeyIndex(this._options.modifiers, requesting);\n        return !!this._options.modifiers.slice(0, index).filter(function (modifier) {\n            return modifier === requested;\n        }).length;\n    };\n\n    //\n    // Modifiers\n    //\n\n    /**\n     * Modifiers list\n     * @namespace Popper.modifiers\n     * @memberof Popper\n     * @type {Object}\n     */\n    Popper.prototype.modifiers = {};\n\n    /**\n     * Apply the computed styles to the popper element\n     * @method\n     * @memberof Popper.modifiers\n     * @argument {Object} data - The data object generated by `update` method\n     * @returns {Object} The same data object\n     */\n    Popper.prototype.modifiers.applyStyle = function (data) {\n        // apply the final offsets to the popper\n        // NOTE: 1 DOM access here\n        var styles = {\n            position: data.offsets.popper.position\n        };\n\n        // round top and left to avoid blurry text\n        var left = Math.round(data.offsets.popper.left);\n        var top = Math.round(data.offsets.popper.top);\n\n        // if gpuAcceleration is set to true and transform is supported, we use `translate3d` to apply the position to the popper\n        // we automatically use the supported prefixed version if needed\n        var prefixedProperty;\n        if (this._options.gpuAcceleration && (prefixedProperty = getSupportedPropertyName('transform'))) {\n            styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n            styles.top = 0;\n            styles.left = 0;\n        }\n        // othwerise, we use the standard `left` and `top` properties\n        else {\n                styles.left = left;\n                styles.top = top;\n            }\n\n        // any property present in `data.styles` will be applied to the popper,\n        // in this way we can make the 3rd party modifiers add custom styles to it\n        // Be aware, modifiers could override the properties defined in the previous\n        // lines of this modifier!\n        Object.assign(styles, data.styles);\n\n        setStyle(this._popper, styles);\n\n        // set an attribute which will be useful to style the tooltip (use it to properly position its arrow)\n        // NOTE: 1 DOM access here\n        this._popper.setAttribute('x-placement', data.placement);\n\n        // if the arrow modifier is required and the arrow style has been computed, apply the arrow style\n        if (this.isModifierRequired(this.modifiers.applyStyle, this.modifiers.arrow) && data.offsets.arrow) {\n            setStyle(data.arrowElement, data.offsets.arrow);\n        }\n\n        return data;\n    };\n\n    /**\n     * Modifier used to shift the popper on the start or end of its reference element side\n     * @method\n     * @memberof Popper.modifiers\n     * @argument {Object} data - The data object generated by `update` method\n     * @returns {Object} The data object, properly modified\n     */\n    Popper.prototype.modifiers.shift = function (data) {\n        var placement = data.placement;\n        var basePlacement = placement.split('-')[0];\n        var shiftVariation = placement.split('-')[1];\n\n        // if shift shiftVariation is specified, run the modifier\n        if (shiftVariation) {\n            var reference = data.offsets.reference;\n            var popper = getPopperClientRect(data.offsets.popper);\n\n            var shiftOffsets = {\n                y: {\n                    start: { top: reference.top },\n                    end: { top: reference.top + reference.height - popper.height }\n                },\n                x: {\n                    start: { left: reference.left },\n                    end: { left: reference.left + reference.width - popper.width }\n                }\n            };\n\n            var axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';\n\n            data.offsets.popper = Object.assign(popper, shiftOffsets[axis][shiftVariation]);\n        }\n\n        return data;\n    };\n\n    /**\n     * Modifier used to make sure the popper does not overflows from it's boundaries\n     * @method\n     * @memberof Popper.modifiers\n     * @argument {Object} data - The data object generated by `update` method\n     * @returns {Object} The data object, properly modified\n     */\n    Popper.prototype.modifiers.preventOverflow = function (data) {\n        var order = this._options.preventOverflowOrder;\n        var popper = getPopperClientRect(data.offsets.popper);\n\n        var check = {\n            left: function left() {\n                var left = popper.left;\n                if (popper.left < data.boundaries.left) {\n                    left = Math.max(popper.left, data.boundaries.left);\n                }\n                return { left: left };\n            },\n            right: function right() {\n                var left = popper.left;\n                if (popper.right > data.boundaries.right) {\n                    left = Math.min(popper.left, data.boundaries.right - popper.width);\n                }\n                return { left: left };\n            },\n            top: function top() {\n                var top = popper.top;\n                if (popper.top < data.boundaries.top) {\n                    top = Math.max(popper.top, data.boundaries.top);\n                }\n                return { top: top };\n            },\n            bottom: function bottom() {\n                var top = popper.top;\n                if (popper.bottom > data.boundaries.bottom) {\n                    top = Math.min(popper.top, data.boundaries.bottom - popper.height);\n                }\n                return { top: top };\n            }\n        };\n\n        order.forEach(function (direction) {\n            data.offsets.popper = Object.assign(popper, check[direction]());\n        });\n\n        return data;\n    };\n\n    /**\n     * Modifier used to make sure the popper is always near its reference\n     * @method\n     * @memberof Popper.modifiers\n     * @argument {Object} data - The data object generated by _update method\n     * @returns {Object} The data object, properly modified\n     */\n    Popper.prototype.modifiers.keepTogether = function (data) {\n        var popper = getPopperClientRect(data.offsets.popper);\n        var reference = data.offsets.reference;\n        var f = Math.floor;\n\n        if (popper.right < f(reference.left)) {\n            data.offsets.popper.left = f(reference.left) - popper.width;\n        }\n        if (popper.left > f(reference.right)) {\n            data.offsets.popper.left = f(reference.right);\n        }\n        if (popper.bottom < f(reference.top)) {\n            data.offsets.popper.top = f(reference.top) - popper.height;\n        }\n        if (popper.top > f(reference.bottom)) {\n            data.offsets.popper.top = f(reference.bottom);\n        }\n\n        return data;\n    };\n\n    /**\n     * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.\n     * Requires the `preventOverflow` modifier before it in order to work.\n     * **NOTE:** This modifier will run all its previous modifiers everytime it tries to flip the popper!\n     * @method\n     * @memberof Popper.modifiers\n     * @argument {Object} data - The data object generated by _update method\n     * @returns {Object} The data object, properly modified\n     */\n    Popper.prototype.modifiers.flip = function (data) {\n        // check if preventOverflow is in the list of modifiers before the flip modifier.\n        // otherwise flip would not work as expected.\n        if (!this.isModifierRequired(this.modifiers.flip, this.modifiers.preventOverflow)) {\n            console.warn('WARNING: preventOverflow modifier is required by flip modifier in order to work, be sure to include it before flip!');\n            return data;\n        }\n\n        if (data.flipped && data.placement === data._originalPlacement) {\n            // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n            return data;\n        }\n\n        var placement = data.placement.split('-')[0];\n        var placementOpposite = getOppositePlacement(placement);\n        var variation = data.placement.split('-')[1] || '';\n\n        var flipOrder = [];\n        if (this._options.flipBehavior === 'flip') {\n            flipOrder = [placement, placementOpposite];\n        } else {\n            flipOrder = this._options.flipBehavior;\n        }\n\n        flipOrder.forEach(function (step, index) {\n            if (placement !== step || flipOrder.length === index + 1) {\n                return;\n            }\n\n            placement = data.placement.split('-')[0];\n            placementOpposite = getOppositePlacement(placement);\n\n            var popperOffsets = getPopperClientRect(data.offsets.popper);\n\n            // this boolean is used to distinguish right and bottom from top and left\n            // they need different computations to get flipped\n            var a = ['right', 'bottom'].indexOf(placement) !== -1;\n\n            // using Math.floor because the reference offsets may contain decimals we are not going to consider here\n            if (a && Math.floor(data.offsets.reference[placement]) > Math.floor(popperOffsets[placementOpposite]) || !a && Math.floor(data.offsets.reference[placement]) < Math.floor(popperOffsets[placementOpposite])) {\n                // we'll use this boolean to detect any flip loop\n                data.flipped = true;\n                data.placement = flipOrder[index + 1];\n                if (variation) {\n                    data.placement += '-' + variation;\n                }\n                data.offsets.popper = this._getOffsets(this._popper, this._reference, data.placement).popper;\n\n                data = this.runModifiers(data, this._options.modifiers, this._flip);\n            }\n        }.bind(this));\n        return data;\n    };\n\n    /**\n     * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.\n     * The offsets will shift the popper on the side of its reference element.\n     * @method\n     * @memberof Popper.modifiers\n     * @argument {Object} data - The data object generated by _update method\n     * @returns {Object} The data object, properly modified\n     */\n    Popper.prototype.modifiers.offset = function (data) {\n        var offset = this._options.offset;\n        var popper = data.offsets.popper;\n\n        if (data.placement.indexOf('left') !== -1) {\n            popper.top -= offset;\n        } else if (data.placement.indexOf('right') !== -1) {\n            popper.top += offset;\n        } else if (data.placement.indexOf('top') !== -1) {\n            popper.left -= offset;\n        } else if (data.placement.indexOf('bottom') !== -1) {\n            popper.left += offset;\n        }\n        return data;\n    };\n\n    /**\n     * Modifier used to move the arrows on the edge of the popper to make sure them are always between the popper and the reference element\n     * It will use the CSS outer size of the arrow element to know how many pixels of conjuction are needed\n     * @method\n     * @memberof Popper.modifiers\n     * @argument {Object} data - The data object generated by _update method\n     * @returns {Object} The data object, properly modified\n     */\n    Popper.prototype.modifiers.arrow = function (data) {\n        var arrow = this._options.arrowElement;\n\n        // if the arrowElement is a string, suppose it's a CSS selector\n        if (typeof arrow === 'string') {\n            arrow = this._popper.querySelector(arrow);\n        }\n\n        // if arrow element is not found, don't run the modifier\n        if (!arrow) {\n            return data;\n        }\n\n        // the arrow element must be child of its popper\n        if (!this._popper.contains(arrow)) {\n            console.warn('WARNING: `arrowElement` must be child of its popper element!');\n            return data;\n        }\n\n        // arrow depends on keepTogether in order to work\n        if (!this.isModifierRequired(this.modifiers.arrow, this.modifiers.keepTogether)) {\n            console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');\n            return data;\n        }\n\n        var arrowStyle = {};\n        var placement = data.placement.split('-')[0];\n        var popper = getPopperClientRect(data.offsets.popper);\n        var reference = data.offsets.reference;\n        var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n        var len = isVertical ? 'height' : 'width';\n        var side = isVertical ? 'top' : 'left';\n        var altSide = isVertical ? 'left' : 'top';\n        var opSide = isVertical ? 'bottom' : 'right';\n        var arrowSize = getOuterSizes(arrow)[len];\n\n        //\n        // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction\n        //\n\n        // top/left side\n        if (reference[opSide] - arrowSize < popper[side]) {\n            data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowSize);\n        }\n        // bottom/right side\n        if (reference[side] + arrowSize > popper[opSide]) {\n            data.offsets.popper[side] += reference[side] + arrowSize - popper[opSide];\n        }\n\n        // compute center of the popper\n        var center = reference[side] + reference[len] / 2 - arrowSize / 2;\n\n        var sideValue = center - popper[side];\n\n        // prevent arrow from being placed not contiguously to its popper\n        sideValue = Math.max(Math.min(popper[len] - arrowSize, sideValue), 0);\n        arrowStyle[side] = sideValue;\n        arrowStyle[altSide] = ''; // make sure to remove any old style from the arrow\n\n        data.offsets.arrow = arrowStyle;\n        data.arrowElement = arrow;\n\n        return data;\n    };\n\n    //\n    // Helpers\n    //\n\n    /**\n     * Get the outer sizes of the given element (offset size + margins)\n     * @function\n     * @ignore\n     * @argument {Element} element\n     * @returns {Object} object containing width and height properties\n     */\n    function getOuterSizes(element) {\n        // NOTE: 1 DOM access here\n        var _display = element.style.display,\n            _visibility = element.style.visibility;\n        element.style.display = 'block';element.style.visibility = 'hidden';\n        var calcWidthToForceRepaint = element.offsetWidth;\n\n        // original method\n        var styles = root.getComputedStyle(element);\n        var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n        var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n        var result = { width: element.offsetWidth + y, height: element.offsetHeight + x };\n\n        // reset element styles\n        element.style.display = _display;element.style.visibility = _visibility;\n        return result;\n    }\n\n    /**\n     * Get the opposite placement of the given one/\n     * @function\n     * @ignore\n     * @argument {String} placement\n     * @returns {String} flipped placement\n     */\n    function getOppositePlacement(placement) {\n        var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n        return placement.replace(/left|right|bottom|top/g, function (matched) {\n            return hash[matched];\n        });\n    }\n\n    /**\n     * Given the popper offsets, generate an output similar to getBoundingClientRect\n     * @function\n     * @ignore\n     * @argument {Object} popperOffsets\n     * @returns {Object} ClientRect like output\n     */\n    function getPopperClientRect(popperOffsets) {\n        var offsets = Object.assign({}, popperOffsets);\n        offsets.right = offsets.left + offsets.width;\n        offsets.bottom = offsets.top + offsets.height;\n        return offsets;\n    }\n\n    /**\n     * Given an array and the key to find, returns its index\n     * @function\n     * @ignore\n     * @argument {Array} arr\n     * @argument keyToFind\n     * @returns index or null\n     */\n    function getArrayKeyIndex(arr, keyToFind) {\n        var i = 0,\n            key;\n        for (key in arr) {\n            if (arr[key] === keyToFind) {\n                return i;\n            }\n            i++;\n        }\n        return null;\n    }\n\n    /**\n     * Get CSS computed property of the given element\n     * @function\n     * @ignore\n     * @argument {Eement} element\n     * @argument {String} property\n     */\n    function getStyleComputedProperty(element, property) {\n        // NOTE: 1 DOM access here\n        var css = root.getComputedStyle(element, null);\n        return css[property];\n    }\n\n    /**\n     * Returns the offset parent of the given element\n     * @function\n     * @ignore\n     * @argument {Element} element\n     * @returns {Element} offset parent\n     */\n    function getOffsetParent(element) {\n        // NOTE: 1 DOM access here\n        var offsetParent = element.offsetParent;\n        return offsetParent === root.document.body || !offsetParent ? root.document.documentElement : offsetParent;\n    }\n\n    /**\n     * Returns the scrolling parent of the given element\n     * @function\n     * @ignore\n     * @argument {Element} element\n     * @returns {Element} offset parent\n     */\n    function getScrollParent(element) {\n        var parent = element.parentNode;\n\n        if (!parent) {\n            return element;\n        }\n\n        if (parent === root.document) {\n            // Firefox puts the scrollTOp value on `documentElement` instead of `body`, we then check which of them is\n            // greater than 0 and return the proper element\n            if (root.document.body.scrollTop) {\n                return root.document.body;\n            } else {\n                return root.document.documentElement;\n            }\n        }\n\n        // Firefox want us to check `-x` and `-y` variations as well\n        if (['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-x')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-y')) !== -1) {\n            // If the detected scrollParent is body, we perform an additional check on its parentNode\n            // in this way we'll get body if the browser is Chrome-ish, or documentElement otherwise\n            // fixes issue #65\n            return parent;\n        }\n        return getScrollParent(element.parentNode);\n    }\n\n    /**\n     * Check if the given element is fixed or is inside a fixed parent\n     * @function\n     * @ignore\n     * @argument {Element} element\n     * @argument {Element} customContainer\n     * @returns {Boolean} answer to \"isFixed?\"\n     */\n    function isFixed(element) {\n        if (element === root.document.body) {\n            return false;\n        }\n        if (getStyleComputedProperty(element, 'position') === 'fixed') {\n            return true;\n        }\n        return element.parentNode ? isFixed(element.parentNode) : element;\n    }\n\n    /**\n     * Set the style to the given popper\n     * @function\n     * @ignore\n     * @argument {Element} element - Element to apply the style to\n     * @argument {Object} styles - Object with a list of properties and values which will be applied to the element\n     */\n    function setStyle(element, styles) {\n        function is_numeric(n) {\n            return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n        }\n        Object.keys(styles).forEach(function (prop) {\n            var unit = '';\n            // add unit if the value is numeric and is one of the following\n            if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && is_numeric(styles[prop])) {\n                unit = 'px';\n            }\n            element.style[prop] = styles[prop] + unit;\n        });\n    }\n\n    /**\n     * Check if the given variable is a function\n     * @function\n     * @ignore\n     * @argument {Element} element - Element to check\n     * @returns {Boolean} answer to: is a function?\n     */\n    function isFunction(functionToCheck) {\n        var getType = {};\n        return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n    }\n\n    /**\n     * Get the position of the given element, relative to its offset parent\n     * @function\n     * @ignore\n     * @param {Element} element\n     * @return {Object} position - Coordinates of the element and its `scrollTop`\n     */\n    function getOffsetRect(element) {\n        var elementRect = {\n            width: element.offsetWidth,\n            height: element.offsetHeight,\n            left: element.offsetLeft,\n            top: element.offsetTop\n        };\n\n        elementRect.right = elementRect.left + elementRect.width;\n        elementRect.bottom = elementRect.top + elementRect.height;\n\n        // position\n        return elementRect;\n    }\n\n    /**\n     * Get bounding client rect of given element\n     * @function\n     * @ignore\n     * @param {HTMLElement} element\n     * @return {Object} client rect\n     */\n    function getBoundingClientRect(element) {\n        var rect = element.getBoundingClientRect();\n\n        // whether the IE version is lower than 11\n        var isIE = navigator.userAgent.indexOf(\"MSIE\") != -1;\n\n        // fix ie document bouding top always 0 bug\n        var rectTop = isIE && element.tagName === 'HTML' ? -element.scrollTop : rect.top;\n\n        return {\n            left: rect.left,\n            top: rectTop,\n            right: rect.right,\n            bottom: rect.bottom,\n            width: rect.right - rect.left,\n            height: rect.bottom - rectTop\n        };\n    }\n\n    /**\n     * Given an element and one of its parents, return the offset\n     * @function\n     * @ignore\n     * @param {HTMLElement} element\n     * @param {HTMLElement} parent\n     * @return {Object} rect\n     */\n    function getOffsetRectRelativeToCustomParent(element, parent, fixed) {\n        var elementRect = getBoundingClientRect(element);\n        var parentRect = getBoundingClientRect(parent);\n\n        if (fixed) {\n            var scrollParent = getScrollParent(parent);\n            parentRect.top += scrollParent.scrollTop;\n            parentRect.bottom += scrollParent.scrollTop;\n            parentRect.left += scrollParent.scrollLeft;\n            parentRect.right += scrollParent.scrollLeft;\n        }\n\n        var rect = {\n            top: elementRect.top - parentRect.top,\n            left: elementRect.left - parentRect.left,\n            bottom: elementRect.top - parentRect.top + elementRect.height,\n            right: elementRect.left - parentRect.left + elementRect.width,\n            width: elementRect.width,\n            height: elementRect.height\n        };\n        return rect;\n    }\n\n    /**\n     * Get the prefixed supported property name\n     * @function\n     * @ignore\n     * @argument {String} property (camelCase)\n     * @returns {String} prefixed property (camelCase)\n     */\n    function getSupportedPropertyName(property) {\n        var prefixes = ['', 'ms', 'webkit', 'moz', 'o'];\n\n        for (var i = 0; i < prefixes.length; i++) {\n            var toCheck = prefixes[i] ? prefixes[i] + property.charAt(0).toUpperCase() + property.slice(1) : property;\n            if (typeof root.document.body.style[toCheck] !== 'undefined') {\n                return toCheck;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * The Object.assign() method is used to copy the values of all enumerable own properties from one or more source\n     * objects to a target object. It will return the target object.\n     * This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway\n     * Source: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n     * @function\n     * @ignore\n     */\n    if (!Object.assign) {\n        Object.defineProperty(Object, 'assign', {\n            enumerable: false,\n            configurable: true,\n            writable: true,\n            value: function value(target) {\n                if (target === undefined || target === null) {\n                    throw new TypeError('Cannot convert first argument to object');\n                }\n\n                var to = Object(target);\n                for (var i = 1; i < arguments.length; i++) {\n                    var nextSource = arguments[i];\n                    if (nextSource === undefined || nextSource === null) {\n                        continue;\n                    }\n                    nextSource = Object(nextSource);\n\n                    var keysArray = Object.keys(nextSource);\n                    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n                        var nextKey = keysArray[nextIndex];\n                        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n                        if (desc !== undefined && desc.enumerable) {\n                            to[nextKey] = nextSource[nextKey];\n                        }\n                    }\n                }\n                return to;\n            }\n        });\n    }\n\n    return Popper;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/element-ui/lib/utils/popper.js\n// module id = 50\n// module chunks = 0 1 3 4","'use strict';\n\nexports.__esModule = true;\n\nvar _popper = require('./popper');\n\nvar _popper2 = _interopRequireDefault(_popper);\n\nvar _vuePopup = require('vue-popup');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @param {HTMLElement} [reference=$refs.reference] - The reference element used to position the popper.\n * @param {HTMLElement} [popper=$refs.popper] - The HTML element used as popper, or a configuration used to generate the popper.\n * @param {String} [placement=button] - Placement of the popper accepted values: top(-start, -end), right(-start, -end), bottom(-start, -right), left(-start, -end)\n * @param {Number} [offset=0] - Amount of pixels the popper will be shifted (can be negative).\n * @param {Boolean} [visible=false] Visibility of the popup element.\n * @param {Boolean} [visible-arrow=false] Visibility of the arrow, no style.\n */\nexports.default = {\n  props: {\n    placement: {\n      type: String,\n      default: 'bottom'\n    },\n    boundariesPadding: {\n      type: Number,\n      default: 5\n    },\n    reference: {},\n    popper: {},\n    offset: {\n      default: 0\n    },\n    value: Boolean,\n    visibleArrow: Boolean,\n    transition: String,\n    appendToBody: {\n      type: Boolean,\n      default: true\n    },\n    options: {\n      type: Object,\n      default: function _default() {\n        return {\n          gpuAcceleration: false\n        };\n      }\n    }\n  },\n\n  data: function data() {\n    return {\n      showPopper: false\n    };\n  },\n\n\n  watch: {\n    value: {\n      immediate: true,\n      handler: function handler(val) {\n        this.showPopper = val;\n        this.$emit('input', val);\n      }\n    },\n\n    showPopper: function showPopper(val) {\n      val ? this.updatePopper() : this.destroyPopper();\n      this.$emit('input', val);\n    }\n  },\n\n  methods: {\n    createPopper: function createPopper() {\n      var _this = this;\n\n      if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(this.placement)) {\n        return;\n      }\n\n      var options = this.options;\n      var popper = this.popperElm = this.popperElm || this.popper || this.$refs.popper;\n      var reference = this.referenceElm = this.referenceElm || this.reference || this.$refs.reference;\n\n      if (!reference && this.$slots.reference && this.$slots.reference[0]) {\n        reference = this.referenceElm = this.$slots.reference[0].elm;\n      }\n      if (!popper || !reference) return;\n      if (this.visibleArrow) this.appendArrow(popper);\n      if (this.appendToBody) document.body.appendChild(this.popperElm);\n      if (this.popperJS && this.popperJS.destroy) {\n        this.popperJS.destroy();\n      }\n\n      options.placement = this.placement;\n      options.offset = this.offset;\n      this.popperJS = new _popper2.default(reference, popper, options);\n      this.popperJS.onCreate(function (_) {\n        _this.$emit('created', _this);\n        _this.resetTransformOrigin();\n        _this.$nextTick(_this.updatePopper);\n      });\n      this.popperJS._popper.style.zIndex = _vuePopup.PopupManager.nextZIndex();\n    },\n    updatePopper: function updatePopper() {\n      this.popperJS ? this.popperJS.update() : this.createPopper();\n    },\n    doDestroy: function doDestroy() {\n      /* istanbul ignore if */\n      if (this.showPopper || !this.popperJS) return;\n      this.popperJS.destroy();\n      this.popperJS = null;\n    },\n    destroyPopper: function destroyPopper() {\n      if (this.popperJS) {\n        this.resetTransformOrigin();\n      }\n    },\n    resetTransformOrigin: function resetTransformOrigin() {\n      var placementMap = { top: 'bottom', bottom: 'top', left: 'right', right: 'left' };\n      var placement = this.popperJS._popper.getAttribute('x-placement').split('-')[0];\n      var origin = placementMap[placement];\n      this.popperJS._popper.style.transformOrigin = ['top', 'bottom'].indexOf(placement) > -1 ? 'center ' + origin : origin + ' center';\n    },\n    appendArrow: function appendArrow(element) {\n      var hash = void 0;\n      if (this.appended) {\n        return;\n      }\n\n      this.appended = true;\n\n      for (var item in element.attributes) {\n        if (/^_v-/.test(element.attributes[item].name)) {\n          hash = element.attributes[item].name;\n          break;\n        }\n      }\n\n      var arrow = document.createElement('div');\n\n      if (hash) {\n        arrow.setAttribute(hash, '');\n      }\n      arrow.setAttribute('x-arrow', '');\n      arrow.className = 'popper__arrow';\n      element.appendChild(arrow);\n    }\n  },\n\n  beforeDestroy: function beforeDestroy() {\n    this.doDestroy();\n    this.popperElm && this.popperElm.parentNode === document.body && document.body.removeChild(this.popperElm);\n  },\n\n\n  // call destroy in keep-alive mode\n  deactivated: function deactivated() {\n    this.$options.beforeDestroy[0].call(this);\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/element-ui/lib/utils/vue-popper.js\n// module id = 51\n// module chunks = 0 1 3 4","// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/timsort.js\n// module id = 53\n// module chunks = 0 1","/**\n * 可绘制的图形基类\n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * z层level，决定绘画在哪层canvas中\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * 是否可拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * 是否正在拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * 是否相应鼠标事件\n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * 图形绘制方法\n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * 获取最小包围盒\n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         * 判断坐标 x, y 是否在图形上\n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         * 判断坐标 x, y 是否在图形的包围盒上\n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * 标记图形元素为脏，并且在下一帧重绘\n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * 图形是否会触发事件\n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO, 通过 bind 绑定的事件\n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Displayable.js\n// module id = 54\n// module chunks = 0 1","\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Gradient.js\n// module id = 55\n// module chunks = 0 1","// 更新状态icon映射\nlet updateStatusIconMap = {\n  '已更新': 'icon-success',\n  '更新中': 'icon-wait',\n  '待更新': 'icon-wait ignore-status',\n  '异常': 'icon-wait ignore-status'\n}\n\n// 执行状态icon映射\nlet excuteStatusIconMap = {\n  '已执行': 'icon-success',\n  '待执行': 'icon-wait',\n  '不可执行': 'icon-wait ignore-status',\n  '已过期': 'icon-wait ignore-status'\n}\n\nexport default {\n  filters: {\n    updateStatusIcon(value) {\n      return updateStatusIconMap[value] || ''\n    },\n    excuteStatusIcon(value) {\n      return excuteStatusIconMap[value] || ''\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/views/ex/mixin.js","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * Interface of Coordinate System Class\n     *\n     * create:\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {module:echarts/ExtensionAPI} api\n     *     @return {Object} coordinate system instance\n     *\n     * update:\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {module:echarts/ExtensionAPI} api\n     *\n     * convertToPixel:\n     * convertFromPixel:\n     *     These two methods is also responsible for determine whether this\n     *     coodinate system is applicable to the given `finder`.\n     *     Each coordinate system will be tried, util one returns none\n     *     null/undefined value.\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {Object} finder\n     *     @param {Array|number} value\n     *     @return {Array|number} convert result.\n     *\n     * containPoint:\n     *     @param {Array.<number>} point In pixel coordinate system.\n     *     @return {boolean}\n     */\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/CoordinateSystem.js\n// module id = 70\n// module chunks = 0 1","/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = require('../model/Model');\n    var DataDiffer = require('./DataDiffer');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    var transferProperties = function (a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string>} dimensions\n     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n            }\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var size = data.length;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var idList = [];\n        var nameRepeatCount = {};\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var idx = 0; idx < data.length; idx++) {\n            var dataItem = data[idx];\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n            }\n\n            indices.push(idx);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < data.length; i++) {\n            if (!nameList[i]) {\n                if (data[i] && data[i].name != null) {\n                    nameList[i] = data[i].name;\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = data[i] && data[i].id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null) {\n            return NaN;\n        }\n\n        var value = storage[dim] && storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getDataExtent = function (dim, stack) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                value < min && (min = value);\n                value > max && (max = value);\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {number}\n     */\n    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var nearestIdx = -1;\n        if (dimData) {\n            var minDist = Number.MAX_VALUE;\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var diff = value - this.get(dim, i, stack);\n                var dist = Math.abs(diff);\n                if (\n                    diff <= maxDistance\n                    && (dist < minDist\n                        // For the case of two data are same on xAxis, which has sequence data.\n                        // Show the nearest index\n                        // https://github.com/ecomfe/echarts/issues/2869\n                        || (dist === minDist && diff > 0)\n                    )\n                ) {\n                    minDist = dist;\n                    nearestIdx = i;\n                }\n            }\n        }\n        return nearestIdx;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData[this.getRawIndex(idx)];\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        var val;\n        // Use prefix to avoid index to be the same as otherIdList[idx],\n        // which will cause weird udpate animation.\n        var prefix = 'e\\0\\0';\n\n        return new DataDiffer(\n            otherList ? otherList.indices : [],\n            this.indices,\n            function (idx) {\n                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n            },\n            function (idx) {\n                return (val = idList[idx]) != null ? val : prefix + idx;\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} ignoreParent\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/List.js\n// module id = 71\n// module chunks = 0 1","'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * 画布元素ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * 元素类型\n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * 元素名字\n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n         * 该路径会继承被裁减对象的变换\n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // 添加动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // 移除动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Element.js\n// module id = 73\n// module chunks = 0 1","/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = (\n                isValueArray\n                && isArrayLike(firstVal[0])\n            )\n            ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * 设置动画关键帧\n         * @param  {number} time 关键帧时间，单位是ms\n         * @param  {Object} props 关键帧的属性值，key-value表示\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * 添加动画每一帧的回调函数\n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * 开始执行动画\n         * @param  {string|Function} easing\n         *         动画缓动函数，详见{@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * 设置动画延迟开始的时间\n         * @param  {number} time 单位ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * 添加动画结束的回调\n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animator.js\n// module id = 74\n// module chunks = 0 1","\n\n    module.exports = (typeof window !== 'undefined' &&\n                                    (window.requestAnimationFrame\n                                    || window.msRequestAnimationFrame\n                                    || window.mozRequestAnimationFrame\n                                    || window.webkitRequestAnimationFrame))\n                                || function (func) {\n                                    setTimeout(func, 16);\n                                };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/requestAnimationFrame.js\n// module id = 75\n// module chunks = 0 1","\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/util.js\n// module id = 76\n// module chunks = 0 1","/**\n * zrender: 生成唯一id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/guid.js\n// module id = 77\n// module chunks = 0 1","\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/log.js\n// module id = 78\n// module chunks = 0 1","/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // 图片已经加载完成\n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var width = style.width || image.width;\n                var height = style.height || image.height;\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // 图片加载失败\n                if (!image.width || !image.height) {\n                    return;\n                }\n\n                // 设置transform\n                this.setTransform(ctx);\n\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                // 如果没设置宽和高的话自动根据图片宽高设置\n                if (style.width == null) {\n                    style.width = width;\n                }\n                if (style.height == null) {\n                    style.height = height;\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Image.js\n// module id = 79\n// module chunks = 0 1","\n\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n\n        return this._canvasPattern\n            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n\n    module.exports = Pattern;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Pattern.js\n// module id = 80\n// module chunks = 0 1","/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Style.js\n// module id = 81\n// module chunks = 0 1","\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/poly.js\n// module id = 82\n// module chunks = 0 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../util/format');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var colorPaletteMixin = require('./mixin/colorPalette');\n    var env = require('zrender/lib/core/env');\n    var layout = require('../util/layout');\n\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n\n            // If we reverse the order (make this._data firstly, and then make\n            // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause this._data.graph.data !== this._data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this._data = this._dataBeforeProcessed.cloneShallow();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `position` and `show`\n            // FIXME Set label in mergeOption\n            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\n            this.fillDataTextStyle(option.data);\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n            }\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                this._data = data;\n                this._dataBeforeProcessed = data.cloneShallow();\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `position` and `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            return dataType == null ? this._data : this._data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            this._data = data;\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return this._dataBeforeProcessed;\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return [coordDim];\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return dataDim;\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var result = [];\n\n                zrUtil.each(value, function (val, idx) {\n                    var dimInfo = data.getDimensionInfo(idx);\n                    var dimType = dimInfo && dimInfo.type;\n                    var valStr;\n\n                    if (dimType === 'ordinal') {\n                        valStr = val + '';\n                    }\n                    else if (dimType === 'time') {\n                        valStr = multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val);\n                    }\n                    else {\n                        valStr = addCommas(val);\n                    }\n\n                    valStr && result.push(valStr);\n                });\n\n                return result.join(', ');\n            }\n\n            var data = this._data;\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = zrUtil.isArray(value)\n                ? formatArrayValue(value) : addCommas(value);\n            var name = data.getName(dataIndex);\n\n            var color = data.getItemVisual(dataIndex, 'color');\n            if (zrUtil.isObject(color) && color.colorStops) {\n                color = (color.colorStops[0] || {}).color;\n            }\n            color = color || 'transparent';\n\n            var colorEl = '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            return !multipleSeries\n                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl\n                    + (name\n                        ? encodeHTML(name) + ' : ' + formattedValue\n                        : formattedValue)\n                  )\n                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);\n        },\n\n        /**\n         * @return {boolean}\n         */\n        ifEnableAnimation: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            this._data = this._dataBeforeProcessed.cloneShallow();\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Array.<number>} data indices.\n         */\n        getAxisTooltipDataIndex: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Series.js\n// module id = 88\n// module chunks = 0 1","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var modelUtil = require('../util/model');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/view/Chart.js\n// module id = 90\n// module chunks = 0 1","exports = module.exports = require(\"./../../../css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".el-tooltip,.el-tooltip__rel{display:inline-block}.el-tooltip__rel{position:relative}.el-tooltip__popper{position:absolute;border-radius:4px;padding:10px;z-index:2000;font-size:12px;line-height:1.2}.el-tooltip__popper .popper__arrow,.el-tooltip__popper .popper__arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.el-tooltip__popper .popper__arrow{border-width:6px}.el-tooltip__popper .popper__arrow:after{content:\\\" \\\";border-width:5px}.el-tooltip__popper[x-placement^=top]{margin-bottom:12px}.el-tooltip__popper[x-placement^=top] .popper__arrow{bottom:-6px;border-top-color:#1f2d3d;border-bottom-width:0}.el-tooltip__popper[x-placement^=top] .popper__arrow:after{bottom:1px;margin-left:-5px;border-top-color:#1f2d3d;border-bottom-width:0}.el-tooltip__popper[x-placement^=bottom]{margin-top:12px}.el-tooltip__popper[x-placement^=bottom] .popper__arrow{top:-6px;border-top-width:0;border-bottom-color:#1f2d3d}.el-tooltip__popper[x-placement^=bottom] .popper__arrow:after{top:1px;margin-left:-5px;border-top-width:0;border-bottom-color:#1f2d3d}.el-tooltip__popper[x-placement^=right]{margin-left:12px}.el-tooltip__popper[x-placement^=right] .popper__arrow{left:-6px;border-right-color:#1f2d3d;border-left-width:0}.el-tooltip__popper[x-placement^=right] .popper__arrow:after{bottom:-5px;left:1px;border-right-color:#1f2d3d;border-left-width:0}.el-tooltip__popper[x-placement^=left]{margin-right:12px}.el-tooltip__popper[x-placement^=left] .popper__arrow{right:-6px;border-right-width:0;border-left-color:#1f2d3d}.el-tooltip__popper[x-placement^=left] .popper__arrow:after{right:1px;bottom:-5px;margin-left:-5px;border-right-width:0;border-left-color:#1f2d3d}.el-tooltip__popper.is-light{background:#fff;border:1px solid #1f2d3d}.el-tooltip__popper.is-light[x-placement^=top] .popper__arrow{border-top-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=top] .popper__arrow:after{border-top-color:#fff}.el-tooltip__popper.is-light[x-placement^=bottom] .popper__arrow{border-bottom-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=bottom] .popper__arrow:after{border-bottom-color:#fff}.el-tooltip__popper.is-light[x-placement^=left] .popper__arrow{border-left-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=left] .popper__arrow:after{border-left-color:#fff}.el-tooltip__popper.is-light[x-placement^=right] .popper__arrow{border-right-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=right] .popper__arrow:after{border-right-color:#fff}.el-tooltip__popper.is-dark{background:#1f2d3d;color:#fff}\", \"\", {\"version\":3,\"sources\":[\"/./node_modules/element-ui/lib/theme-default/tooltip.css\"],\"names\":[],\"mappings\":\"AAAiB,6BAA6B,oBAAoB,CAAC,iBAAiB,iBAAiB,CAAC,oBAAoB,kBAAkB,kBAAkB,aAAa,aAAa,eAAe,eAAe,CAAC,4EAA6E,kBAAkB,cAAc,QAAQ,SAAS,yBAAyB,kBAAkB,CAAC,mCAAmC,gBAAgB,CAAC,yCAA0C,YAAY,gBAAgB,CAAC,sCAAsC,kBAAkB,CAAC,qDAAqD,YAAY,yBAAyB,qBAAqB,CAAC,2DAA4D,WAAW,iBAAiB,yBAAyB,qBAAqB,CAAC,yCAAyC,eAAe,CAAC,wDAAwD,SAAS,mBAAmB,2BAA2B,CAAC,8DAA+D,QAAQ,iBAAiB,mBAAmB,2BAA2B,CAAC,wCAAwC,gBAAgB,CAAC,uDAAuD,UAAU,2BAA2B,mBAAmB,CAAC,6DAA8D,YAAY,SAAS,2BAA2B,mBAAmB,CAAC,uCAAuC,iBAAiB,CAAC,sDAAsD,WAAW,qBAAqB,yBAAyB,CAAC,4DAA6D,UAAU,YAAY,iBAAiB,qBAAqB,yBAAyB,CAAC,6BAA6B,gBAAgB,wBAAwB,CAAC,8DAA8D,wBAAwB,CAAC,oEAAqE,qBAAqB,CAAC,iEAAiE,2BAA2B,CAAC,uEAAwE,wBAAwB,CAAC,+DAA+D,yBAAyB,CAAC,qEAAsE,sBAAsB,CAAC,gEAAgE,0BAA0B,CAAC,sEAAuE,uBAAuB,CAAC,4BAA4B,mBAAmB,UAAU,CAAC\",\"file\":\"tooltip.css\",\"sourcesContent\":[\"@charset \\\"UTF-8\\\";.el-tooltip,.el-tooltip__rel{display:inline-block}.el-tooltip__rel{position:relative}.el-tooltip__popper{position:absolute;border-radius:4px;padding:10px;z-index:2000;font-size:12px;line-height:1.2}.el-tooltip__popper .popper__arrow,.el-tooltip__popper .popper__arrow::after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.el-tooltip__popper .popper__arrow{border-width:6px}.el-tooltip__popper .popper__arrow::after{content:\\\" \\\";border-width:5px}.el-tooltip__popper[x-placement^=top]{margin-bottom:12px}.el-tooltip__popper[x-placement^=top] .popper__arrow{bottom:-6px;border-top-color:#1f2d3d;border-bottom-width:0}.el-tooltip__popper[x-placement^=top] .popper__arrow::after{bottom:1px;margin-left:-5px;border-top-color:#1f2d3d;border-bottom-width:0}.el-tooltip__popper[x-placement^=bottom]{margin-top:12px}.el-tooltip__popper[x-placement^=bottom] .popper__arrow{top:-6px;border-top-width:0;border-bottom-color:#1f2d3d}.el-tooltip__popper[x-placement^=bottom] .popper__arrow::after{top:1px;margin-left:-5px;border-top-width:0;border-bottom-color:#1f2d3d}.el-tooltip__popper[x-placement^=right]{margin-left:12px}.el-tooltip__popper[x-placement^=right] .popper__arrow{left:-6px;border-right-color:#1f2d3d;border-left-width:0}.el-tooltip__popper[x-placement^=right] .popper__arrow::after{bottom:-5px;left:1px;border-right-color:#1f2d3d;border-left-width:0}.el-tooltip__popper[x-placement^=left]{margin-right:12px}.el-tooltip__popper[x-placement^=left] .popper__arrow{right:-6px;border-right-width:0;border-left-color:#1f2d3d}.el-tooltip__popper[x-placement^=left] .popper__arrow::after{right:1px;bottom:-5px;margin-left:-5px;border-right-width:0;border-left-color:#1f2d3d}.el-tooltip__popper.is-light{background:#fff;border:1px solid #1f2d3d}.el-tooltip__popper.is-light[x-placement^=top] .popper__arrow{border-top-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=top] .popper__arrow::after{border-top-color:#fff}.el-tooltip__popper.is-light[x-placement^=bottom] .popper__arrow{border-bottom-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=bottom] .popper__arrow::after{border-bottom-color:#fff}.el-tooltip__popper.is-light[x-placement^=left] .popper__arrow{border-left-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=left] .popper__arrow::after{border-left-color:#fff}.el-tooltip__popper.is-light[x-placement^=right] .popper__arrow{border-right-color:#1f2d3d}.el-tooltip__popper.is-light[x-placement^=right] .popper__arrow::after{border-right-color:#fff}.el-tooltip__popper.is-dark{background:#1f2d3d;color:#fff}\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?-autoprefixer&sourceMap!./~/postcss-loader!./~/element-ui/lib/theme-default/tooltip.css\n// module id = 106\n// module chunks = 0 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'\n    ];\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/ExtensionAPI.js\n// module id = 108\n// module chunks = 0 1","\n    // List layout\n    var layout = require('../../util/layout');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n\n    function positionGroup(group, model, api) {\n        layout.positionElement(\n            group, model.getBoxLayoutParams(),\n            {\n                width: api.getWidth(),\n                height: api.getHeight()\n            },\n            model.get('padding')\n        );\n    }\n\n    module.exports = {\n        /**\n         * Layout list like component.\n         * It will box layout each items in group of component and then position the whole group in the viewport\n         * @param {module:zrender/group/Group} group\n         * @param {module:echarts/model/Component} componentModel\n         * @param {module:echarts/ExtensionAPI}\n         */\n        layout: function (group, componentModel, api) {\n            var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }, componentModel.get('padding'));\n            layout.box(\n                componentModel.get('orient'),\n                group,\n                componentModel.get('itemGap'),\n                rect.width,\n                rect.height\n            );\n\n            positionGroup(group, componentModel, api);\n        },\n\n        addBackground: function (group, componentModel) {\n            var padding = formatUtil.normalizeCssArray(\n                componentModel.get('padding')\n            );\n            var boundingRect = group.getBoundingRect();\n            var style = componentModel.getItemStyle(['color', 'opacity']);\n            style.fill = componentModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: boundingRect.x - padding[3],\n                    y: boundingRect.y - padding[0],\n                    width: boundingRect.width + padding[1] + padding[3],\n                    height: boundingRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true,\n                z2: -1\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/helper/listComponent.js\n// module id = 109\n// module chunks = 0 1","/**\n * Legend component entry file8\n */\n\n\n    require('./legend/LegendModel');\n    require('./legend/legendAction');\n    require('./legend/LegendView');\n\n    var echarts = require('../echarts');\n    // Series Filter\n    echarts.registerProcessor(require('./legend/legendFilter'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend.js\n// module id = 110\n// module chunks = 0 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Model = require('../../model/Model');\n\n    var LegendModel = require('../../echarts').extendComponentModel({\n\n        type: 'legend',\n\n        dependencies: ['series'],\n\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n\n        init: function (option, parentModel, ecModel) {\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            option.selected = option.selected || {};\n        },\n\n        mergeOption: function (option) {\n            LegendModel.superCall(this, 'mergeOption', option);\n        },\n\n        optionUpdated: function () {\n            this._updateData(this.ecModel);\n\n            var legendData = this._data;\n\n            // If selectedMode is single, try to select one\n            if (legendData[0] && this.get('selectedMode') === 'single') {\n                var hasSelected = false;\n                // If has any selected in option.selected\n                for (var i = 0; i < legendData.length; i++) {\n                    var name = legendData[i].get('name');\n                    if (this.isSelected(name)) {\n                        // Force to unselect others\n                        this.select(name);\n                        hasSelected = true;\n                        break;\n                    }\n                }\n                // Try select the first if selectedMode is single\n                !hasSelected && this.select(legendData[0].get('name'));\n            }\n        },\n\n        _updateData: function (ecModel) {\n            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n                // Can be string or number\n                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n                    dataItem = {\n                        name: dataItem\n                    };\n                }\n                return new Model(dataItem, this, this.ecModel);\n            }, this);\n            this._data = legendData;\n\n            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n                return series.name;\n            });\n            ecModel.eachSeries(function (seriesModel) {\n                if (seriesModel.legendDataProvider) {\n                    var data = seriesModel.legendDataProvider();\n                    availableNames = availableNames.concat(data.mapArray(data.getName));\n                }\n            });\n            /**\n             * @type {Array.<string>}\n             * @private\n             */\n            this._availableNames = availableNames;\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Model>}\n         */\n        getData: function () {\n            return this._data;\n        },\n\n        /**\n         * @param {string} name\n         */\n        select: function (name) {\n            var selected = this.option.selected;\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                var data = this._data;\n                zrUtil.each(data, function (dataItem) {\n                    selected[dataItem.get('name')] = false;\n                });\n            }\n            selected[name] = true;\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            if (this.get('selectedMode') !== 'single') {\n                this.option.selected[name] = false;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var selected = this.option.selected;\n            // Default is true\n            if (!selected.hasOwnProperty(name)) {\n                selected[name] = true;\n            }\n            this[selected[name] ? 'unSelect' : 'select'](name);\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var selected = this.option.selected;\n            return !(selected.hasOwnProperty(name) && !selected[name])\n                && zrUtil.indexOf(this._availableNames, name) >= 0;\n        },\n\n        defaultOption: {\n            // 一级层叠\n            zlevel: 0,\n            // 二级层叠\n            z: 4,\n            show: true,\n\n            // 布局方式，默认为水平布局，可选为：\n            // 'horizontal' | 'vertical'\n            orient: 'horizontal',\n\n            left: 'center',\n            // right: 'center',\n\n            top: 'top',\n            // bottom: 'top',\n\n            // 水平对齐\n            // 'auto' | 'left' | 'right'\n            // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐\n            align: 'auto',\n\n            backgroundColor: 'rgba(0,0,0,0)',\n            // 图例边框颜色\n            borderColor: '#ccc',\n            // 图例边框线宽，单位px，默认为0（无边框）\n            borderWidth: 0,\n            // 图例内边距，单位px，默认各方向内边距为5，\n            // 接受数组分别设定上右下左边距，同css\n            padding: 5,\n            // 各个item之间的间隔，单位px，默认为10，\n            // 横向布局时为水平间隔，纵向布局时为纵向间隔\n            itemGap: 10,\n            // 图例图形宽度\n            itemWidth: 25,\n            // 图例图形高度\n            itemHeight: 14,\n\n            // 图例关闭时候的颜色\n            inactiveColor: '#ccc',\n\n            textStyle: {\n                // 图例文字颜色\n                color: '#333'\n            },\n            // formatter: '',\n            // 选择模式，默认开启图例开关\n            selectedMode: true,\n            // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入\n            // selected: null,\n            // 图例内容（详见legend.data，数组中每一项代表一个item\n            // data: [],\n\n            // Tooltip 相关配置\n            tooltip: {\n                show: false\n            }\n        }\n    });\n\n    module.exports = LegendModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/LegendModel.js\n// module id = 111\n// module chunks = 0 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var symbolCreator = require('../../util/symbol');\n    var graphic = require('../../util/graphic');\n    var listComponentHelper = require('../helper/listComponent');\n\n    var curry = zrUtil.curry;\n\n    function dispatchSelectAction(name, api) {\n        api.dispatchAction({\n            type: 'legendToggleSelect',\n            name: name\n        });\n    }\n\n    function dispatchHighlightAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'highlight',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    function dispatchDownplayAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'downplay',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    module.exports = require('../../echarts').extendComponentView({\n\n        type: 'legend',\n\n        init: function () {\n            this._symbolTypeStore = {};\n        },\n\n        render: function (legendModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            if (!legendModel.get('show')) {\n                return;\n            }\n\n            var selectMode = legendModel.get('selectedMode');\n            var itemAlign = legendModel.get('align');\n\n            if (itemAlign === 'auto') {\n                itemAlign = (legendModel.get('left') === 'right'\n                    && legendModel.get('orient') === 'vertical')\n                    ? 'right' : 'left';\n            }\n\n            var legendDrawedMap = {};\n\n            zrUtil.each(legendModel.getData(), function (itemModel) {\n                var name = itemModel.get('name');\n\n                // Use empty string or \\n as a newline string\n                if (name === '' || name === '\\n') {\n                    group.add(new graphic.Group({\n                        newline: true\n                    }));\n                    return;\n                }\n\n                var seriesModel = ecModel.getSeriesByName(name)[0];\n\n                if (legendDrawedMap[name]) {\n                    // Have been drawed\n                    return;\n                }\n\n                // Series legend\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var color = data.getVisual('color');\n\n                    // If color is a callback function\n                    if (typeof color === 'function') {\n                        // Use the first data\n                        color = color(seriesModel.getDataParams(0));\n                    }\n\n                    // Using rect symbol defaultly\n                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n                    var symbolType = data.getVisual('symbol');\n\n                    var itemGroup = this._createItem(\n                        name, itemModel, legendModel,\n                        legendSymbolType, symbolType,\n                        itemAlign, color,\n                        selectMode\n                    );\n\n                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\n                    legendDrawedMap[name] = true;\n                }\n                else {\n                    // Data legend of pie, funnel\n                    ecModel.eachRawSeries(function (seriesModel) {\n                        // In case multiple series has same data name\n                        if (legendDrawedMap[name]) {\n                            return;\n                        }\n                        if (seriesModel.legendDataProvider) {\n                            var data = seriesModel.legendDataProvider();\n                            var idx = data.indexOfName(name);\n                            if (idx < 0) {\n                                return;\n                            }\n\n                            var color = data.getItemVisual(idx, 'color');\n\n                            var legendSymbolType = 'roundRect';\n\n                            var itemGroup = this._createItem(\n                                name, itemModel, legendModel,\n                                legendSymbolType, null,\n                                itemAlign, color,\n                                selectMode\n                            );\n\n                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                                // FIXME Should not specify the series name\n                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\n                            legendDrawedMap[name] = true;\n                        }\n                    }, this);\n                }\n\n                if (__DEV__) {\n                    if (!legendDrawedMap[name]) {\n                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n                    }\n                }\n            }, this);\n\n            listComponentHelper.layout(group, legendModel, api);\n            // Render background after group is layout\n            // FIXME\n            listComponentHelper.addBackground(group, legendModel);\n        },\n\n        _createItem: function (\n            name, itemModel, legendModel,\n            legendSymbolType, symbolType,\n            itemAlign, color, selectMode\n        ) {\n            var itemWidth = legendModel.get('itemWidth');\n            var itemHeight = legendModel.get('itemHeight');\n            var inactiveColor = legendModel.get('inactiveColor');\n\n            var isSelected = legendModel.isSelected(name);\n            var itemGroup = new graphic.Group();\n\n            var textStyleModel = itemModel.getModel('textStyle');\n\n            var itemIcon = itemModel.get('icon');\n\n            var tooltipModel = itemModel.getModel('tooltip');\n            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\n            // Use user given icon first\n            legendSymbolType = itemIcon || legendSymbolType;\n            itemGroup.add(symbolCreator.createSymbol(\n                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n            ));\n\n            // Compose symbols\n            // PENDING\n            if (!itemIcon && symbolType\n                // At least show one symbol, can't be all none\n                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n            ) {\n                var size = itemHeight * 0.8;\n                if (symbolType === 'none') {\n                    symbolType = 'circle';\n                }\n                // Put symbol in the center\n                itemGroup.add(symbolCreator.createSymbol(\n                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n                    isSelected ? color : inactiveColor\n                ));\n            }\n\n            // Text\n            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n            var textAlign = itemAlign;\n\n            var formatter = legendModel.get('formatter');\n            var content = name;\n            if (typeof formatter === 'string' && formatter) {\n                content = formatter.replace('{name}', name != null ? name : '');\n            }\n            else if (typeof formatter === 'function') {\n                content = formatter(name);\n            }\n\n            var text = new graphic.Text({\n                style: {\n                    text: content,\n                    x: textX,\n                    y: itemHeight / 2,\n                    fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n                    textFont: textStyleModel.getFont(),\n                    textAlign: textAlign,\n                    textVerticalAlign: 'middle'\n                }\n            });\n            itemGroup.add(text);\n\n            // Add a invisible rect to increase the area of mouse hover\n            var hitRect = new graphic.Rect({\n                shape: itemGroup.getBoundingRect(),\n                invisible: true,\n                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n                    content: name,\n                    // Defaul formatter\n                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n                        return name;\n                    },\n                    formatterParams: {\n                        componentType: 'legend',\n                        legendIndex: legendModel.componentIndex,\n                        name: name,\n                        $vars: ['name']\n                    }\n                }, tooltipModel.option) : null\n            });\n            itemGroup.add(hitRect);\n\n            itemGroup.eachChild(function (child) {\n                child.silent = true;\n            });\n\n            hitRect.silent = !selectMode;\n\n\n\n            this.group.add(itemGroup);\n\n            graphic.setHoverStyle(itemGroup);\n\n            return itemGroup;\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/LegendView.js\n// module id = 112\n// module chunks = 0 1","/**\n * @file Legend action\n */\n\n\n    var echarts = require('../../echarts');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function legendSelectActionHandler(methodName, payload, ecModel) {\n        var selectedMap = {};\n        var isToggleSelect = methodName === 'toggleSelected';\n        var isSelected;\n        // Update all legend components\n        ecModel.eachComponent('legend', function (legendModel) {\n            if (isToggleSelect && isSelected != null) {\n                // Force other legend has same selected status\n                // Or the first is toggled to true and other are toggled to false\n                // In the case one legend has some item unSelected in option. And if other legend\n                // doesn't has the item, they will assume it is selected.\n                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n            }\n            else {\n                legendModel[methodName](payload.name);\n                isSelected = legendModel.isSelected(payload.name);\n            }\n            var legendData = legendModel.getData();\n            zrUtil.each(legendData, function (model) {\n                var name = model.get('name');\n                // Wrap element\n                if (name === '\\n' || name === '') {\n                    return;\n                }\n                var isItemSelected = legendModel.isSelected(name);\n                if (name in selectedMap) {\n                    // Unselected if any legend is unselected\n                    selectedMap[name] = selectedMap[name] && isItemSelected;\n                }\n                else {\n                    selectedMap[name] = isItemSelected;\n                }\n            });\n        });\n        // Return the event explicitly\n        return {\n            name: payload.name,\n            selected: selectedMap\n        };\n    }\n    /**\n     * @event legendToggleSelect\n     * @type {Object}\n     * @property {string} type 'legendToggleSelect'\n     * @property {string} [from]\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendToggleSelect', 'legendselectchanged',\n        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n    );\n\n    /**\n     * @event legendSelect\n     * @type {Object}\n     * @property {string} type 'legendSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendSelect', 'legendselected',\n        zrUtil.curry(legendSelectActionHandler, 'select')\n    );\n\n    /**\n     * @event legendUnSelect\n     * @type {Object}\n     * @property {string} type 'legendUnSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendUnSelect', 'legendunselected',\n        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n    );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/legendAction.js\n// module id = 113\n// module chunks = 0 1","\n   module.exports = function (ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (legendModels && legendModels.length) {\n            ecModel.filterSeries(function (series) {\n                // If in any legend component the status is not selected.\n                // Because in legend series is assumed selected when it is not in the legend data.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(series.name)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/legendFilter.js\n// module id = 114\n// module chunks = 0 1","// FIXME Better way to pack data in graphic element\n\n\n    require('./tooltip/TooltipModel');\n\n    require('./tooltip/TooltipView');\n\n    // Show tip action\n    /**\n     * @action\n     * @property {string} type\n     * @property {number} seriesIndex\n     * @property {number} dataIndex\n     * @property {number} [x]\n     * @property {number} [y]\n     */\n    require('../echarts').registerAction(\n        {\n            type: 'showTip',\n            event: 'showTip',\n            update: 'none'\n        },\n        // noop\n        function () {}\n    );\n    // Hide tip action\n    require('../echarts').registerAction(\n        {\n            type: 'hideTip',\n            event: 'hideTip',\n            update: 'none'\n        },\n        // noop\n        function () {}\n    );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip.js\n// module id = 115\n// module chunks = 0 1","/**\n * @module echarts/component/tooltip/TooltipContent\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var zrColor = require('zrender/lib/tool/color');\n    var eventUtil = require('zrender/lib/core/event');\n    var formatUtil = require('../../util/format');\n    var each = zrUtil.each;\n    var toCamelCase = formatUtil.toCamelCase;\n    var env = require('zrender/lib/core/env');\n\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n    /**\n     * @param {number} duration\n     * @return {string}\n     * @inner\n     */\n    function assembleTransition(duration) {\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n                            + 'top ' + duration + 's ' + transitionCurve;\n        return zrUtil.map(vendors, function (vendorPrefix) {\n            return vendorPrefix + 'transition:' + transitionText;\n        }).join(';');\n    }\n\n    /**\n     * @param {Object} textStyle\n     * @return {string}\n     * @inner\n     */\n    function assembleFont(textStyleModel) {\n        var cssText = [];\n\n        var fontSize = textStyleModel.get('fontSize');\n        var color = textStyleModel.getTextColor();\n\n        color && cssText.push('color:' + color);\n\n        cssText.push('font:' + textStyleModel.getFont());\n\n        fontSize &&\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\n        each(['decoration', 'align'], function (name) {\n            var val = textStyleModel.get(name);\n            val && cssText.push('text-' + name + ':' + val);\n        });\n\n        return cssText.join(';');\n    }\n\n    /**\n     * @param {Object} tooltipModel\n     * @return {string}\n     * @inner\n     */\n    function assembleCssText(tooltipModel) {\n\n        tooltipModel = tooltipModel;\n\n        var cssText = [];\n\n        var transitionDuration = tooltipModel.get('transitionDuration');\n        var backgroundColor = tooltipModel.get('backgroundColor');\n        var textStyleModel = tooltipModel.getModel('textStyle');\n        var padding = tooltipModel.get('padding');\n\n        // Animation transition\n        transitionDuration &&\n            cssText.push(assembleTransition(transitionDuration));\n\n        if (backgroundColor) {\n            if (env.canvasSupported) {\n                cssText.push('background-Color:' + backgroundColor);\n            }\n            else {\n                // for ie\n                cssText.push(\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\n                );\n                cssText.push('filter:alpha(opacity=70)');\n            }\n        }\n\n        // Border style\n        each(['width', 'color', 'radius'], function (name) {\n            var borderName = 'border-' + name;\n            var camelCase = toCamelCase(borderName);\n            var val = tooltipModel.get(camelCase);\n            val != null &&\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n        });\n\n        // Text style\n        cssText.push(assembleFont(textStyleModel));\n\n        // Padding\n        if (padding != null) {\n            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n        }\n\n        return cssText.join(';') + ';';\n    }\n\n    /**\n     * @alias module:echarts/component/tooltip/TooltipContent\n     * @constructor\n     */\n    function TooltipContent(container, api) {\n        var el = document.createElement('div');\n        var zr = api.getZr();\n\n        this.el = el;\n\n        this._x = api.getWidth() / 2;\n        this._y = api.getHeight() / 2;\n\n        container.appendChild(el);\n\n        this._container = container;\n\n        this._show = false;\n\n        /**\n         * @private\n         */\n        this._hideTimeout;\n\n        var self = this;\n        el.onmouseenter = function () {\n            // clear the timeout in hideLater and keep showing tooltip\n            if (self.enterable) {\n                clearTimeout(self._hideTimeout);\n                self._show = true;\n            }\n            self._inContent = true;\n        };\n        el.onmousemove = function (e) {\n            e = e || window.event;\n            if (!self.enterable) {\n                // Try trigger zrender event to avoid mouse\n                // in and out shape too frequently\n                var handler = zr.handler;\n                eventUtil.normalizeEvent(container, e, true);\n                handler.dispatch('mousemove', e);\n            }\n        };\n        el.onmouseleave = function () {\n            if (self.enterable) {\n                if (self._show) {\n                    self.hideLater(self._hideDelay);\n                }\n            }\n            self._inContent = false;\n        };\n    }\n\n    TooltipContent.prototype = {\n\n        constructor: TooltipContent,\n\n        enterable: true,\n\n        /**\n         * Update when tooltip is rendered\n         */\n        update: function () {\n            var container = this._container;\n            var stl = container.currentStyle\n                || document.defaultView.getComputedStyle(container);\n            var domStyle = container.style;\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n                domStyle.position = 'relative';\n            }\n            // Hide the tooltip\n            // PENDING\n            // this.hide();\n        },\n\n        show: function (tooltipModel) {\n            clearTimeout(this._hideTimeout);\n            var el = this.el;\n\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n                + (tooltipModel.get('extraCssText') || '');\n\n            el.style.display = el.innerHTML ?  'block' : 'none';\n\n            this._show = true;\n        },\n\n        setContent: function (content) {\n            var el = this.el;\n            el.innerHTML = content;\n            el.style.display = content ? 'block' : 'none';\n        },\n\n        moveTo: function (x, y) {\n            var style = this.el.style;\n            style.left = x + 'px';\n            style.top = y + 'px';\n\n            this._x = x;\n            this._y = y;\n        },\n\n        hide: function () {\n            this.el.style.display = 'none';\n            this._show = false;\n        },\n\n        // showLater: function ()\n\n        hideLater: function (time) {\n            if (this._show && !(this._inContent && this.enterable)) {\n                if (time) {\n                    this._hideDelay = time;\n                    // Set show false to avoid invoke hideLater mutiple times\n                    this._show = false;\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n                }\n                else {\n                    this.hide();\n                }\n            }\n        },\n\n        isShow: function () {\n            return this._show;\n        }\n    };\n\n    module.exports = TooltipContent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipContent.js\n// module id = 116\n// module chunks = 0 1","\n\n    require('../../echarts').extendComponentModel({\n\n        type: 'tooltip',\n\n        defaultOption: {\n            zlevel: 0,\n\n            z: 8,\n\n            show: true,\n\n            // tooltip主体内容\n            showContent: true,\n\n            // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis'\n            trigger: 'item',\n\n            // 触发条件，支持 'click' | 'mousemove' | 'none'\n            triggerOn: 'mousemove',\n\n            // 是否永远显示 content\n            alwaysShowContent: false,\n\n            // 位置 {Array} | {Function}\n            // position: null\n\n            // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。\n            confine: false,\n\n            // 内容格式器：{string}（Template） ¦ {Function}\n            // formatter: null\n\n            showDelay: 0,\n\n            // 隐藏延迟，单位ms\n            hideDelay: 100,\n\n            // 动画变换时间，单位s\n            transitionDuration: 0.4,\n\n            enterable: false,\n\n            // 提示背景颜色，默认为透明度为0.7的黑色\n            backgroundColor: 'rgba(50,50,50,0.7)',\n\n            // 提示边框颜色\n            borderColor: '#333',\n\n            // 提示边框圆角，单位px，默认为4\n            borderRadius: 4,\n\n            // 提示边框线宽，单位px，默认为0（无边框）\n            borderWidth: 0,\n\n            // 提示内边距，单位px，默认各方向内边距为5，\n            // 接受数组分别设定上右下左边距，同css\n            padding: 5,\n\n            // Extra css text\n            extraCssText: '',\n\n            // 坐标轴指示器，坐标轴触发有效\n            axisPointer: {\n                // 默认为直线\n                // 可选为：'line' | 'shadow' | 'cross'\n                type: 'line',\n\n                // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选\n                // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'\n                // 默认 'auto'，会选择类型为 cateogry 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴\n                // 极坐标系会默认选择 angle 轴\n                axis: 'auto',\n\n                animation: true,\n                animationDurationUpdate: 200,\n                animationEasingUpdate: 'exponentialOut',\n\n                // 直线指示器样式设置\n                lineStyle: {\n                    color: '#555',\n                    width: 1,\n                    type: 'solid'\n                },\n\n                crossStyle: {\n                    color: '#555',\n                    width: 1,\n                    type: 'dashed',\n\n                    // TODO formatter\n                    textStyle: {}\n                },\n\n                // 阴影指示器样式设置\n                shadowStyle: {\n                    color: 'rgba(150,150,150,0.3)'\n                }\n            },\n            textStyle: {\n                color: '#fff',\n                fontSize: 14\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipModel.js\n// module id = 117\n// module chunks = 0 1","\n\n    var TooltipContent = require('./TooltipContent');\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var numberUtil = require('../../util/number');\n    var modelUtil = require('../../util/model');\n    var parsePercent = numberUtil.parsePercent;\n    var env = require('zrender/lib/core/env');\n    var Model = require('../../model/Model');\n\n    function dataEqual(a, b) {\n        if (!a || !b) {\n            return false;\n        }\n        var round = numberUtil.round;\n        return round(a[0]) === round(b[0])\n            && round(a[1]) === round(b[1]);\n    }\n    /**\n     * @inner\n     */\n    function makeLineShape(x1, y1, x2, y2) {\n        return {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function makeRectShape(x, y, width, height) {\n        return {\n            x: x,\n            y: y,\n            width: width,\n            height: height\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n        return {\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: r,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            clockwise: true\n        };\n    }\n\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n        var gap = 20;\n\n        if (x + width + gap > viewWidth) {\n            x -= width + gap;\n        }\n        else {\n            x += gap;\n        }\n        if (y + height + gap > viewHeight) {\n            y -= height + gap;\n        }\n        else {\n            y += gap;\n        }\n        return [x, y];\n    }\n\n    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        x = Math.min(x + width, viewWidth) - width;\n        y = Math.min(y + height, viewHeight) - height;\n        x = Math.max(x, 0);\n        y = Math.max(y, 0);\n\n        return [x, y];\n    }\n\n    function calcTooltipPosition(position, rect, dom) {\n        var domWidth = dom.clientWidth;\n        var domHeight = dom.clientHeight;\n        var gap = 5;\n        var x = 0;\n        var y = 0;\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n        switch (position) {\n            case 'inside':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'top':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y - domHeight - gap;\n                break;\n            case 'bottom':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight + gap;\n                break;\n            case 'left':\n                x = rect.x - domWidth - gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'right':\n                x = rect.x + rectWidth + gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n        }\n        return [x, y];\n    }\n\n    /**\n     * @param  {string|Function|Array.<number>} positionExpr\n     * @param  {number} x Mouse x\n     * @param  {number} y Mouse y\n     * @param  {boolean} confine Whether confine tooltip content in view rect.\n     * @param  {module:echarts/component/tooltip/TooltipContent} content\n     * @param  {Object|<Array.<Object>} params\n     * @param  {module:zrender/Element} el target element\n     * @param  {module:echarts/ExtensionAPI} api\n     * @return {Array.<number>}\n     */\n    function updatePosition(positionExpr, x, y, confine, content, params, el, api) {\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n\n        var rect = el && el.getBoundingRect().clone();\n        el && rect.applyTransform(el.transform);\n        if (typeof positionExpr === 'function') {\n            // Callback of position can be an array or a string specify the position\n            positionExpr = positionExpr([x, y], params, content.el, rect);\n        }\n\n        if (zrUtil.isArray(positionExpr)) {\n            x = parsePercent(positionExpr[0], viewWidth);\n            y = parsePercent(positionExpr[1], viewHeight);\n        }\n        // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n        else if (typeof positionExpr === 'string' && el) {\n            var pos = calcTooltipPosition(\n                positionExpr, rect, content.el\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n        else {\n            var pos = refixTooltipPosition(\n                x, y, content.el, viewWidth, viewHeight\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n\n        if (confine) {\n            var pos = confineTooltipPosition(\n                x, y, content.el, viewWidth, viewHeight\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n\n        content.moveTo(x, y);\n    }\n\n    function ifSeriesSupportAxisTrigger(seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n        var trigger = seriesModel.get('tooltip.trigger', true);\n        // Ignore series use item tooltip trigger and series coordinate system is not cartesian or\n        return !(!coordSys\n            || (coordSys.type !== 'cartesian2d' && coordSys.type !== 'polar' && coordSys.type !== 'singleAxis')\n            || trigger === 'item');\n    }\n\n    require('../../echarts').extendComponentView({\n\n        type: 'tooltip',\n\n        _axisPointers: {},\n\n        init: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var tooltipContent = new TooltipContent(api.getDom(), api);\n            this._tooltipContent = tooltipContent;\n\n            api.on('showTip', this._manuallyShowTip, this);\n            api.on('hideTip', this._manuallyHideTip, this);\n        },\n\n        render: function (tooltipModel, ecModel, api) {\n            if (env.node) {\n                return;\n            }\n\n            // Reset\n            this.group.removeAll();\n\n            /**\n             * @type {Object}\n             * @private\n             */\n            this._axisPointers = {};\n\n            /**\n             * @private\n             * @type {module:echarts/component/tooltip/TooltipModel}\n             */\n            this._tooltipModel = tooltipModel;\n\n            /**\n             * @private\n             * @type {module:echarts/model/Global}\n             */\n            this._ecModel = ecModel;\n\n            /**\n             * @private\n             * @type {module:echarts/ExtensionAPI}\n             */\n            this._api = api;\n\n            /**\n             * @type {Object}\n             * @private\n             */\n            this._lastHover = {\n                // data\n                // payloadBatch\n            };\n\n            var tooltipContent = this._tooltipContent;\n            tooltipContent.update();\n            tooltipContent.enterable = tooltipModel.get('enterable');\n            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\n            /**\n             * @type {Object.<string, Array>}\n             */\n            this._seriesGroupByAxis = this._prepareAxisTriggerData(\n                tooltipModel, ecModel\n            );\n\n            var crossText = this._crossText;\n            if (crossText) {\n                this.group.add(crossText);\n            }\n\n            var triggerOn = tooltipModel.get('triggerOn');\n\n            // Try to keep the tooltip show when refreshing\n            if (this._lastX != null\n                && this._lastY != null\n                // When user is willing to control tooltip totally using API,\n                // self._manuallyShowTip({x, y}) might cause tooltip hide,\n                // which is not expected.\n                && triggerOn !== 'none'\n            ) {\n                var self = this;\n                clearTimeout(this._refreshUpdateTimeout);\n                this._refreshUpdateTimeout = setTimeout(function () {\n                    // Show tip next tick after other charts are rendered\n                    // In case highlight action has wrong result\n                    // FIXME\n                    self._manuallyShowTip({\n                        x: self._lastX,\n                        y: self._lastY\n                    });\n                });\n            }\n\n            var zr = this._api.getZr();\n            zr.off('click', this._tryShow);\n            zr.off('mousemove', this._mousemove);\n            zr.off('mouseout', this._hide);\n            zr.off('globalout', this._hide);\n\n            if (triggerOn === 'click') {\n                zr.on('click', this._tryShow, this);\n            }\n            else if (triggerOn === 'mousemove') {\n                zr.on('mousemove', this._mousemove, this);\n                zr.on('mouseout', this._hide, this);\n                zr.on('globalout', this._hide, this);\n            }\n            // else triggerOn is 'none', which enable user\n            // to control tooltip totally using API.\n        },\n\n        _mousemove: function (e) {\n            var showDelay = this._tooltipModel.get('showDelay');\n            var self = this;\n            clearTimeout(this._showTimeout);\n            if (showDelay > 0) {\n                this._showTimeout = setTimeout(function () {\n                    self._tryShow(e);\n                }, showDelay);\n            }\n            else {\n                this._tryShow(e);\n            }\n        },\n\n        /**\n         * Show tip manually by\n         * dispatchAction({\n         *     type: 'showTip',\n         *     x: 10,\n         *     y: 10\n         * });\n         * Or\n         * dispatchAction({\n         *      type: 'showTip',\n         *      seriesIndex: 0,\n         *      dataIndex or dataIndexInside or name\n         * });\n         *\n         *  TODO Batch\n         */\n        _manuallyShowTip: function (event) {\n            // From self\n            if (event.from === this.uid) {\n                return;\n            }\n\n            var ecModel = this._ecModel;\n            var seriesIndex = event.seriesIndex;\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n            var api = this._api;\n\n            var isTriggerAxis = this._tooltipModel.get('trigger') === 'axis';\n            function seriesHaveDataOnIndex(_series) {\n                var data = _series.getData();\n                var dataIndex = modelUtil.queryDataIndex(data, event);\n                // Have single dataIndex\n                if (dataIndex != null && !zrUtil.isArray(dataIndex)\n                    && data.hasValue(dataIndex)\n                ) {\n                    return true;\n                }\n            }\n\n            if (event.x == null || event.y == null) {\n                if (isTriggerAxis) {\n                    // Find another series.\n                    if (seriesModel && !seriesHaveDataOnIndex(seriesModel)) {\n                        seriesModel = null;\n                    }\n                    if (!seriesModel) {\n                        // Find the first series can use axis trigger And data is not null\n                        ecModel.eachSeries(function (_series) {\n                            if (ifSeriesSupportAxisTrigger(_series) && !seriesModel) {\n                                if (seriesHaveDataOnIndex(_series)) {\n                                    seriesModel = _series;\n                                }\n                            }\n                        });\n                    }\n                }\n                else {\n                    // Use the first series by default.\n                    seriesModel = seriesModel || ecModel.getSeriesByIndex(0);\n                }\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var dataIndex = modelUtil.queryDataIndex(data, event);\n\n                    if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n                        return;\n                    }\n\n                    var el = data.getItemGraphicEl(dataIndex);\n                    var cx;\n                    var cy;\n                    // Try to get the point in coordinate system\n                    var coordSys = seriesModel.coordinateSystem;\n                    if (seriesModel.getTooltipPosition) {\n                        var point = seriesModel.getTooltipPosition(dataIndex) || [];\n                        cx = point[0];\n                        cy = point[1];\n                    }\n                    else if (coordSys && coordSys.dataToPoint) {\n                        var point = coordSys.dataToPoint(\n                            data.getValues(\n                                zrUtil.map(coordSys.dimensions, function (dim) {\n                                    return seriesModel.coordDimToDataDim(dim)[0];\n                                }), dataIndex, true\n                            )\n                        );\n                        cx = point && point[0];\n                        cy = point && point[1];\n                    }\n                    else if (el) {\n                        // Use graphic bounding rect\n                        var rect = el.getBoundingRect().clone();\n                        rect.applyTransform(el.transform);\n                        cx = rect.x + rect.width / 2;\n                        cy = rect.y + rect.height / 2;\n                    }\n\n                    if (cx != null && cy != null) {\n                        this._tryShow({\n                            offsetX: cx,\n                            offsetY: cy,\n                            position: event.position,\n                            target: el,\n                            event: {}\n                        });\n                    }\n                }\n            }\n            else {\n                var el = api.getZr().handler.findHover(event.x, event.y);\n                this._tryShow({\n                    offsetX: event.x,\n                    offsetY: event.y,\n                    position: event.position,\n                    target: el,\n                    event: {}\n                });\n            }\n        },\n\n        _manuallyHideTip: function (e) {\n            if (e.from === this.uid) {\n                return;\n            }\n\n            this._hide();\n        },\n\n        _prepareAxisTriggerData: function (tooltipModel, ecModel) {\n            // Prepare data for axis trigger\n            var seriesGroupByAxis = {};\n            ecModel.eachSeries(function (seriesModel) {\n                if (ifSeriesSupportAxisTrigger(seriesModel)) {\n                    var coordSys = seriesModel.coordinateSystem;\n                    var baseAxis;\n                    var key;\n\n                    // Only cartesian2d, polar and single support axis trigger\n                    if (coordSys.type === 'cartesian2d') {\n                        // FIXME `axisPointer.axis` is not baseAxis\n                        baseAxis = coordSys.getBaseAxis();\n                        key = baseAxis.dim + baseAxis.index;\n                    }\n                    else if (coordSys.type === 'singleAxis') {\n                        baseAxis = coordSys.getAxis();\n                        key = baseAxis.dim + baseAxis.type;\n                    }\n                    else {\n                        baseAxis = coordSys.getBaseAxis();\n                        key = baseAxis.dim + coordSys.name;\n                    }\n\n                    seriesGroupByAxis[key] = seriesGroupByAxis[key] || {\n                        coordSys: [],\n                        series: []\n                    };\n                    seriesGroupByAxis[key].coordSys.push(coordSys);\n                    seriesGroupByAxis[key].series.push(seriesModel);\n                }\n            }, this);\n\n            return seriesGroupByAxis;\n        },\n\n        /**\n         * mousemove handler\n         * @param {Object} e\n         * @private\n         */\n        _tryShow: function (e) {\n            var el = e.target;\n            var tooltipModel = this._tooltipModel;\n            var globalTrigger = tooltipModel.get('trigger');\n            var ecModel = this._ecModel;\n            var api = this._api;\n\n            if (!tooltipModel) {\n                return;\n            }\n\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n            this._lastX = e.offsetX;\n            this._lastY = e.offsetY;\n\n            // Always show item tooltip if mouse is on the element with dataIndex\n            if (el && el.dataIndex != null) {\n                // Use dataModel in element if possible\n                // Used when mouseover on a element like markPoint or edge\n                // In which case, the data is not main data in series.\n                var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                var dataIndex = el.dataIndex;\n                var itemModel = dataModel.getData().getItemModel(dataIndex);\n                // Series or single data may use item trigger when global is axis trigger\n                if ((itemModel.get('tooltip.trigger') || globalTrigger) === 'axis') {\n                    this._showAxisTooltip(tooltipModel, ecModel, e);\n                }\n                else {\n                    // Reset ticket\n                    this._ticket = '';\n                    // If either single data or series use item trigger\n                    this._hideAxisPointer();\n                    // Reset last hover and dispatch downplay action\n                    this._resetLastHover();\n\n                    this._showItemTooltipContent(dataModel, dataIndex, el.dataType, e);\n                }\n\n                api.dispatchAction({\n                    type: 'showTip',\n                    from: this.uid,\n                    dataIndexInside: el.dataIndex,\n                    seriesIndex: el.seriesIndex\n                });\n            }\n            // Tooltip provided directly. Like legend\n            else if (el && el.tooltip) {\n                var tooltipOpt = el.tooltip;\n                if (typeof tooltipOpt === 'string') {\n                    var content = tooltipOpt;\n                    tooltipOpt = {\n                        content: content,\n                        // Fixed formatter\n                        formatter: content\n                    };\n                }\n                var subTooltipModel = new Model(tooltipOpt, tooltipModel);\n                var defaultHtml = subTooltipModel.get('content');\n                var asyncTicket = Math.random();\n                this._showTooltipContent(\n                    // TODO params\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el, api\n                );\n            }\n            else {\n                if (globalTrigger === 'item') {\n                    this._hide();\n                }\n                else {\n                    // Try show axis tooltip\n                    this._showAxisTooltip(tooltipModel, ecModel, e);\n                }\n\n                // Action of cross pointer\n                // other pointer types will trigger action in _dispatchAndShowSeriesTooltipContent method\n                if (tooltipModel.get('axisPointer.type') === 'cross') {\n                    api.dispatchAction({\n                        type: 'showTip',\n                        from: this.uid,\n                        x: e.offsetX,\n                        y: e.offsetY\n                    });\n                }\n            }\n        },\n\n        /**\n         * Show tooltip on axis\n         * @param {module:echarts/component/tooltip/TooltipModel} tooltipModel\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Object} e\n         * @private\n         */\n        _showAxisTooltip: function (tooltipModel, ecModel, e) {\n            var axisPointerModel = tooltipModel.getModel('axisPointer');\n            var axisPointerType = axisPointerModel.get('type');\n\n            if (axisPointerType === 'cross') {\n                var el = e.target;\n                if (el && el.dataIndex != null) {\n                    var seriesModel = ecModel.getSeriesByIndex(el.seriesIndex);\n                    var dataIndex = el.dataIndex;\n                    this._showItemTooltipContent(seriesModel, dataIndex, el.dataType, e);\n                }\n            }\n\n            this._showAxisPointer();\n            var allNotShow = true;\n            zrUtil.each(this._seriesGroupByAxis, function (seriesCoordSysSameAxis) {\n                // Try show the axis pointer\n                var allCoordSys = seriesCoordSysSameAxis.coordSys;\n                var coordSys = allCoordSys[0];\n\n                // If mouse position is not in the grid or polar\n                var point = [e.offsetX, e.offsetY];\n\n                if (!coordSys.containPoint(point)) {\n                    // Hide axis pointer\n                    this._hideAxisPointer(coordSys.name);\n                    return;\n                }\n\n                allNotShow = false;\n                // Make sure point is discrete on cateogry axis\n                var dimensions = coordSys.dimensions;\n                var value = coordSys.pointToData(point, true);\n                point = coordSys.dataToPoint(value);\n                var baseAxis = coordSys.getBaseAxis();\n                var axisType = axisPointerModel.get('axis');\n                if (axisType === 'auto') {\n                    axisType = baseAxis.dim;\n                }\n\n                var contentNotChange = false;\n                var lastHover = this._lastHover;\n                if (axisPointerType === 'cross') {\n                    // If hover data not changed\n                    // Possible when two axes are all category\n                    if (dataEqual(lastHover.data, value)) {\n                        contentNotChange = true;\n                    }\n                    lastHover.data = value;\n                }\n                else {\n                    var valIndex = zrUtil.indexOf(dimensions, axisType);\n\n                    // If hover data not changed on the axis dimension\n                    if (lastHover.data === value[valIndex]) {\n                        contentNotChange = true;\n                    }\n                    lastHover.data = value[valIndex];\n                }\n\n                var enableAnimation = tooltipModel.get('animation');\n\n                if (coordSys.type === 'cartesian2d' && !contentNotChange) {\n                    this._showCartesianPointer(\n                        axisPointerModel, coordSys, axisType, point, enableAnimation\n                    );\n                }\n                else if (coordSys.type === 'polar' && !contentNotChange) {\n                    this._showPolarPointer(\n                        axisPointerModel, coordSys, axisType, point, enableAnimation\n                    );\n                }\n                else if (coordSys.type === 'singleAxis' && !contentNotChange) {\n                    this._showSinglePointer(\n                        axisPointerModel, coordSys, axisType, point, enableAnimation\n                    );\n                }\n\n                if (axisPointerType !== 'cross') {\n                    this._dispatchAndShowSeriesTooltipContent(\n                        coordSys, seriesCoordSysSameAxis.series, point, value, contentNotChange, e.position\n                    );\n                }\n            }, this);\n\n            if (!this._tooltipModel.get('show')) {\n                this._hideAxisPointer();\n            }\n\n            if (allNotShow) {\n                this._hide();\n            }\n        },\n\n        /**\n         * Show tooltip on axis of cartesian coordinate\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @param {module:echarts/coord/cartesian/Cartesian2D} cartesians\n         * @param {string} axisType\n         * @param {Array.<number>} point\n         * @private\n         */\n        _showCartesianPointer: function (axisPointerModel, cartesian, axisType, point, enableAnimation) {\n            var self = this;\n\n            var axisPointerType = axisPointerModel.get('type');\n            var baseAxis = cartesian.getBaseAxis();\n            var moveAnimation = enableAnimation\n                && axisPointerType !== 'cross'\n                && baseAxis.type === 'category'\n                && baseAxis.getBandWidth() > 20;\n\n            if (axisPointerType === 'cross') {\n                moveGridLine('x', point, cartesian.getAxis('y').getGlobalExtent());\n                moveGridLine('y', point, cartesian.getAxis('x').getGlobalExtent());\n\n                this._updateCrossText(cartesian, point, axisPointerModel);\n            }\n            else {\n                var otherAxis = cartesian.getAxis(axisType === 'x' ? 'y' : 'x');\n                var otherExtent = otherAxis.getGlobalExtent();\n\n                if (cartesian.type === 'cartesian2d') {\n                    (axisPointerType === 'line' ? moveGridLine : moveGridShadow)(\n                        axisType, point, otherExtent\n                    );\n                }\n            }\n\n            /**\n             * @inner\n             */\n            function moveGridLine(axisType, point, otherExtent) {\n                var targetShape = axisType === 'x'\n                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\n                var pointerEl = self._getPointerElement(\n                    cartesian, axisPointerModel, axisType, targetShape\n                );\n                graphic.subPixelOptimizeLine({\n                    shape: targetShape,\n                    style: pointerEl.style\n                });\n\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n            /**\n             * @inner\n             */\n            function moveGridShadow(axisType, point, otherExtent) {\n                var axis = cartesian.getAxis(axisType);\n                var bandWidth = axis.getBandWidth();\n                var span = otherExtent[1] - otherExtent[0];\n                var targetShape = axisType === 'x'\n                    ? makeRectShape(point[0] - bandWidth / 2, otherExtent[0], bandWidth, span)\n                    : makeRectShape(otherExtent[0], point[1] - bandWidth / 2, span, bandWidth);\n\n                var pointerEl = self._getPointerElement(\n                    cartesian, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n        },\n\n        _showSinglePointer: function (axisPointerModel, single, axisType, point, enableAnimation) {\n            var self = this;\n            var axisPointerType = axisPointerModel.get('type');\n            var moveAnimation =\n                enableAnimation\n                && axisPointerType !== 'cross'\n                && single.getBaseAxis().type === 'category';\n            var rect = single.getRect();\n            var otherExtent = [rect.y, rect.y + rect.height];\n\n            moveSingleLine(axisType, point, otherExtent);\n\n            /**\n             * @inner\n             */\n            function moveSingleLine(axisType, point, otherExtent) {\n                var axis = single.getAxis();\n                var orient = axis.orient;\n\n                var targetShape = orient === 'horizontal'\n                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\n                var pointerEl = self._getPointerElement(\n                    single, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n        },\n\n        /**\n         * Show tooltip on axis of polar coordinate\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @param {Array.<module:echarts/coord/polar/Polar>} polar\n         * @param {string} axisType\n         * @param {Array.<number>} point\n         */\n        _showPolarPointer: function (axisPointerModel, polar, axisType, point, enableAnimation) {\n            var self = this;\n\n            var axisPointerType = axisPointerModel.get('type');\n\n            var angleAxis = polar.getAngleAxis();\n            var radiusAxis = polar.getRadiusAxis();\n\n            var moveAnimation = enableAnimation\n                && axisPointerType !== 'cross'\n                && polar.getBaseAxis().type === 'category';\n\n            if (axisPointerType === 'cross') {\n                movePolarLine('angle', point, radiusAxis.getExtent());\n                movePolarLine('radius', point, angleAxis.getExtent());\n\n                this._updateCrossText(polar, point, axisPointerModel);\n            }\n            else {\n                var otherAxis = polar.getAxis(axisType === 'radius' ? 'angle' : 'radius');\n                var otherExtent = otherAxis.getExtent();\n\n                (axisPointerType === 'line' ? movePolarLine : movePolarShadow)(\n                    axisType, point, otherExtent\n                );\n            }\n            /**\n             * @inner\n             */\n            function movePolarLine(axisType, point, otherExtent) {\n                var mouseCoord = polar.pointToCoord(point);\n\n                var targetShape;\n\n                if (axisType === 'angle') {\n                    var p1 = polar.coordToPoint([otherExtent[0], mouseCoord[1]]);\n                    var p2 = polar.coordToPoint([otherExtent[1], mouseCoord[1]]);\n                    targetShape = makeLineShape(p1[0], p1[1], p2[0], p2[1]);\n                }\n                else {\n                    targetShape = {\n                        cx: polar.cx,\n                        cy: polar.cy,\n                        r: mouseCoord[0]\n                    };\n                }\n\n                var pointerEl = self._getPointerElement(\n                    polar, axisPointerModel, axisType, targetShape\n                );\n\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n            /**\n             * @inner\n             */\n            function movePolarShadow(axisType, point, otherExtent) {\n                var axis = polar.getAxis(axisType);\n                var bandWidth = axis.getBandWidth();\n\n                var mouseCoord = polar.pointToCoord(point);\n\n                var targetShape;\n\n                var radian = Math.PI / 180;\n\n                if (axisType === 'angle') {\n                    targetShape = makeSectorShape(\n                        polar.cx, polar.cy,\n                        otherExtent[0], otherExtent[1],\n                        // In ECharts y is negative if angle is positive\n                        (-mouseCoord[1] - bandWidth / 2) * radian,\n                        (-mouseCoord[1] + bandWidth / 2) * radian\n                    );\n                }\n                else {\n                    targetShape = makeSectorShape(\n                        polar.cx, polar.cy,\n                        mouseCoord[0] - bandWidth / 2,\n                        mouseCoord[0] + bandWidth / 2,\n                        0, Math.PI * 2\n                    );\n                }\n\n                var pointerEl = self._getPointerElement(\n                    polar, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n        },\n\n        _updateCrossText: function (coordSys, point, axisPointerModel) {\n            var crossStyleModel = axisPointerModel.getModel('crossStyle');\n            var textStyleModel = crossStyleModel.getModel('textStyle');\n\n            var tooltipModel = this._tooltipModel;\n\n            var text = this._crossText;\n            if (!text) {\n                text = this._crossText = new graphic.Text({\n                    style: {\n                        textAlign: 'left',\n                        textVerticalAlign: 'bottom'\n                    }\n                });\n                this.group.add(text);\n            }\n\n            var value = coordSys.pointToData(point);\n\n            var dims = coordSys.dimensions;\n            value = zrUtil.map(value, function (val, idx) {\n                var axis = coordSys.getAxis(dims[idx]);\n                if (axis.type === 'category' || axis.type === 'time') {\n                    val = axis.scale.getLabel(val);\n                }\n                else {\n                    val = formatUtil.addCommas(\n                        val.toFixed(axis.getPixelPrecision())\n                    );\n                }\n                return val;\n            });\n\n            text.setStyle({\n                fill: textStyleModel.getTextColor() || crossStyleModel.get('color'),\n                textFont: textStyleModel.getFont(),\n                text: value.join(', '),\n                x: point[0] + 5,\n                y: point[1] - 5\n            });\n            text.z = tooltipModel.get('z');\n            text.zlevel = tooltipModel.get('zlevel');\n        },\n\n        _getPointerElement: function (coordSys, pointerModel, axisType, initShape) {\n            var tooltipModel = this._tooltipModel;\n            var z = tooltipModel.get('z');\n            var zlevel = tooltipModel.get('zlevel');\n            var axisPointers = this._axisPointers;\n            var coordSysName = coordSys.name;\n            axisPointers[coordSysName] = axisPointers[coordSysName] || {};\n            if (axisPointers[coordSysName][axisType]) {\n                return axisPointers[coordSysName][axisType];\n            }\n\n            // Create if not exists\n            var pointerType = pointerModel.get('type');\n            var styleModel = pointerModel.getModel(pointerType + 'Style');\n            var isShadow = pointerType === 'shadow';\n            var style = styleModel[isShadow ? 'getAreaStyle' : 'getLineStyle']();\n\n            var elementType = coordSys.type === 'polar'\n                ? (isShadow ? 'Sector' : (axisType === 'radius' ? 'Circle' : 'Line'))\n                : (isShadow ? 'Rect' : 'Line');\n\n            isShadow ? (style.stroke = null) : (style.fill = null);\n\n            var el = axisPointers[coordSysName][axisType] = new graphic[elementType]({\n                style: style,\n                z: z,\n                zlevel: zlevel,\n                silent: true,\n                shape: initShape\n            });\n\n            this.group.add(el);\n            return el;\n        },\n\n        /**\n         * Dispatch actions and show tooltip on series\n         * @param {Array.<module:echarts/model/Series>} seriesList\n         * @param {Array.<number>} point\n         * @param {Array.<number>} value\n         * @param {boolean} contentNotChange\n         * @param {Array.<number>|string|Function} [positionExpr]\n         */\n        _dispatchAndShowSeriesTooltipContent: function (\n            coordSys, seriesList, point, value, contentNotChange, positionExpr\n        ) {\n\n            var rootTooltipModel = this._tooltipModel;\n\n            var baseAxis = coordSys.getBaseAxis();\n            var baseDimIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\n            var payloadBatch = zrUtil.map(seriesList, function (series) {\n                return {\n                    seriesIndex: series.seriesIndex,\n                    dataIndexInside: series.getAxisTooltipDataIndex\n                        ? series.getAxisTooltipDataIndex(series.coordDimToDataDim(baseAxis.dim), value, baseAxis)\n                        : series.getData().indexOfNearest(\n                            series.coordDimToDataDim(baseAxis.dim)[0],\n                            value[baseDimIndex],\n                            // Add a threshold to avoid find the wrong dataIndex when data length is not same\n                            false, baseAxis.type === 'category' ? 0.5 : null\n                        )\n                };\n            });\n            var sampleSeriesIndex;\n            zrUtil.each(payloadBatch, function (payload, idx) {\n                if (seriesList[idx].getData().hasValue(payload.dataIndexInside)) {\n                    sampleSeriesIndex = idx;\n                }\n            });\n            // Fallback to 0.\n            sampleSeriesIndex = sampleSeriesIndex || 0;\n\n            var lastHover = this._lastHover;\n            var api = this._api;\n            // Dispatch downplay action\n            if (lastHover.payloadBatch && !contentNotChange) {\n                api.dispatchAction({\n                    type: 'downplay',\n                    batch: lastHover.payloadBatch\n                });\n            }\n            // Dispatch highlight action\n            if (!contentNotChange) {\n                api.dispatchAction({\n                    type: 'highlight',\n                    batch: payloadBatch\n                });\n                lastHover.payloadBatch = payloadBatch;\n            }\n            // Dispatch showTip action\n            api.dispatchAction({\n                type: 'showTip',\n                dataIndexInside: payloadBatch[sampleSeriesIndex].dataIndexInside,\n                seriesIndex: payloadBatch[sampleSeriesIndex].seriesIndex,\n                from: this.uid\n            });\n\n            if (baseAxis && rootTooltipModel.get('showContent') && rootTooltipModel.get('show')) {\n                var paramsList = zrUtil.map(seriesList, function (series, index) {\n                    return series.getDataParams(payloadBatch[index].dataIndexInside);\n                });\n\n                if (!contentNotChange) {\n                    // Update html content\n                    var firstDataIndex = payloadBatch[sampleSeriesIndex].dataIndexInside;\n\n                    // Default tooltip content\n                    // FIXME\n                    // (1) shold be the first data which has name?\n                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n                    var firstLine = baseAxis.type === 'time'\n                        ? baseAxis.scale.getLabel(value[baseDimIndex])\n                        : seriesList[sampleSeriesIndex].getData().getName(firstDataIndex);\n                    var defaultHtml = (firstLine ? firstLine + '<br />' : '')\n                        + zrUtil.map(seriesList, function (series, index) {\n                            return series.formatTooltip(payloadBatch[index].dataIndexInside, true);\n                        }).join('<br />');\n\n                    var asyncTicket = 'axis_' + coordSys.name + '_' + firstDataIndex;\n\n                    this._showTooltipContent(\n                        rootTooltipModel, defaultHtml, paramsList, asyncTicket,\n                        point[0], point[1], positionExpr, null, api\n                    );\n                }\n                else {\n                    updatePosition(\n                        positionExpr || rootTooltipModel.get('position'),\n                        point[0], point[1],\n                        rootTooltipModel.get('confine'),\n                        this._tooltipContent, paramsList, null, api\n                    );\n                }\n            }\n        },\n\n        /**\n         * Show tooltip on item\n         * @param {module:echarts/model/Series} seriesModel\n         * @param {number} dataIndex\n         * @param {string} dataType\n         * @param {Object} e\n         */\n        _showItemTooltipContent: function (seriesModel, dataIndex, dataType, e) {\n            // FIXME Graph data\n            var api = this._api;\n            var data = seriesModel.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var tooltipOpt = itemModel.get('tooltip', true);\n            if (typeof tooltipOpt === 'string') {\n                // In each data item tooltip can be simply write:\n                // {\n                //  value: 10,\n                //  tooltip: 'Something you need to know'\n                // }\n                var tooltipContent = tooltipOpt;\n                tooltipOpt = {\n                    formatter: tooltipContent\n                };\n            }\n            var rootTooltipModel = this._tooltipModel;\n            var seriesTooltipModel = seriesModel.getModel(\n                'tooltip', rootTooltipModel\n            );\n            var tooltipModel = new Model(tooltipOpt, seriesTooltipModel, seriesTooltipModel.ecModel);\n\n            var params = seriesModel.getDataParams(dataIndex, dataType);\n            var defaultHtml = seriesModel.formatTooltip(dataIndex, false, dataType);\n\n            var asyncTicket = 'item_' + seriesModel.name + '_' + dataIndex;\n\n            this._showTooltipContent(\n                tooltipModel, defaultHtml, params, asyncTicket,\n                e.offsetX, e.offsetY, e.position, e.target, api\n            );\n        },\n\n        _showTooltipContent: function (\n            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, target, api\n        ) {\n            // Reset ticket\n            this._ticket = '';\n\n            if (tooltipModel.get('showContent') && tooltipModel.get('show')) {\n                var tooltipContent = this._tooltipContent;\n                var confine = tooltipModel.get('confine');\n\n                var formatter = tooltipModel.get('formatter');\n                positionExpr = positionExpr || tooltipModel.get('position');\n                var html = defaultHtml;\n\n                if (formatter) {\n                    if (typeof formatter === 'string') {\n                        html = formatUtil.formatTpl(formatter, params);\n                    }\n                    else if (typeof formatter === 'function') {\n                        var self = this;\n                        var ticket = asyncTicket;\n                        var callback = function (cbTicket, html) {\n                            if (cbTicket === self._ticket) {\n                                tooltipContent.setContent(html);\n\n                                updatePosition(\n                                    positionExpr, x, y, confine,\n                                    tooltipContent, params, target, api\n                                );\n                            }\n                        };\n                        self._ticket = ticket;\n                        html = formatter(params, ticket, callback);\n                    }\n                }\n\n                tooltipContent.show(tooltipModel);\n                tooltipContent.setContent(html);\n\n                updatePosition(\n                    positionExpr, x, y, confine,\n                    tooltipContent, params, target, api\n                );\n            }\n        },\n\n        /**\n         * Show axis pointer\n         * @param {string} [coordSysName]\n         */\n        _showAxisPointer: function (coordSysName) {\n            if (coordSysName) {\n                var axisPointers = this._axisPointers[coordSysName];\n                axisPointers && zrUtil.each(axisPointers, function (el) {\n                    el.show();\n                });\n            }\n            else {\n                this.group.eachChild(function (child) {\n                    child.show();\n                });\n                this.group.show();\n            }\n        },\n\n        _resetLastHover: function () {\n            var lastHover = this._lastHover;\n            if (lastHover.payloadBatch) {\n                this._api.dispatchAction({\n                    type: 'downplay',\n                    batch: lastHover.payloadBatch\n                });\n            }\n            // Reset lastHover\n            this._lastHover = {};\n        },\n        /**\n         * Hide axis pointer\n         * @param {string} [coordSysName]\n         */\n        _hideAxisPointer: function (coordSysName) {\n            if (coordSysName) {\n                var axisPointers = this._axisPointers[coordSysName];\n                axisPointers && zrUtil.each(axisPointers, function (el) {\n                    el.hide();\n                });\n            }\n            else {\n                if (this.group.children().length) {\n                    this.group.hide();\n                }\n            }\n        },\n\n        _hide: function () {\n            clearTimeout(this._showTimeout);\n\n            this._hideAxisPointer();\n            this._resetLastHover();\n            if (!this._alwaysShowContent) {\n                this._tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n            }\n\n            this._api.dispatchAction({\n                type: 'hideTip',\n                from: this.uid\n            });\n\n            this._lastX = this._lastY = null;\n        },\n\n        dispose: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var zr = api.getZr();\n            this._tooltipContent.hide();\n\n            zr.off('click', this._tryShow);\n            zr.off('mousemove', this._mousemove);\n            zr.off('mouseout', this._hide);\n            zr.off('globalout', this._hide);\n\n            api.off('showTip', this._manuallyShowTip);\n            api.off('hideTip', this._manuallyHideTip);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipView.js\n// module id = 118\n// module chunks = 0 1","'use strict';\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            var key = keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/DataDiffer.js\n// module id = 120\n// module chunks = 0 1","/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * Complete the dimensions array guessed from the data structure.\n     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n     * @return {Array.<string>}\n     */\n    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n        if (!data) {\n            return dimensions;\n        }\n\n        var value0 = retrieveValue(data[0]);\n        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\n        defaultNames = defaultNames || [];\n        extraPrefix = extraPrefix || 'extra';\n        for (var i = 0; i < dimSize; i++) {\n            if (!dimensions[i]) {\n                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));\n                dimensions[i] = guessOrdinal(data, i)\n                    ? {type: 'ordinal', name: name}\n                    : name;\n            }\n        }\n\n        return dimensions;\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            if (value != null && isFinite(value)) {\n                return false;\n            }\n            else if (zrUtil.isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/helper/completeDimensions.js\n// module id = 121\n// module chunks = 0 1","\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/loading/default.js\n// module id = 122\n// module chunks = 0 1","/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var Model = require('./Model');\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = require('./Component');\n\n    var globalDefault = require('./globalDefault');\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption();\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            // 如果不存在对应的 component model 则直接 merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION 同步是否要改回原来的\n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap[mainType], newCptOptionList\n                );\n\n                modelUtil.makeIdAndName(mapResult);\n\n                // Set mainType and complete subType.\n                each(mapResult, function (item, index) {\n                    var opt = item.option;\n                    if (isObject(opt)) {\n                        item.keyInfo.mainType = mainType;\n                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n                    }\n                });\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap[mainType] = [];\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap[mainType][index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.series);\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap[mainType];\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap[mainType];\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts;\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap[mainType];\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q.hasOwnProperty(indexAttr)\n                        || q.hasOwnProperty(idAttr)\n                        || q.hasOwnProperty(nameAttr)\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                each(componentsMap, function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap[mainType], cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.series[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.series.slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.series, cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.series, cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.series);\n\n            var componentTypes = [];\n            each(componentsMap, function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap[componentType], function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap[type] || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (__DEV__) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Series has not been initialized yet.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n\n    module.exports = GlobalModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Global.js\n// module id = 123\n// module chunks = 0 1","/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // 如果没有reset功能则不clone。\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // performed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/OptionManager.js\n// module id = 124\n// module chunks = 0 1","\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // 全图默认背景\n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // 浅色\n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // 深色\n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        // 默认需要 Grid 配置项\n        // grid: {},\n        // 主题，主题\n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: true,\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n        // which is unexpected.\n        // see example <echarts/test/heatmap-large.html>.\n        hoverLayerThreshold: 3000\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/globalDefault.js\n// module id = 125\n// module chunks = 0 1","\n    module.exports = {\n        getAreaStyle: require('./makeStyleMapper')(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/areaStyle.js\n// module id = 126\n// module chunks = 0 1","\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/boxLayout.js\n// module id = 127\n// module chunks = 0 1","\n    var getItemStyle = require('./makeStyleMapper')(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes) {\n            var style = getItemStyle.call(this, excludes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/itemStyle.js\n// module id = 128\n// module chunks = 0 1","\n    var getLineStyle = require('./makeStyleMapper')(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/lineStyle.js\n// module id = 129\n// module chunks = 0 1","\n\n    var textContain = require('zrender/lib/contain/text');\n\n    function getShallow(model, path) {\n        return model && model.getShallow(path);\n    }\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @return {string}\n         */\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (ecModel && ecModel.get('textStyle.color'));\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            var ecModel = this.ecModel;\n            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n            return [\n                // FIXME in node-canvas fontWeight is before fontStyle\n                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n            ].join(' ');\n        },\n\n        getTextRect: function (text) {\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                this.getShallow('align'),\n                this.getShallow('baseline')\n            );\n        },\n\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(\n                text, containerWidth, this.getFont(), ellipsis, options\n            );\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/textStyle.js\n// module id = 130\n// module chunks = 0 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../util/format');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var colorPaletteMixin = require('./mixin/colorPalette');\n    var env = require('zrender/lib/core/env');\n    var layout = require('../util/layout');\n\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n\n            // If we reverse the order (make this._data firstly, and then make\n            // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause this._data.graph.data !== this._data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this._data = this._dataBeforeProcessed.cloneShallow();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `position` and `show`\n            // FIXME Set label in mergeOption\n            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\n            this.fillDataTextStyle(option.data);\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n            }\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                this._data = data;\n                this._dataBeforeProcessed = data.cloneShallow();\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `position` and `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            return dataType == null ? this._data : this._data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            this._data = data;\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return this._dataBeforeProcessed;\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return [coordDim];\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return dataDim;\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var result = [];\n\n                zrUtil.each(value, function (val, idx) {\n                    var dimInfo = data.getDimensionInfo(idx);\n                    var dimType = dimInfo && dimInfo.type;\n                    var valStr;\n\n                    if (dimType === 'ordinal') {\n                        valStr = val + '';\n                    }\n                    else if (dimType === 'time') {\n                        valStr = multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val);\n                    }\n                    else {\n                        valStr = addCommas(val);\n                    }\n\n                    valStr && result.push(valStr);\n                });\n\n                return result.join(', ');\n            }\n\n            var data = this._data;\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = zrUtil.isArray(value)\n                ? formatArrayValue(value) : addCommas(value);\n            var name = data.getName(dataIndex);\n\n            var color = data.getItemVisual(dataIndex, 'color');\n            if (zrUtil.isObject(color) && color.colorStops) {\n                color = (color.colorStops[0] || {}).color;\n            }\n            color = color || 'transparent';\n\n            var colorEl = '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            return !multipleSeries\n                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl\n                    + (name\n                        ? encodeHTML(name) + ' : ' + formattedValue\n                        : formattedValue)\n                  )\n                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);\n        },\n\n        /**\n         * @return {boolean}\n         */\n        ifEnableAnimation: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            this._data = this._dataBeforeProcessed.cloneShallow();\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Array.<number>} data indices.\n         */\n        getAxisTooltipDataIndex: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/series.js\n// module id = 131\n// module chunks = 0 1","// Compatitable with 2.0\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var compatStyle = require('./helper/compatStyle');\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            compatStyle(seriesOpt);\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/preprocessor/backwardCompat.js\n// module id = 132\n// module chunks = 0 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n\n    module.exports = function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    }\n                    else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/preprocessor/helper/compatStyle.js\n// module id = 133\n// module chunks = 0 1","'use strict';\n// Symbol factory\n\n\n    var graphic = require('./graphic');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/symbol.js\n// module id = 135\n// module chunks = 0 1","\n\n    var lib = {};\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n\n    /**\n     * @public\n     * @param {(Function)} fn\n     * @param {number} [delay=0] Unit: ms.\n     * @param {boolean} [debounce=false]\n     *        true: If call interval less than `delay`, only the last call works.\n     *        false: If call interval less than `delay, call works on fixed rate.\n     * @return {(Function)} throttled fn.\n     */\n    lib.throttle = function (fn, delay, debounce) {\n\n        var currCall;\n        var lastCall = 0;\n        var lastExec = 0;\n        var timer = null;\n        var diff;\n        var scope;\n        var args;\n\n        delay = delay || 0;\n\n        function exec() {\n            lastExec = (new Date()).getTime();\n            timer = null;\n            fn.apply(scope, args || []);\n        }\n\n        var cb = function () {\n            currCall = (new Date()).getTime();\n            scope = this;\n            args = arguments;\n            diff = currCall - (debounce ? lastCall : lastExec) - delay;\n\n            clearTimeout(timer);\n\n            if (debounce) {\n                timer = setTimeout(exec, delay);\n            }\n            else {\n                if (diff >= 0) {\n                    exec();\n                }\n                else {\n                    timer = setTimeout(exec, -diff);\n                }\n            }\n\n            lastCall = currCall;\n        };\n\n        /**\n         * Clear throttle.\n         * @public\n         */\n        cb.clear = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n\n        return cb;\n    };\n\n    /**\n     * Create throttle method or update throttle rate.\n     *\n     * @example\n     * ComponentView.prototype.render = function () {\n     *     ...\n     *     throttle.createOrUpdate(\n     *         this,\n     *         '_dispatchAction',\n     *         this.model.get('throttle'),\n     *         'fixRate'\n     *     );\n     * };\n     * ComponentView.prototype.remove = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     * ComponentView.prototype.dispose = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     * @param {number} [rate]\n     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n     * @return {Function} throttled function.\n     */\n    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n        var fn = obj[fnAttr];\n\n        if (!fn) {\n            return;\n        }\n\n        var originFn = fn[ORIGIN_METHOD] || fn;\n        var lastThrottleType = fn[THROTTLE_TYPE];\n        var lastRate = fn[RATE];\n\n        if (lastRate !== rate || lastThrottleType !== throttleType) {\n            if (rate == null || !throttleType) {\n                return (obj[fnAttr] = originFn);\n            }\n\n            fn = obj[fnAttr] = lib.throttle(\n                originFn, rate, throttleType === 'debounce'\n            );\n            fn[ORIGIN_METHOD] = originFn;\n            fn[THROTTLE_TYPE] = throttleType;\n            fn[RATE] = rate;\n        }\n\n        return fn;\n    };\n\n    /**\n     * Clear throttle. Example see throttle.createOrUpdate.\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     */\n    lib.clear = function (obj, fnAttr) {\n        var fn = obj[fnAttr];\n        if (fn && fn[ORIGIN_METHOD]) {\n            obj[fnAttr] = fn[ORIGIN_METHOD];\n        }\n    };\n\n    module.exports = lib;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/throttle.js\n// module id = 136\n// module chunks = 0 1","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/view/Component.js\n// module id = 137\n// module chunks = 0 1","\n    var Gradient = require('zrender/lib/graphic/Gradient');\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/visual/seriesColor.js\n// module id = 138\n// module chunks = 0 1","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(280);\n\n\n/***/ },\n\n/***/ 53:\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"element-ui/lib/utils/vue-popper\");\n\n/***/ },\n\n/***/ 280:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _main = __webpack_require__(281);\n\n\tvar _main2 = _interopRequireDefault(_main);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/* istanbul ignore next */\n\t_main2.default.install = function (Vue) {\n\t  Vue.component(_main2.default.name, _main2.default);\n\t};\n\n\texports.default = _main2.default;\n\n/***/ },\n\n/***/ 281:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_exports__, __vue_options__\n\tvar __vue_styles__ = {}\n\n\t/* script */\n\t__vue_exports__ = __webpack_require__(282)\n\n\t/* template */\n\tvar __vue_template__ = __webpack_require__(283)\n\t__vue_options__ = __vue_exports__ = __vue_exports__ || {}\n\tif (\n\t  typeof __vue_exports__.default === \"object\" ||\n\t  typeof __vue_exports__.default === \"function\"\n\t) {\n\t__vue_options__ = __vue_exports__ = __vue_exports__.default\n\t}\n\tif (typeof __vue_options__ === \"function\") {\n\t  __vue_options__ = __vue_options__.options\n\t}\n\n\t__vue_options__.render = __vue_template__.render\n\t__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\n\tmodule.exports = __vue_exports__\n\n\n/***/ },\n\n/***/ 282:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _vuePopper = __webpack_require__(53);\n\n\tvar _vuePopper2 = _interopRequireDefault(_vuePopper);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = {\n\t  name: 'el-tooltip',\n\n\t  mixins: [_vuePopper2.default],\n\n\t  props: {\n\t    openDelay: {\n\t      type: Number,\n\t      default: 0\n\t    },\n\t    disabled: Boolean,\n\t    manual: Boolean,\n\t    effect: {\n\t      type: String,\n\t      default: 'dark'\n\t    },\n\t    content: String,\n\t    visibleArrow: {\n\t      default: true\n\t    },\n\t    transition: {\n\t      type: String,\n\t      default: 'fade-in-linear'\n\t    },\n\t    options: {\n\t      default: function _default() {\n\t        return {\n\t          boundariesPadding: 10,\n\t          gpuAcceleration: false\n\t        };\n\t      }\n\t    }\n\t  },\n\n\t  methods: {\n\t    handleShowPopper: function handleShowPopper() {\n\t      var _this = this;\n\n\t      if (this.manual) return;\n\t      this.timeout = setTimeout(function () {\n\t        _this.showPopper = true;\n\t      }, this.openDelay);\n\t    },\n\t    handleClosePopper: function handleClosePopper() {\n\t      if (this.manual) return;\n\t      clearTimeout(this.timeout);\n\t      this.showPopper = false;\n\t    }\n\t  }\n\t}; //\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\n/***/ },\n\n/***/ 283:\n/***/ function(module, exports) {\n\n\tmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._c;\n\t  return _h('div', {\n\t    staticClass: \"el-tooltip\",\n\t    on: {\n\t      \"mouseenter\": _vm.handleShowPopper,\n\t      \"mouseleave\": _vm.handleClosePopper\n\t    }\n\t  }, [_h('div', {\n\t    ref: \"reference\",\n\t    staticClass: \"el-tooltip__rel\"\n\t  }, [_vm._t(\"default\")]), _h('transition', {\n\t    attrs: {\n\t      \"name\": _vm.transition\n\t    },\n\t    on: {\n\t      \"after-leave\": _vm.doDestroy\n\t    }\n\t  }, [_h('div', {\n\t    directives: [{\n\t      name: \"show\",\n\t      rawName: \"v-show\",\n\t      value: (!_vm.disabled && _vm.showPopper),\n\t      expression: \"!disabled && showPopper\"\n\t    }],\n\t    ref: \"popper\",\n\t    staticClass: \"el-tooltip__popper\",\n\t    class: ['is-' + _vm.effect]\n\t  }, [_vm._t(\"content\", [_h('div', {\n\t    domProps: {\n\t      \"textContent\": _vm._s(_vm.content)\n\t    }\n\t  })])])])])\n\t},staticRenderFns: []}\n\n/***/ }\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/element-ui/lib/tooltip.js\n// module id = 144\n// module chunks = 0 1","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../css-loader/index.js?-autoprefixer&sourceMap!./../../../postcss-loader/index.js!./tooltip.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../css-loader/index.js?-autoprefixer&sourceMap!./../../../postcss-loader/index.js!./tooltip.css\", function() {\n\t\t\tvar newContent = require(\"!!./../../../css-loader/index.js?-autoprefixer&sourceMap!./../../../postcss-loader/index.js!./tooltip.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/element-ui/lib/theme-default/tooltip.css\n// module id = 148\n// module chunks = 0 1","'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n\n    var Eventful = require('./mixin/Eventful');\n\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n\n            this._hovered = hovered;\n\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = null;\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * 设置默认的cursor style\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * 事件分发代理\n         *\n         * @private\n         * @param {Object} targetEl 目标图形元素\n         * @param {string} eventName 事件名称\n         * @param {Object} event 事件对象\n         */\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\n            var el = targetEl;\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                // 冒泡到顶级 zrender 对象\n                this.trigger(eventName, eventPacket);\n                // 分发事件到用户自定义层\n                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                if (!list[i].silent\n                 && list[i] !== exclude\n                 // getDisplayList may include ignored item in VML mode\n                 && !list[i].ignore\n                 && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hovered;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Handler.js\n// module id = 156\n// module chunks = 0 1","/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * 创建dom\n     *\n     * @inner\n     * @param {string} id dom id 待用\n     * @param {string} type dom type，such as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // 没append呢，请原谅我这样写，清晰~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id不作为索引用，避免可能造成的重名，定义为私有属性\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * 每次清空画布的颜色\n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * 是否开启动态模糊\n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * 清空该层画布\n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Layer.js\n// module id = 157\n// module chunks = 0 1","'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n\n    var Layer = require('./Layer');\n\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.isBuildin) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var path = clipPath.path;\n\n            clipPath.setTransform(ctx);\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root 绘图容器\n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * 绘图容器\n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n        }\n\n        this.pathToImage = this._createPathToImage();\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n        },\n\n        /**\n         * 刷新\n         * @param {boolean} [paintAll=false] 强制绘制所有displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.isBuildin && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuildinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuildinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.isBuildin) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.isBuildin = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(\n                        layer.dom,\n                        prevDom.nextSibling\n                    );\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n\n            layersMap[zlevel] = layer;\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuildinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (! layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * 获取所有已创建的层\n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuildinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // 层中的元素数量有发生变化\n            this.eachBuildinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * 清除hover层外所有内容\n         */\n        clear: function () {\n            this.eachBuildinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * 修改指定zlevel的绘制参数\n         *\n         * @param {string} zlevel\n         * @param {Object} config 配置对象\n         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * 删除指定层\n         * @param {number} zlevel 层所在的zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * 区域大小变化后重绘\n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // 优化没有实际改变的resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * 清除单独的一个层\n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * 释放\n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            return imageLayer.dom;\n        },\n        /**\n         * 获取绘图区域宽度\n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * 获取绘图区域高度\n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        _pathToImage: function (id, path, width, height, dpr) {\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [0, 0, 0];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                id: id,\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        },\n\n        _createPathToImage: function () {\n            var me = this;\n\n            return function (id, e, width, height) {\n                return me._pathToImage(\n                    id, e, width, height, me.dpr\n                );\n            };\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Painter.js\n// module id = 158\n// module chunks = 0 1","'use strict';\n/**\n * Storage内容仓库模块\n * @module zrender/Storage\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = require('./core/util');\n    var env = require('./core/env');\n\n    var Group = require('./container/Group');\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     * 内容仓库 (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // 所有常规形状，id索引的map\n        this._elements = {};\n\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * 返回所有图形的绘制队列\n         * @param {boolean} [update=false] 是否在返回前更新该数组\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n         *\n         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * 更新图形的绘制队列。\n         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var clipPath = el.clipPath;\n            if (clipPath) {\n                // clipPath 的变换是基于 group 的变换\n                clipPath.parent = el;\n                clipPath.updateTransform();\n\n                // FIXME 效率影响\n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                    clipPaths.push(clipPath);\n                }\n                else {\n                    clipPaths = [clipPath];\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * 添加图形(Shape)或者组(Group)到根节点\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * 删除指定的图形(Shape)或者组(Group)\n         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage\n         */\n        delRoot: function (elId) {\n            if (elId == null) {\n                // 不指定elId清空\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n\n            var el;\n            if (typeof(elId) == 'string') {\n                el = this._elements[elId];\n            }\n            else {\n                el = elId;\n            }\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty(false);\n\n            this._elements[el.id] = el;\n\n            return this;\n        },\n\n        get: function (elId) {\n            return this._elements[elId];\n        },\n\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * 清空并且释放Storage\n         */\n        dispose: function () {\n            this._elements =\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Storage.js\n// module id = 159\n// module chunks = 0 1","'use strict';\n/**\n * 动画主类, 调度和管理所有动画控制器\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n\n    var requestAnimationFrame = require('./requestAnimationFrame');\n\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         * 添加 clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         * 添加 animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * 开始运行动画\n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * 停止运行动画\n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * 清除所有动画片段\n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] 是否循环播放动画\n         * @param  {Function} [options.getter=null]\n         *         如果指定getter函数，会通过getter函数取属性值\n         * @param  {Function} [options.setter=null]\n         *         如果指定setter函数，会通过setter函数设置属性值\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animation.js\n// module id = 160\n// module chunks = 0 1","/**\n * 动画主控制器\n * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n * @config life(1000) 动画时长\n * @config delay(0) 动画延迟时间\n * @config loop(true)\n * @config gap(0) 循环的间隔时间\n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // 生命周期\n        this._life = options.life || 1000;\n        // 延时\n        this._delay = options.delay || 0;\n        // 开始时间\n        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n        this._initialized = false;\n\n        // 是否循环\n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            var percent = (globalTime - this._startTime) / this._life;\n\n            // 还没开始\n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // 结束\n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // 重新开始周期\n                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n                    return 'restart';\n                }\n\n                // 动画完成将这个控制器标识为待删除\n                // 在Animation.update中进行批量删除\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n\n            this._needsRemove = false;\n        },\n\n        fire: function(eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Clip.js\n// module id = 161\n// module chunks = 0 1","/**\n * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // 三次方的缓动（t^3）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // 四次方的缓动（t^4）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // 五次方的缓动（t^5）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // 正弦曲线的缓动（sin(t)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 指数曲线的缓动（2^t）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // 圆形曲线的缓动（sqrt(1-t^2)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // 创建类似于弹簧在停止前来回振荡的动画\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // 创建弹跳效果\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/easing.js\n// module id = 162\n// module chunks = 0 1","\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * 圆弧描边包含判断\n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/arc.js\n// module id = 163\n// module chunks = 0 1","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * 三次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/cubic.js\n// module id = 164\n// module chunks = 0 1","\n    module.exports = {\n        /**\n         * 线段包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/line.js\n// module id = 165\n// module chunks = 0 1","'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // 临时数组\n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // 分成三段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // 分成两段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc 旋转\n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                // 如果被任何一个 subpath 包含\n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                // 如果第一个命令是 L, C, Q\n                // 则 previous point 同绘制命令的第一个 point\n                //\n                // 第一个命令为 Arc 的情况下会在后面特殊处理\n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                    // 在 closePath 的时候使用\n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc 判断的开销比较大\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc 旋转\n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    // 不是直接使用 arc 命令\n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // 第一个命令起点还未定义\n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        // 如果被任何一个 subpath 包含\n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/path.js\n// module id = 166\n// module chunks = 0 1","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * 二次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/quadratic.js\n// module id = 167\n// module chunks = 0 1","\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/windingLine.js\n// module id = 168\n// module chunks = 0 1","'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = require('./event');\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/GestureMgr.js\n// module id = 169\n// module chunks = 0 1","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function() {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function(val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function(entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function(entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function() {\n        return this._len;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function(val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function(maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     */\n    LRUProto.put = function(key, value) {\n        var list = this._list;\n        var map = this._map;\n        if (map[key] == null) {\n            var len = list.len();\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n            }\n\n            var entry = list.insert(value);\n            entry.key = key;\n            map[key] = entry;\n        }\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function(key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function() {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/LRU.js\n// module id = 170\n// module chunks = 0 1","/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points 顶点数组\n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/bbox.js\n// module id = 171\n// module chunks = 0 1","\n\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null),\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        if (gestureInfo) {\n            // eventTool.stop(event);\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n    function useTouchEvent() {\n        return env.touchEventsSupported;\n    }\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // 忽略包含在root中的dom引起的mouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch开始响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch移动响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch结束响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        }\n    };\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * 为控制类实例初始化dom 事件处理函数\n     *\n     * @inner\n     * @param {module:zrender/Handler} instance 控制类实例\n     */\n    function initDomHandler(instance) {\n        for (var i = 0; i < touchHandlerNames.length; i++) {\n            var name = touchHandlerNames[i];\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        }\n\n        for (var i = 0; i < mouseHandlerNames.length; i++) {\n            var name = mouseHandlerNames[i];\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        }\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (useTouchEvent()) {\n            mountHandlers(touchHandlerNames, this);\n\n            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n            // addEventListener(root, 'mouseout', this._mouseoutHandler);\n        }\n\n        // Considering some devices that both enable touch and mouse event (like MS Surface\n        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n        // mouse event can not be handle in those devices.\n        mountHandlers(mouseHandlerNames, this);\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/dom/HandlerProxy.js\n// module id = 172\n// module chunks = 0 1","// CompoundPath to improve performance\n\n\n    var Path = require('./Path');\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/CompoundPath.js\n// module id = 173\n// module chunks = 0 1","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/LinearGradient.js\n// module id = 174\n// module chunks = 0 1","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/RadialGradient.js\n// module id = 175\n// module chunks = 0 1","/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('国', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            if (!this._rect) {\n                var style = this.style;\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                this._rect = rect;\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Text.js\n// module id = 176\n// module chunks = 0 1","\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/roundRect.js\n// module id = 177\n// module chunks = 0 1","/**\n * 贝塞尔平滑曲线\n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * 贝塞尔平滑曲线\n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points 线段顶点数组\n     * @param {number} smooth 平滑等级, 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n     *                           整个折线的包围盒做一个并集用来约束控制点。\n     * @param {Array} 计算出来的控制点数组\n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // 与指定的包围盒做并集\n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothBezier.js\n// module id = 178\n// module chunks = 0 1","/**\n * Catmull-Rom spline 插值折线\n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points 线段顶点数组\n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothSpline.js\n// module id = 179\n// module chunks = 0 1","/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                textFill && ctx.fillText(textLines[i], x, y);\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/mixin/RectText.js\n// module id = 180\n// module chunks = 0 1","/**\n * 圆弧\n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = require('../Path').extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Arc.js\n// module id = 181\n// module chunks = 0 1","'use strict';\n/**\n * 贝塞尔曲线\n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = require('../Path').extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/BezierCurve.js\n// module id = 182\n// module chunks = 0 1","'use strict';\n/**\n * 圆形\n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Circle.js\n// module id = 183\n// module chunks = 0 1","/**\n * 直线\n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = require('../Path').extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Line.js\n// module id = 184\n// module chunks = 0 1","/**\n * 多边形\n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polygon.js\n// module id = 185\n// module chunks = 0 1","/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polyline.js\n// module id = 186\n// module chunks = 0 1","/**\n * 矩形\n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = require('../helper/roundRect');\n\n    module.exports = require('../Path').extend({\n\n        type: 'rect',\n\n        shape: {\n            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n            // r缩写为1         相当于 [1, 1, 1, 1]\n            // r缩写为[1]       相当于 [1, 1, 1, 1]\n            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Rect.js\n// module id = 187\n// module chunks = 0 1","/**\n * 圆环\n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Ring.js\n// module id = 188\n// module chunks = 0 1","/**\n * 扇形\n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Sector.js\n// module id = 189\n// module chunks = 0 1","'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * 动画\n         *\n         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\n         * @param {boolean} [loop] 动画是否循环\n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Animatable.js\n// module id = 190\n// module chunks = 0 1","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    module.exports = Draggable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Draggable.js\n// module id = 191\n// module chunks = 0 1","'use strict';\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * 平移\n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * 旋转\n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * 缩放\n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * 旋转和缩放的原点\n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * 判断是否需要有坐标变换\n     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // 应用父节点变换\n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // 保存这个变换矩阵\n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = this.origin;\n\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n    /**\n     * 将自己的transform应用到context上\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n\n    var tmpTransform = [];\n\n    /**\n     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     * 变换坐标位置到 shape 的局部坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * 变换局部坐标位置到全局坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    module.exports = Transformable;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Transformable.js\n// module id = 192\n// module chunks = 0 1","\n\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n    var matrix = require('../core/matrix');\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/path.js\n// module id = 193\n// module chunks = 0 1","\n\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i++] += x;\n                    // cy\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/transformPath.js\n// module id = 194\n// module chunks = 0 1","/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var zrUtil = require('./core/util');\n\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: require('./Painter')\n    };\n\n    var instances = {};    // ZRender实例map索引\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.2.2';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        // 修改 storage.delFromMap, 每次删除元素之前删除动画\n        // FIXME 有点ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * 获取实例唯一标识\n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * 添加元素\n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * 删除元素\n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, width, height) {\n            var id = guid();\n            return this.painter.pathToImage(id, e, width, height);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/zrender.js\n// module id = 195\n// module chunks = 0 1","<template lang=\"pug\">\n  .pie-echarts(ref='echart')\n</template>\n\n<script>\nimport _ from 'lodash'\nimport Vue from 'vue'\nimport echart from 'echarts/lib/echarts'\nrequire('echarts/lib/chart/pie')\nrequire('echarts/lib/model/series')\nrequire('echarts/lib/component/tooltip')\nrequire('echarts/lib/component/legend')\n\nexport default {\n  props: ['chartOption'],\n  data() {\n    return {\n      chart: null\n    }\n  },\n\n  mounted() {\n    this.chart = echart.init(this.$refs.echart)\n    let option = {\n      tooltip: {\n        show: true,\n        trigger: 'item',\n        formatter: (params, ticket, callback) => {\n          return '<div style=\"text-align:center; font-size:14px;\">' + params.name + '<br/>' + Vue.filter('ktCurrency')(params.value) + '(' + params.percent + '%)' + '</div>'\n        }\n      },\n      color: ['#21a9e1', '#35cbef', '#1fdab1', '#92e68d'],\n      legend: {\n        orient: 'vertical',\n        x: '20px',\n        left: '0px',\n        top: 'center',\n        // data: this.chartOption.legendData,\n        data: [],\n        textStyle: {\n          fontSize: 14, //示例文字size\n          color: '#262c38' //示例文字颜色\n        },\n        itemWidth: 16,\n        itemHeight: 16,\n        itemGap: 20\n      },\n      series: [{\n        name: '',\n        type: 'pie',\n        center: ['70%', '50%'],\n        radius: ['50%', '80%'],\n        avoidLabelOverlap: false,\n        label: {\n          normal: {\n            show: false,\n            position: 'center'\n          },\n          emphasis: {\n            show: true,\n            textStyle: {\n              fontSize: '25',\n              fontWeight: 'bold'\n            }\n          }\n        },\n        labelLine: {\n          normal: {\n            show: false\n          }\n        },\n        data: []\n      }]\n    }\n\n    this.chart.setOption(_.merge({}, option, this.chartOption))\n  },\n\n  watch: {\n    chartOption() {\n      this.chart.setOption(this.chartOption)\n    }\n  }\n}\n</script>\n\n<style type=\"scss\">\n  .pie-echarts{ min-width:400px; width:400px; height:237px; margin:0 auto; }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// kt-pie-echart.vue?d02f7198","<template lang=\"pug\">\n  .overview\n    .today-overview\n      h2 今日总览\n      .overview-left.fl\n        h3 当前存续金额（元）\n        .overview-left-middle\n          i(class=\"icon-icomoon icon-overview\")\n          span {{balance.total | ktCurrency('')}}\n        .overview-left-down\n          .Principal.fl\n            span 存续本金\n              em {{balance.principal | ktCurrency('')}}\n          .Interest.fr\n            span 存续利息\n              em {{balance.interest | ktCurrency('')}}\n      .overview-right.fr\n        h3 今日存量产品占比分析\n        .overview-right-middle\n          kt-pie-echart(:chart-option=\"pieChartOption\")\n\n    .today-square\n      h2 今日清算\n        el-tooltip(effect=\"dark\",placement=\"right\")\n          .Prompt(slot=\"content\") 展示今日需资金清算的所有产品，包括今日流入资金的入账确认以及今日流出资金的划款确认 <br> 待执行-清算数据正常可以进行清算执行操作确认 <br> 不可执行-清算数据尚未更新或者异常导致无法执行清算确认 <br> 已执行-已经进行过清算执行操作确认 <br> 已过期-当前时间已经晚于需确认清算执行的最晚时限\n          i(class=\"icon-icomoon icon-explain\")\n        .information.fr\n          span {{summary.executed}}\n          em 条 已执行，\n          span {{summary.pending_execute}}\n          em 条 待执行，\n          span {{summary.cant_execute}}\n          em 条 不可执行，\n          span {{summary.expired}}\n          em 条 已过期\n      .overview-table\n        table(v-for=\"(item,key) in virtualAssets\")\n          thead\n            tr\n              th {{key}}\n          tbody(v-for=\"product in item\")\n            tr(@click=\"toDetails(product)\")\n              td\n                span {{product.name}}\n              td\n                span(v-if=\"product.inflow_desc\") {{product.inflow_desc}}\n                  em.red-color {{product.inflow | ktCurrency}}\n              td\n                span(v-if=\"product.outflow_desc\") {{product.outflow_desc}}\n                  em.green-color {{product.outflow | ktCurrency}}\n              td\n                span {{product.inflow >= product.outflow ? '净流入' : '净流出'}}\n                  em(:class=\"[product.inflow >= product.outflow ? 'red-color' : 'green-color']\") {{product.net_cash_flow  | ktCurrency}}\n              td\n                span.bg-color {{product.execute_method}}\n              td.implement.status-column\n                i.icon-icomoon(:class=\"product.execute_status | excuteStatusIcon\")\n                em.em-implement {{product.execute_status}}\n              td\n                span(v-show=\"product.execute_status === '待执行' ? true : false\") 结算时限:\n                  em {{product.due_at}}\n</template>\n\n<script>\nimport _ from 'lodash'\nimport {\n  subsist,\n  stock,\n  liquidation\n} from '../../common/resources.js'\nimport KtPieEchart from '../../components/kt-pie-echart.vue'\nimport {\n  Tooltip,\n  Loading\n} from 'element-ui'\nimport exMixin from './mixin.js'\nexport default {\n  mixins: [exMixin],\n  components: {\n    KtPieEchart,\n    ElTooltip: Tooltip\n  },\n\n  methods: {\n\n    // 查看单个产品详情总览\n    toDetails(product) {\n      this.$router.push({\n        name: 'productDashboard',\n        params: {\n          id: product.id,\n          name: product.name\n        }\n      })\n    },\n\n    // 当前存续金额（元）\n    subsistGet() {\n      return subsist.get().then(res => res.json()).then(data => {\n        this.balance = data.balance\n      })\n    },\n\n    // 今日存量产品占比分析\n    stockGet() {\n      return stock.get().then(res => res.json()).then(data => {\n        this.pieChartOption = _.merge({}, this.pieChartOption, {\n          legend: {\n            data: _.map(data.balance.by_consignee, 'consignee')\n          },\n          series: [{\n            name: '',\n            type: 'pie',\n            center: ['70%', '50%'],\n            radius: ['50%', '80%'],\n            avoidLabelOverlap: false,\n            label: {\n              normal: {\n                show: false,\n                position: 'center'\n              },\n              emphasis: {\n                show: true,\n                textStyle: {\n                  fontSize: '25',\n                  fontWeight: 'bold'\n                }\n              }\n            },\n            labelLine: {\n              normal: {\n                show: false\n              }\n            },\n            data: _.map(data.balance.by_consignee, v => {\n              return {\n                name: v.consignee,\n                value: v.balance\n              }\n            })\n          }]\n        })\n      })\n    },\n\n    // 今日清算\n    liquidationGet() {\n      return liquidation.get().then(res => res.json()).then(data => {\n        this.summary = data.summary\n        this.virtualAssets = _.groupBy(data.virtual_assets, v => v.consignee)\n      })\n    }\n  },\n\n  mounted() {\n    this.instLoading = Loading.service({\n      target: '.overview'\n    })\n\n    Promise.all([\n      this.subsistGet(),\n      this.stockGet(),\n      this.liquidationGet()\n    ]).then(() => {\n      this.instLoading.close()\n    }).catch(res => {\n      this.instLoading.close()\n    })\n  },\n\n  data() {\n    return {\n      balance: '',\n      pieChartOption: {},\n      summary: '',\n      virtualAssets: ''\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scope>\n.fl {\n  float: left;\n}\n\n.fr {\n  float: right;\n}\n\n.overview {\n  background: #ecf1f7;\n  h2 {\n    margin-bottom: 10px;\n    font-size: 17px;\n  }\n}\n\n.today-overview {\n  overflow: hidden;\n  .overview-left,\n  .overview-right {\n    border-radius: 4px;\n    background: #fff;\n    padding: 10px;\n    width: 49.5%;\n  }\n  .overview-left {\n    h3 {\n      background: #ecf1f7;\n      height: 40px;\n      line-height: 40px;\n      font-size: 14px;\n      text-indent: 10px;\n      border-radius: 4px;\n    }\n    .overview-left-middle {\n      height: 164px;\n      line-height: 164px;\n      text-align: center;\n      border-bottom: 1px solid #ecf1f7;\n      i {\n        font-size: 57px;\n        color: #eef1f3;\n        display: inline-block;\n        vertical-align: middle;\n      }\n      span {\n        position: relative;\n        font-size: 35px;\n        color: #66cebe;\n        margin-left: 35px;\n        margin-top: 3px;\n        vertical-align: middle;\n        &:before {\n          content: \"￥\";\n          font-size: 30px;\n          color: #c4c4c4;\n          margin-right: 10px;\n          margin-top: 5px;\n        }\n      }\n    }\n    .overview-left-down {\n      height: 72px;\n      line-height: 72px;\n      overflow: hidden;\n      padding: 0 10px;\n      .Principal {\n        span {\n          font-size: 14px;\n        }\n        em {\n          font-style: normal;\n          color: #66cebe;\n          margin-left: 8px;\n          &:before {\n            content: \"￥\";\n            font-size: 13px;\n            color: #c4c4c4;\n            margin-right: 7px;\n          }\n        }\n      }\n      .Interest {\n        span {\n          font-size: 14px;\n        }\n        em {\n          font-style: normal;\n          color: #66cebe;\n          margin-left: 8px;\n          &:before {\n            content: \"￥\";\n            font-size: 13px;\n            color: #c4c4c4;\n            margin-right: 7px;\n          }\n        }\n      }\n    }\n  }\n  .overview-right {\n    h3 {\n      background: #ecf1f7;\n      height: 40px;\n      line-height: 40px;\n      font-size: 14px;\n      text-indent: 10px;\n      border-radius: 4px;\n    }\n    .overview-right-middle {\n      height: 237px;\n    }\n  }\n}\n\n.today-square {\n  margin-top: 25px;\n  h2 {\n    i {\n      font-size: 15px;\n      color: #b4becf;\n      margin-left: 5px;\n    }\n    .information {\n      font-size: 13px;\n      span {\n        color: #54c9b8;\n      }\n      em {\n        font-style: normal;\n      }\n    }\n  }\n}\n\n.overview-table {\n  max-height: 500px;\n  overflow-y: scroll;\n}\n</style>\n\n\n\n// WEBPACK FOOTER //\n// dashboard.vue?1254d816","exports = module.exports = require(\"./../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".fl{float:left}.fr{float:right}.overview{background:#ecf1f7}.overview h2{margin-bottom:10px;font-size:17px}.today-overview{overflow:hidden}.today-overview .overview-left,.today-overview .overview-right{border-radius:4px;background:#fff;padding:10px;width:49.5%}.today-overview .overview-left h3{background:#ecf1f7;height:40px;line-height:40px;font-size:14px;text-indent:10px;border-radius:4px}.today-overview .overview-left .overview-left-middle{height:164px;line-height:164px;text-align:center;border-bottom:1px solid #ecf1f7}.today-overview .overview-left .overview-left-middle i{font-size:57px;color:#eef1f3;display:inline-block;vertical-align:middle}.today-overview .overview-left .overview-left-middle span{position:relative;font-size:35px;color:#66cebe;margin-left:35px;margin-top:3px;vertical-align:middle}.today-overview .overview-left .overview-left-middle span:before{content:\\\"\\\\FFE5\\\";font-size:30px;color:#c4c4c4;margin-right:10px;margin-top:5px}.today-overview .overview-left .overview-left-down{height:72px;line-height:72px;overflow:hidden;padding:0 10px}.today-overview .overview-left .overview-left-down .Principal span{font-size:14px}.today-overview .overview-left .overview-left-down .Principal em{font-style:normal;color:#66cebe;margin-left:8px}.today-overview .overview-left .overview-left-down .Principal em:before{content:\\\"\\\\FFE5\\\";font-size:13px;color:#c4c4c4;margin-right:7px}.today-overview .overview-left .overview-left-down .Interest span{font-size:14px}.today-overview .overview-left .overview-left-down .Interest em{font-style:normal;color:#66cebe;margin-left:8px}.today-overview .overview-left .overview-left-down .Interest em:before{content:\\\"\\\\FFE5\\\";font-size:13px;color:#c4c4c4;margin-right:7px}.today-overview .overview-right h3{background:#ecf1f7;height:40px;line-height:40px;font-size:14px;text-indent:10px;border-radius:4px}.today-overview .overview-right .overview-right-middle{height:237px}.today-square{margin-top:25px}.today-square h2 i{font-size:15px;color:#b4becf;margin-left:5px}.today-square h2 .information{font-size:13px}.today-square h2 .information span{color:#54c9b8}.today-square h2 .information em{font-style:normal}.overview-table{max-height:500px;overflow-y:scroll}\", \"\", {\"version\":3,\"sources\":[\"/./src/views/ex/dashboard.vue\"],\"names\":[],\"mappings\":\"AACA,IAAI,UAAU,CACb,AACD,IAAI,WAAW,CACd,AACD,UAAU,kBAAkB,CAC3B,AACD,aAAa,mBAAmB,cAAc,CAC7C,AACD,gBAAgB,eAAe,CAC9B,AACD,+DAA+D,kBAAkB,gBAAgB,aAAa,WAAW,CACxH,AACD,kCAAkC,mBAAmB,YAAY,iBAAiB,eAAe,iBAAiB,iBAAiB,CAClI,AACD,qDAAqD,aAAa,kBAAkB,kBAAkB,+BAA+B,CACpI,AACD,uDAAuD,eAAe,cAAc,qBAAqB,qBAAqB,CAC7H,AACD,0DAA0D,kBAAkB,eAAe,cAAc,iBAAiB,eAAe,qBAAqB,CAC7J,AACD,iEAAiE,gBAAY,eAAe,cAAc,kBAAkB,cAAc,CACzI,AACD,mDAAmD,YAAY,iBAAiB,gBAAgB,cAAc,CAC7G,AACD,mEAAmE,cAAc,CAChF,AACD,iEAAiE,kBAAkB,cAAc,eAAe,CAC/G,AACD,wEAAwE,gBAAY,eAAe,cAAc,gBAAgB,CAChI,AACD,kEAAkE,cAAc,CAC/E,AACD,gEAAgE,kBAAkB,cAAc,eAAe,CAC9G,AACD,uEAAuE,gBAAY,eAAe,cAAc,gBAAgB,CAC/H,AACD,mCAAmC,mBAAmB,YAAY,iBAAiB,eAAe,iBAAiB,iBAAiB,CACnI,AACD,uDAAuD,YAAY,CAClE,AACD,cAAc,eAAe,CAC5B,AACD,mBAAmB,eAAe,cAAc,eAAe,CAC9D,AACD,8BAA8B,cAAc,CAC3C,AACD,mCAAmC,aAAa,CAC/C,AACD,iCAAiC,iBAAiB,CACjD,AACD,gBAAgB,iBAAiB,iBAAiB,CACjD\",\"file\":\"dashboard.vue\",\"sourcesContent\":[\"\\n.fl{float:left\\n}\\n.fr{float:right\\n}\\n.overview{background:#ecf1f7\\n}\\n.overview h2{margin-bottom:10px;font-size:17px\\n}\\n.today-overview{overflow:hidden\\n}\\n.today-overview .overview-left,.today-overview .overview-right{border-radius:4px;background:#fff;padding:10px;width:49.5%\\n}\\n.today-overview .overview-left h3{background:#ecf1f7;height:40px;line-height:40px;font-size:14px;text-indent:10px;border-radius:4px\\n}\\n.today-overview .overview-left .overview-left-middle{height:164px;line-height:164px;text-align:center;border-bottom:1px solid #ecf1f7\\n}\\n.today-overview .overview-left .overview-left-middle i{font-size:57px;color:#eef1f3;display:inline-block;vertical-align:middle\\n}\\n.today-overview .overview-left .overview-left-middle span{position:relative;font-size:35px;color:#66cebe;margin-left:35px;margin-top:3px;vertical-align:middle\\n}\\n.today-overview .overview-left .overview-left-middle span:before{content:\\\"￥\\\";font-size:30px;color:#c4c4c4;margin-right:10px;margin-top:5px\\n}\\n.today-overview .overview-left .overview-left-down{height:72px;line-height:72px;overflow:hidden;padding:0 10px\\n}\\n.today-overview .overview-left .overview-left-down .Principal span{font-size:14px\\n}\\n.today-overview .overview-left .overview-left-down .Principal em{font-style:normal;color:#66cebe;margin-left:8px\\n}\\n.today-overview .overview-left .overview-left-down .Principal em:before{content:\\\"￥\\\";font-size:13px;color:#c4c4c4;margin-right:7px\\n}\\n.today-overview .overview-left .overview-left-down .Interest span{font-size:14px\\n}\\n.today-overview .overview-left .overview-left-down .Interest em{font-style:normal;color:#66cebe;margin-left:8px\\n}\\n.today-overview .overview-left .overview-left-down .Interest em:before{content:\\\"￥\\\";font-size:13px;color:#c4c4c4;margin-right:7px\\n}\\n.today-overview .overview-right h3{background:#ecf1f7;height:40px;line-height:40px;font-size:14px;text-indent:10px;border-radius:4px\\n}\\n.today-overview .overview-right .overview-right-middle{height:237px\\n}\\n.today-square{margin-top:25px\\n}\\n.today-square h2 i{font-size:15px;color:#b4becf;margin-left:5px\\n}\\n.today-square h2 .information{font-size:13px\\n}\\n.today-square h2 .information span{color:#54c9b8\\n}\\n.today-square h2 .information em{font-style:normal\\n}\\n.overview-table{max-height:500px;overflow-y:scroll\\n}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?-autoprefixer&sourceMap!./~/vue-loader/lib/style-rewriter.js?id=data-v-1d47d409!./~/sass-loader?sourceMap!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/views/ex/dashboard.vue\n// module id = 410\n// module chunks = 1","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".pie-echarts{min-width:400px;width:400px;height:237px;margin:0 auto}\", \"\", {\"version\":3,\"sources\":[\"/./src/components/kt-pie-echart.vue\"],\"names\":[],\"mappings\":\"AACA,aAAc,gBAAgB,AAAC,YAAY,AAAC,aAAa,AAAC,aAAc,CACvE\",\"file\":\"kt-pie-echart.vue\",\"sourcesContent\":[\"\\n.pie-echarts{ min-width:400px; width:400px; height:237px; margin:0 auto;\\n}\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?-autoprefixer&sourceMap!./~/vue-loader/lib/style-rewriter.js?id=data-v-901a6116!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/kt-pie-echart.vue\n// module id = 416\n// module chunks = 1","\n    var echarts = require('../echarts');\n    var zrUtil = require('zrender/lib/core/util');\n    module.exports = function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent(\n                    {mainType: 'series', subType: seriesType, query: payload},\n                    function (seriesModel) {\n                        if (seriesModel[actionInfo.method]) {\n                            seriesModel[actionInfo.method](payload.name);\n                        }\n                        var data = seriesModel.getData();\n                        // Create selected map\n                        data.each(function (idx) {\n                            var name = data.getName(idx);\n                            selected[name] = seriesModel.isSelected(name) || false;\n                        });\n                    }\n                );\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/action/createDataSelectAction.js\n// module id = 420\n// module chunks = 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('./pie/PieSeries');\n    require('./pie/PieView');\n\n    require('../action/createDataSelectAction')('pie', [{\n        type: 'pieToggleSelect',\n        event: 'pieselectchanged',\n        method: 'toggleSelected'\n    }, {\n        type: 'pieSelect',\n        event: 'pieselected',\n        method: 'select'\n    }, {\n        type: 'pieUnSelect',\n        event: 'pieunselected',\n        method: 'unSelect'\n    }]);\n\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n\n    echarts.registerLayout(zrUtil.curry(\n        require('./pie/pieLayout'), 'pie'\n    ));\n\n    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie.js\n// module id = 426\n// module chunks = 1","'use strict';\n\n\n    var List = require('../../data/List');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n\n    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n\n    var PieSeries = require('../../echarts').extendSeriesModel({\n\n        type: 'series.pie',\n\n        // Overwrite\n        init: function (option) {\n            PieSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this._dataBeforeProcessed;\n            };\n\n            this.updateSelectedMap(option.data);\n\n            this._defaultLabelLine(option);\n        },\n\n        // Overwrite\n        mergeOption: function (newOption) {\n            PieSeries.superCall(this, 'mergeOption', newOption);\n            this.updateSelectedMap(this.option.data);\n        },\n\n        getInitialData: function (option, ecModel) {\n            var dimensions = completeDimensions(['value'], option.data);\n            var list = new List(dimensions, this);\n            list.initData(option.data);\n            return list;\n        },\n\n        // Overwrite\n        getDataParams: function (dataIndex) {\n            var data = this._data;\n            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n            var sum = data.getSum('value');\n            // FIXME toFixed?\n            //\n            // Percent is 0 if sum is 0\n            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\n            params.$vars.push('percent');\n            return params;\n        },\n\n        _defaultLabelLine: function (option) {\n            // Extend labelLine emphasis\n            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\n            var labelLineNormalOpt = option.labelLine.normal;\n            var labelLineEmphasisOpt = option.labelLine.emphasis;\n            // Not show label line if `label.normal.show = false`\n            labelLineNormalOpt.show = labelLineNormalOpt.show\n                && option.label.normal.show;\n            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n                && option.label.emphasis.show;\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // 默认全局居中\n            center: ['50%', '50%'],\n            radius: [0, '75%'],\n            // 默认顺时针\n            clockwise: true,\n            startAngle: 90,\n            // 最小角度改为0\n            minAngle: 0,\n            // 选中是扇区偏移量\n            selectedOffset: 10,\n\n            // If use strategy to avoid label overlapping\n            avoidLabelOverlap: true,\n            // 选择模式，默认关闭，可选single，multiple\n            // selectedMode: false,\n            // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）\n            // roseType: null,\n\n            label: {\n                normal: {\n                    // If rotate around circle\n                    rotate: false,\n                    show: true,\n                    // 'outer', 'inside', 'center'\n                    position: 'outer'\n                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                    // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数\n                },\n                emphasis: {}\n            },\n            // Enabled when label.normal.position is 'outer'\n            labelLine: {\n                normal: {\n                    show: true,\n                    // 引导线两段中的第一段长度\n                    length: 15,\n                    // 引导线两段中的第二段长度\n                    length2: 15,\n                    smooth: false,\n                    lineStyle: {\n                        // color: 各异,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderWidth: 1\n                },\n                emphasis: {}\n            },\n\n            animationEasing: 'cubicOut',\n\n            data: []\n        }\n    });\n\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\n    module.exports = PieSeries;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/PieSeries.js\n// module id = 427\n// module chunks = 1","\n\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n\n        data.each(function (idx) {\n            toggleItemSelected(\n                data.getItemGraphicEl(idx),\n                data.getItemLayout(idx),\n                seriesModel.isSelected(data.getName(idx)),\n                selectedOffset,\n                hasAnimation\n            );\n        });\n    }\n\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [dx * offset, dy * offset];\n\n        hasAnimation\n            // animateTo will stop revious animation like update transition\n            ? el.animate()\n                .when(200, {\n                    position: position\n                })\n                .start('bounceOut')\n            : el.attr('position', position);\n    }\n\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n\n        graphic.Group.call(this);\n\n        var sector = new graphic.Sector({\n            z2: 2\n        });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n\n        this.updateData(data, idx, true);\n\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis)\n            .on('normal', onNormal)\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal);\n    }\n\n    var piePieceProto = PiePiece.prototype;\n\n    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n        return {\n            fill: textStyleModel.getTextColor()\n                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            opacity: data.getItemVisual(idx, 'opacity'),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(\n                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)\n            )\n        };\n    }\n\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n\n        var sector = this.childAt(0);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n            sector.shape.endAngle = layout.startAngle;\n            graphic.updateProps(sector, {\n                shape: {\n                    endAngle: layout.endAngle\n                }\n            }, seriesModel, idx);\n        }\n        else {\n            graphic.updateProps(sector, {\n                shape: sectorShape\n            }, seriesModel, idx);\n        }\n\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        sector.useStyle(\n            zrUtil.defaults(\n                {\n                    lineJoin: 'bevel',\n                    fill: visualColor\n                },\n                itemStyleModel.getModel('normal').getItemStyle()\n            )\n        );\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n        // Toggle selected\n        toggleItemSelected(\n            this,\n            data.getItemLayout(idx),\n            itemModel.get('selected'),\n            seriesModel.get('selectedOffset'),\n            seriesModel.get('animation')\n        );\n\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r + 10\n                }\n            }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r\n                }\n            }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n            sector\n                .on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n\n        this._updateLabel(data, idx);\n\n        graphic.setHoverStyle(this);\n    };\n\n    piePieceProto._updateLabel = function (data, idx) {\n\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n                ]\n            }\n        }, seriesModel, idx);\n\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textVerticalAlign: labelLayout.verticalAlign,\n                textAlign: labelLayout.textAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [labelLayout.x, labelLayout.y],\n            z2: 10\n        });\n\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({\n            smooth: smooth\n        });\n    };\n\n    zrUtil.inherits(PiePiece, graphic.Group);\n\n\n    // Pie view\n    var Pie = require('../../view/Chart').extend({\n\n        type: 'pie',\n\n        init: function () {\n            var sectorGroup = new graphic.Group();\n            this._sectorGroup = sectorGroup;\n        },\n\n        render: function (seriesModel, ecModel, api, payload) {\n            if (payload && (payload.from === this.uid)) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var group = this.group;\n\n            var hasAnimation = ecModel.get('animation');\n            var isFirstRender = !oldData;\n\n            var onSectorClick = zrUtil.curry(\n                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n            );\n\n            var selectedMode = seriesModel.get('selectedMode');\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    if (isFirstRender) {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n\n                    selectedMode && piePiece.on('click', onSectorClick);\n\n                    data.setItemGraphicEl(idx, piePiece);\n\n                    group.add(piePiece);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                    piePiece.updateData(data, newIdx);\n\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                })\n                .remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                })\n                .execute();\n\n            if (hasAnimation && isFirstRender && data.count() > 0) {\n                var shape = data.getItemLayout(0);\n                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\n                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                group.setClipPath(this._createClipPath(\n                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n                ));\n            }\n\n            this._data = data;\n        },\n\n        dispose: function () {},\n\n        _createClipPath: function (\n            cx, cy, r, startAngle, clockwise, cb, seriesModel\n        ) {\n            var clipPath = new graphic.Sector({\n                shape: {\n                    cx: cx,\n                    cy: cy,\n                    r0: 0,\n                    r: r,\n                    startAngle: startAngle,\n                    endAngle: startAngle,\n                    clockwise: clockwise\n                }\n            });\n\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n                }\n            }, seriesModel, cb);\n\n            return clipPath;\n        },\n\n        /**\n         * @implement\n         */\n        containPoint: function (point, seriesModel) {\n            var data = seriesModel.getData();\n            var itemLayout = data.getItemLayout(0);\n            if (itemLayout) {\n                var dx = point[0] - itemLayout.cx;\n                var dy = point[1] - itemLayout.cy;\n                var radius = Math.sqrt(dx * dx + dy * dy);\n                return radius <= itemLayout.r && radius >= itemLayout.r0;\n            }\n        }\n\n    });\n\n    module.exports = Pie;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/PieView.js\n// module id = 428\n// module chunks = 1","'use strict';\n// FIXME emphasis label position is not same with normal label position\n\n\n    var textContain = require('zrender/lib/contain/text');\n\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n\n        // 压\n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start\n                    && j + 1 < end\n                    && list[j + 1].y > list[j].y + list[j].height\n                ) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n\n            shiftUp(end - 1, delta / 2);\n        }\n\n        // 弹\n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0\n                    && list[j].y > list[j - 1].y + list[j - 1].height\n                ) {\n                    break;\n                }\n            }\n        }\n\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0\n                ? isDownList                // 右侧\n                    ? Number.MAX_VALUE      // 下\n                    : 0                     // 上\n                : isDownList                // 左侧\n                    ? Number.MAX_VALUE      // 下\n                    : 0;                    // 上\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = (deltaY < r + length)\n                    ? Math.sqrt(\n                          (r + length + length2) * (r + length + length2)\n                          - deltaY * deltaY\n                      )\n                    : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // 右下，左下\n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // 右上，左上\n                    deltaX = lastDeltaX + 10;\n                }\n\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            }\n            else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            }\n            else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                }\n                else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n\n    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n\n            cx = layout.cx;\n            cy = layout.cy;\n\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            }\n            else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n                    var y3 = y2;\n\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n                }\n\n                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n            }\n            var font = labelModel.getModel('textStyle').getFont();\n\n            var labelRotate = labelModel.get('rotate')\n                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal')\n                        || data.getName(idx);\n            var textRect = textContain.getBoundingRect(\n                text, font, textAlign, 'top'\n            );\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                font: font,\n                rotation: labelRotate\n            };\n\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/labelLayout.js\n// module id = 429\n// module chunks = 1","// TODO minAngle\n\n\n\n    var numberUtil = require('../../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = require('./labelLayout');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n\n    module.exports = function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n\n            if (!zrUtil.isArray(radius)) {\n                radius = [0, radius];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [center, center];\n            }\n\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n\n            var data = seriesModel.getData();\n\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\n            var clockwise = seriesModel.get('clockwise');\n\n            var roseType = seriesModel.get('roseType');\n\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n\n            var currentAngle = startAngle;\n\n            var dir = clockwise ? 1 : -1;\n            data.each('value', function (value, idx) {\n                var angle;\n                // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n                if (roseType !== 'area') {\n                    angle = sum === 0 ? unitRadian : (value * unitRadian);\n                }\n                else {\n                    angle = PI2 / (data.count() || 1);\n                }\n\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                }\n                else {\n                    valueSumLargerThanMinAngle += value;\n                }\n\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType\n                        ? numberUtil.linearMap(value, extent, [r0, r])\n                        : r\n                });\n\n                currentAngle = endAngle;\n            }, true);\n\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 1e-3) {\n                    var angle = PI2 / data.count();\n                    data.each(function (idx) {\n                        var layout = data.getItemLayout(idx);\n                        layout.startAngle = startAngle + dir * idx * angle;\n                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                    });\n                }\n                else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        var layout = data.getItemLayout(idx);\n                        var angle = layout.angle === minAngle\n                            ? minAngle : value * unitRadian;\n                        layout.startAngle = currentAngle;\n                        layout.endAngle = currentAngle + dir * angle;\n                        currentAngle += dir * angle;\n                    });\n                }\n            }\n\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/pieLayout.js\n// module id = 430\n// module chunks = 1","/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n *\n * @module echarts/chart/helper/DataSelectable\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = {\n\n        updateSelectedMap: function (targetList) {\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap[target.name] = target;\n                return targetMap;\n            }, {});\n        },\n        /**\n         * @param {string} name\n         */\n        // PENGING If selectedMode is null ?\n        select: function (name) {\n            var targetMap = this._selectTargetMap;\n            var target = targetMap[name];\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                zrUtil.each(targetMap, function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            var target = this._selectTargetMap[name];\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name);\n                return target.selected;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            return target && target.selected;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/helper/selectableMixin.js\n// module id = 433\n// module chunks = 1","\n    module.exports = function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/processor/dataFilter.js\n// module id = 445\n// module chunks = 1","// Pick color from palette for each data item\n\n\n    module.exports = function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    // FIXME Performance\n                    var itemModel = dataAll.getItemModel(rawIdx);\n                    var filteredIdx = idxMap[rawIdx];\n\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null\n                        && data.getItemVisual(filteredIdx, 'color', true);\n\n                    if (!singleDataColor) {\n                        var color = itemModel.get('itemStyle.normal.color')\n                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    }\n                    else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/visual/dataColor.js\n// module id = 449\n// module chunks = 1","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../node_modules/css-loader/index.js?-autoprefixer&sourceMap!./../../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-1d47d409!./../../../node_modules/sass-loader/index.js?sourceMap!./../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./dashboard.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../node_modules/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../node_modules/css-loader/index.js?-autoprefixer&sourceMap!./../../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-1d47d409!./../../../node_modules/sass-loader/index.js?sourceMap!./../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./dashboard.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../../node_modules/css-loader/index.js?-autoprefixer&sourceMap!./../../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-1d47d409!./../../../node_modules/sass-loader/index.js?sourceMap!./../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./dashboard.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!./~/vue-style-loader!./~/css-loader?-autoprefixer&sourceMap!./~/vue-loader/lib/style-rewriter.js?id=data-v-1d47d409!./~/sass-loader?sourceMap!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/views/ex/dashboard.vue\n// module id = 474\n// module chunks = 1","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js?-autoprefixer&sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-901a6116!./../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./kt-pie-echart.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js?-autoprefixer&sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-901a6116!./../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./kt-pie-echart.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js?-autoprefixer&sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-901a6116!./../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./kt-pie-echart.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!./~/vue-style-loader!./~/css-loader?-autoprefixer&sourceMap!./~/vue-loader/lib/style-rewriter.js?id=data-v-901a6116!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/kt-pie-echart.vue\n// module id = 481\n// module chunks = 1","var __vue_exports__, __vue_options__\nvar __vue_styles__ = {}\n\n/* styles */\nrequire(\"!!./../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"extract\\\":true,\\\"remove\\\":true}!vue-style-loader!css-loader?-autoprefixer&sourceMap!vue-loader/lib/style-rewriter?id=data-v-901a6116!vue-loader/lib/selector?type=styles&index=0!./kt-pie-echart.vue\")\n\n/* script */\n__vue_exports__ = require(\"!!babel-loader!vue-loader/lib/selector?type=script&index=0!./kt-pie-echart.vue\")\n\n/* template */\nvar __vue_template__ = require(\"!!vue-loader/lib/template-compiler?id=data-v-901a6116!vue-loader/lib/template-loader?raw&engine=pug!vue-loader/lib/selector?type=template&index=0!./kt-pie-echart.vue\")\n__vue_options__ = __vue_exports__ = __vue_exports__ || {}\nif (\n  typeof __vue_exports__.default === \"object\" ||\n  typeof __vue_exports__.default === \"function\"\n) {\n__vue_options__ = __vue_exports__ = __vue_exports__.default\n}\nif (typeof __vue_options__ === \"function\") {\n  __vue_options__ = __vue_options__.options\n}\n\n__vue_options__.render = __vue_template__.render\n__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\nmodule.exports = __vue_exports__\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/kt-pie-echart.vue\n// module id = 490\n// module chunks = 1","var __vue_exports__, __vue_options__\nvar __vue_styles__ = {}\n\n/* styles */\nrequire(\"!!./../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"extract\\\":true,\\\"remove\\\":true}!vue-style-loader!css-loader?-autoprefixer&sourceMap!vue-loader/lib/style-rewriter?id=data-v-1d47d409!sass-loader?sourceMap!vue-loader/lib/selector?type=styles&index=0!./dashboard.vue\")\n\n/* script */\n__vue_exports__ = require(\"!!babel-loader!vue-loader/lib/selector?type=script&index=0!./dashboard.vue\")\n\n/* template */\nvar __vue_template__ = require(\"!!vue-loader/lib/template-compiler?id=data-v-1d47d409!vue-loader/lib/template-loader?raw&engine=pug!vue-loader/lib/selector?type=template&index=0!./dashboard.vue\")\n__vue_options__ = __vue_exports__ = __vue_exports__ || {}\nif (\n  typeof __vue_exports__.default === \"object\" ||\n  typeof __vue_exports__.default === \"function\"\n) {\n__vue_options__ = __vue_exports__ = __vue_exports__.default\n}\nif (typeof __vue_options__ === \"function\") {\n  __vue_options__ = __vue_options__.options\n}\n\n__vue_options__.render = __vue_template__.render\n__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\nmodule.exports = __vue_exports__\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/ex/dashboard.vue\n// module id = 493\n// module chunks = 1","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._c;\n  return _c('div', {\n    staticClass: \"overview\"\n  }, [_c('div', {\n    staticClass: \"today-overview\"\n  }, [_c('h2', [_vm._v(\"今日总览\")]), _c('div', {\n    staticClass: \"overview-left fl\"\n  }, [_c('h3', [_vm._v(\"当前存续金额（元）\")]), _c('div', {\n    staticClass: \"overview-left-middle\"\n  }, [_c('i', {\n    staticClass: \"icon-icomoon icon-overview\"\n  }), _c('span', [_vm._v(_vm._s(_vm._f(\"ktCurrency\")(_vm.balance.total, '')))])]), _c('div', {\n    staticClass: \"overview-left-down\"\n  }, [_c('div', {\n    staticClass: \"Principal fl\"\n  }, [_c('span', [_vm._v(\"存续本金\"), _c('em', [_vm._v(_vm._s(_vm._f(\"ktCurrency\")(_vm.balance.principal, '')))])])]), _c('div', {\n    staticClass: \"Interest fr\"\n  }, [_c('span', [_vm._v(\"存续利息\"), _c('em', [_vm._v(_vm._s(_vm._f(\"ktCurrency\")(_vm.balance.interest, '')))])])])])]), _c('div', {\n    staticClass: \"overview-right fr\"\n  }, [_c('h3', [_vm._v(\"今日存量产品占比分析\")]), _c('div', {\n    staticClass: \"overview-right-middle\"\n  }, [_c('kt-pie-echart', {\n    attrs: {\n      \"chart-option\": _vm.pieChartOption\n    }\n  })])])]), _c('div', {\n    staticClass: \"today-square\"\n  }, [_c('h2', [_vm._v(\"今日清算\"), _c('el-tooltip', {\n    attrs: {\n      \"effect\": \"dark\",\n      \"placement\": \"right\"\n    }\n  }, [_c('div', {\n    staticClass: \"Prompt\",\n    slot: \"content\"\n  }, [_vm._v(\"展示今日需资金清算的所有产品，包括今日流入资金的入账确认以及今日流出资金的划款确认 \"), _c('br'), _vm._v(\" 待执行-清算数据正常可以进行清算执行操作确认 \"), _c('br'), _vm._v(\" 不可执行-清算数据尚未更新或者异常导致无法执行清算确认 \"), _c('br'), _vm._v(\" 已执行-已经进行过清算执行操作确认 \"), _c('br'), _vm._v(\" 已过期-当前时间已经晚于需确认清算执行的最晚时限\")]), _c('i', {\n    staticClass: \"icon-icomoon icon-explain\"\n  })]), _c('div', {\n    staticClass: \"information fr\"\n  }, [_c('span', [_vm._v(_vm._s(_vm.summary.executed))]), _c('em', [_vm._v(\"条 已执行，\")]), _c('span', [_vm._v(_vm._s(_vm.summary.pending_execute))]), _c('em', [_vm._v(\"条 待执行，\")]), _c('span', [_vm._v(_vm._s(_vm.summary.cant_execute))]), _c('em', [_vm._v(\"条 不可执行，\")]), _c('span', [_vm._v(_vm._s(_vm.summary.expired))]), _c('em', [_vm._v(\"条 已过期\")])])]), _c('div', {\n    staticClass: \"overview-table\"\n  }, _vm._l((_vm.virtualAssets), function(item, key) {\n    return _c('table', [_c('thead', [_c('tr', [_c('th', [_vm._v(_vm._s(key))])])]), _vm._l((item), function(product) {\n      return _c('tbody', [_c('tr', {\n        on: {\n          \"click\": function($event) {\n            _vm.toDetails(product)\n          }\n        }\n      }, [_c('td', [_c('span', [_vm._v(_vm._s(product.name))])]), _c('td', [(product.inflow_desc) ? _c('span', [_vm._v(_vm._s(product.inflow_desc)), _c('em', {\n        staticClass: \"red-color\"\n      }, [_vm._v(_vm._s(_vm._f(\"ktCurrency\")(product.inflow)))])]) : _vm._e()]), _c('td', [(product.outflow_desc) ? _c('span', [_vm._v(_vm._s(product.outflow_desc)), _c('em', {\n        staticClass: \"green-color\"\n      }, [_vm._v(_vm._s(_vm._f(\"ktCurrency\")(product.outflow)))])]) : _vm._e()]), _c('td', [_c('span', [_vm._v(_vm._s(product.inflow >= product.outflow ? '净流入' : '净流出')), _c('em', {\n        class: [product.inflow >= product.outflow ? 'red-color' : 'green-color']\n      }, [_vm._v(_vm._s(_vm._f(\"ktCurrency\")(product.net_cash_flow)))])])]), _c('td', [_c('span', {\n        staticClass: \"bg-color\"\n      }, [_vm._v(_vm._s(product.execute_method))])]), _c('td', {\n        staticClass: \"implement status-column\"\n      }, [_c('i', {\n        staticClass: \"icon-icomoon\",\n        class: _vm._f(\"excuteStatusIcon\")(product.execute_status)\n      }), _c('em', {\n        staticClass: \"em-implement\"\n      }, [_vm._v(_vm._s(product.execute_status))])]), _c('td', [_c('span', {\n        directives: [{\n          name: \"show\",\n          rawName: \"v-show\",\n          value: (product.execute_status === '待执行' ? true : false),\n          expression: \"product.execute_status === '待执行' ? true : false\"\n        }]\n      }, [_vm._v(\"结算时限:\"), _c('em', [_vm._v(_vm._s(product.due_at))])])])])])\n    })], true)\n  }))])])\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-1d47d409!./~/vue-loader/lib/template-loader.js?raw&engine=pug!./~/vue-loader/lib/selector.js?type=template&index=0!./src/views/ex/dashboard.vue\n// module id = 502\n// module chunks = 1","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._c;\n  return _c('div', {\n    ref: \"echart\",\n    staticClass: \"pie-echarts\"\n  })\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-901a6116!./~/vue-loader/lib/template-loader.js?raw&engine=pug!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/kt-pie-echart.vue\n// module id = 509\n// module chunks = 1"],"sourceRoot":""}